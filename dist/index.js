// build/dist/pkg/common/_commonjsHelpers-8c19dec8.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base) {
      return commonjsRequire(path, base === void 0 || base === null ? module.path : base);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}

// build/dist/pkg/common/index-04edb6a1.js
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
var react_production_min = createCommonjsModule(function(module, exports) {
  var n2 = 60103, p2 = 60106;
  exports.Fragment = 60107;
  exports.StrictMode = 60108;
  exports.Profiler = 60114;
  var q2 = 60109, r2 = 60110, t2 = 60112;
  exports.Suspense = 60113;
  var u = 60115, v2 = 60116;
  if (typeof Symbol === "function" && Symbol.for) {
    var w2 = Symbol.for;
    n2 = w2("react.element");
    p2 = w2("react.portal");
    exports.Fragment = w2("react.fragment");
    exports.StrictMode = w2("react.strict_mode");
    exports.Profiler = w2("react.profiler");
    q2 = w2("react.provider");
    r2 = w2("react.context");
    t2 = w2("react.forward_ref");
    exports.Suspense = w2("react.suspense");
    u = w2("react.memo");
    v2 = w2("react.lazy");
  }
  var x2 = typeof Symbol === "function" && Symbol.iterator;
  function y3(a) {
    if (a === null || typeof a !== "object")
      return null;
    a = x2 && a[x2] || a["@@iterator"];
    return typeof a === "function" ? a : null;
  }
  function z2(a) {
    for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
      b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var A2 = {isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  }}, B2 = {};
  function C(a, b2, c2) {
    this.props = a;
    this.context = b2;
    this.refs = B2;
    this.updater = c2 || A2;
  }
  C.prototype.isReactComponent = {};
  C.prototype.setState = function(a, b2) {
    if (typeof a !== "object" && typeof a !== "function" && a != null)
      throw Error(z2(85));
    this.updater.enqueueSetState(this, a, b2, "setState");
  };
  C.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };
  function D2() {
  }
  D2.prototype = C.prototype;
  function E(a, b2, c2) {
    this.props = a;
    this.context = b2;
    this.refs = B2;
    this.updater = c2 || A2;
  }
  var F2 = E.prototype = new D2();
  F2.constructor = E;
  objectAssign(F2, C.prototype);
  F2.isPureReactComponent = true;
  var G2 = {current: null}, H2 = Object.prototype.hasOwnProperty, I2 = {key: true, ref: true, __self: true, __source: true};
  function J(a, b2, c2) {
    var e2, d2 = {}, k2 = null, h2 = null;
    if (b2 != null)
      for (e2 in b2.ref !== void 0 && (h2 = b2.ref), b2.key !== void 0 && (k2 = "" + b2.key), b2)
        H2.call(b2, e2) && !I2.hasOwnProperty(e2) && (d2[e2] = b2[e2]);
    var g2 = arguments.length - 2;
    if (g2 === 1)
      d2.children = c2;
    else if (1 < g2) {
      for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
        f2[m2] = arguments[m2 + 2];
      d2.children = f2;
    }
    if (a && a.defaultProps)
      for (e2 in g2 = a.defaultProps, g2)
        d2[e2] === void 0 && (d2[e2] = g2[e2]);
    return {$$typeof: n2, type: a, key: k2, ref: h2, props: d2, _owner: G2.current};
  }
  function K(a, b2) {
    return {$$typeof: n2, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner};
  }
  function L(a) {
    return typeof a === "object" && a !== null && a.$$typeof === n2;
  }
  function escape(a) {
    var b2 = {"=": "=0", ":": "=2"};
    return "$" + a.replace(/[=:]/g, function(a2) {
      return b2[a2];
    });
  }
  var M2 = /\/+/g;
  function N2(a, b2) {
    return typeof a === "object" && a !== null && a.key != null ? escape("" + a.key) : b2.toString(36);
  }
  function O2(a, b2, c2, e2, d2) {
    var k2 = typeof a;
    if (k2 === "undefined" || k2 === "boolean")
      a = null;
    var h2 = false;
    if (a === null)
      h2 = true;
    else
      switch (k2) {
        case "string":
        case "number":
          h2 = true;
          break;
        case "object":
          switch (a.$$typeof) {
            case n2:
            case p2:
              h2 = true;
          }
      }
    if (h2)
      return h2 = a, d2 = d2(h2), a = e2 === "" ? "." + N2(h2, 0) : e2, Array.isArray(d2) ? (c2 = "", a != null && (c2 = a.replace(M2, "$&/") + "/"), O2(d2, b2, c2, "", function(a2) {
        return a2;
      })) : d2 != null && (L(d2) && (d2 = K(d2, c2 + (!d2.key || h2 && h2.key === d2.key ? "" : ("" + d2.key).replace(M2, "$&/") + "/") + a)), b2.push(d2)), 1;
    h2 = 0;
    e2 = e2 === "" ? "." : e2 + ":";
    if (Array.isArray(a))
      for (var g2 = 0; g2 < a.length; g2++) {
        k2 = a[g2];
        var f2 = e2 + N2(k2, g2);
        h2 += O2(k2, b2, c2, f2, d2);
      }
    else if (f2 = y3(a), typeof f2 === "function")
      for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
        k2 = k2.value, f2 = e2 + N2(k2, g2++), h2 += O2(k2, b2, c2, f2, d2);
    else if (k2 === "object")
      throw b2 = "" + a, Error(z2(31, b2 === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2));
    return h2;
  }
  function P2(a, b2, c2) {
    if (a == null)
      return a;
    var e2 = [], d2 = 0;
    O2(a, e2, "", "", function(a2) {
      return b2.call(c2, a2, d2++);
    });
    return e2;
  }
  function Q(a) {
    if (a._status === -1) {
      var b2 = a._result;
      b2 = b2();
      a._status = 0;
      a._result = b2;
      b2.then(function(b3) {
        a._status === 0 && (b3 = b3.default, a._status = 1, a._result = b3);
      }, function(b3) {
        a._status === 0 && (a._status = 2, a._result = b3);
      });
    }
    if (a._status === 1)
      return a._result;
    throw a._result;
  }
  var R2 = {current: null};
  function S2() {
    var a = R2.current;
    if (a === null)
      throw Error(z2(321));
    return a;
  }
  var T2 = {ReactCurrentDispatcher: R2, ReactCurrentBatchConfig: {transition: 0}, ReactCurrentOwner: G2, IsSomeRendererActing: {current: false}, assign: objectAssign};
  exports.Children = {map: P2, forEach: function(a, b2, c2) {
    P2(a, function() {
      b2.apply(this, arguments);
    }, c2);
  }, count: function(a) {
    var b2 = 0;
    P2(a, function() {
      b2++;
    });
    return b2;
  }, toArray: function(a) {
    return P2(a, function(a2) {
      return a2;
    }) || [];
  }, only: function(a) {
    if (!L(a))
      throw Error(z2(143));
    return a;
  }};
  exports.Component = C;
  exports.PureComponent = E;
  exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T2;
  exports.cloneElement = function(a, b2, c2) {
    if (a === null || a === void 0)
      throw Error(z2(267, a));
    var e2 = objectAssign({}, a.props), d2 = a.key, k2 = a.ref, h2 = a._owner;
    if (b2 != null) {
      b2.ref !== void 0 && (k2 = b2.ref, h2 = G2.current);
      b2.key !== void 0 && (d2 = "" + b2.key);
      if (a.type && a.type.defaultProps)
        var g2 = a.type.defaultProps;
      for (f2 in b2)
        H2.call(b2, f2) && !I2.hasOwnProperty(f2) && (e2[f2] = b2[f2] === void 0 && g2 !== void 0 ? g2[f2] : b2[f2]);
    }
    var f2 = arguments.length - 2;
    if (f2 === 1)
      e2.children = c2;
    else if (1 < f2) {
      g2 = Array(f2);
      for (var m2 = 0; m2 < f2; m2++)
        g2[m2] = arguments[m2 + 2];
      e2.children = g2;
    }
    return {
      $$typeof: n2,
      type: a.type,
      key: d2,
      ref: k2,
      props: e2,
      _owner: h2
    };
  };
  exports.createContext = function(a, b2) {
    b2 === void 0 && (b2 = null);
    a = {$$typeof: r2, _calculateChangedBits: b2, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null};
    a.Provider = {$$typeof: q2, _context: a};
    return a.Consumer = a;
  };
  exports.createElement = J;
  exports.createFactory = function(a) {
    var b2 = J.bind(null, a);
    b2.type = a;
    return b2;
  };
  exports.createRef = function() {
    return {current: null};
  };
  exports.forwardRef = function(a) {
    return {$$typeof: t2, render: a};
  };
  exports.isValidElement = L;
  exports.lazy = function(a) {
    return {$$typeof: v2, _payload: {_status: -1, _result: a}, _init: Q};
  };
  exports.memo = function(a, b2) {
    return {$$typeof: u, type: a, compare: b2 === void 0 ? null : b2};
  };
  exports.useCallback = function(a, b2) {
    return S2().useCallback(a, b2);
  };
  exports.useContext = function(a, b2) {
    return S2().useContext(a, b2);
  };
  exports.useDebugValue = function() {
  };
  exports.useEffect = function(a, b2) {
    return S2().useEffect(a, b2);
  };
  exports.useImperativeHandle = function(a, b2, c2) {
    return S2().useImperativeHandle(a, b2, c2);
  };
  exports.useLayoutEffect = function(a, b2) {
    return S2().useLayoutEffect(a, b2);
  };
  exports.useMemo = function(a, b2) {
    return S2().useMemo(a, b2);
  };
  exports.useReducer = function(a, b2, c2) {
    return S2().useReducer(a, b2, c2);
  };
  exports.useRef = function(a) {
    return S2().useRef(a);
  };
  exports.useState = function(a) {
    return S2().useState(a);
  };
  exports.version = "17.0.2";
});
var react = createCommonjsModule(function(module) {
  {
    module.exports = react_production_min;
  }
});

// build/dist/pkg/react.js
var Fragment = react.Fragment;
var useEffect = react.useEffect;
var useState = react.useState;

// build/dist/pkg/react-dom.js
var scheduler_production_min = createCommonjsModule(function(module, exports) {
  var f2, g2, h2, k2;
  if (typeof performance === "object" && typeof performance.now === "function") {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  if (typeof window === "undefined" || typeof MessageChannel !== "function") {
    var t2 = null, u = null, w2 = function() {
      if (t2 !== null)
        try {
          var a = exports.unstable_now();
          t2(true, a);
          t2 = null;
        } catch (b2) {
          throw setTimeout(w2, 0), b2;
        }
    };
    f2 = function(a) {
      t2 !== null ? setTimeout(f2, 0, a) : (t2 = a, setTimeout(w2, 0));
    };
    g2 = function(a, b2) {
      u = setTimeout(a, b2);
    };
    h2 = function() {
      clearTimeout(u);
    };
    exports.unstable_shouldYield = function() {
      return false;
    };
    k2 = exports.unstable_forceFrameRate = function() {
    };
  } else {
    var x2 = window.setTimeout, y3 = window.clearTimeout;
    if (typeof console !== "undefined") {
      var z2 = window.cancelAnimationFrame;
      typeof window.requestAnimationFrame !== "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      typeof z2 !== "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    var A2 = false, B2 = null, C = -1, D2 = 5, E = 0;
    exports.unstable_shouldYield = function() {
      return exports.unstable_now() >= E;
    };
    k2 = function() {
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    var F2 = new MessageChannel(), G2 = F2.port2;
    F2.port1.onmessage = function() {
      if (B2 !== null) {
        var a = exports.unstable_now();
        E = a + D2;
        try {
          B2(true, a) ? G2.postMessage(null) : (A2 = false, B2 = null);
        } catch (b2) {
          throw G2.postMessage(null), b2;
        }
      } else
        A2 = false;
    };
    f2 = function(a) {
      B2 = a;
      A2 || (A2 = true, G2.postMessage(null));
    };
    g2 = function(a, b2) {
      C = x2(function() {
        a(exports.unstable_now());
      }, b2);
    };
    h2 = function() {
      y3(C);
      C = -1;
    };
  }
  function H2(a, b2) {
    var c2 = a.length;
    a.push(b2);
    a:
      for (; ; ) {
        var d2 = c2 - 1 >>> 1, e2 = a[d2];
        if (e2 !== void 0 && 0 < I2(e2, b2))
          a[d2] = b2, a[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function J(a) {
    a = a[0];
    return a === void 0 ? null : a;
  }
  function K(a) {
    var b2 = a[0];
    if (b2 !== void 0) {
      var c2 = a.pop();
      if (c2 !== b2) {
        a[0] = c2;
        a:
          for (var d2 = 0, e2 = a.length; d2 < e2; ) {
            var m2 = 2 * (d2 + 1) - 1, n2 = a[m2], v2 = m2 + 1, r2 = a[v2];
            if (n2 !== void 0 && 0 > I2(n2, c2))
              r2 !== void 0 && 0 > I2(r2, n2) ? (a[d2] = r2, a[v2] = c2, d2 = v2) : (a[d2] = n2, a[m2] = c2, d2 = m2);
            else if (r2 !== void 0 && 0 > I2(r2, c2))
              a[d2] = r2, a[v2] = c2, d2 = v2;
            else
              break a;
          }
      }
      return b2;
    }
    return null;
  }
  function I2(a, b2) {
    var c2 = a.sortIndex - b2.sortIndex;
    return c2 !== 0 ? c2 : a.id - b2.id;
  }
  var L = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q = false, R2 = false, S2 = false;
  function T2(a) {
    for (var b2 = J(M2); b2 !== null; ) {
      if (b2.callback === null)
        K(M2);
      else if (b2.startTime <= a)
        K(M2), b2.sortIndex = b2.expirationTime, H2(L, b2);
      else
        break;
      b2 = J(M2);
    }
  }
  function U2(a) {
    S2 = false;
    T2(a);
    if (!R2)
      if (J(L) !== null)
        R2 = true, f2(V2);
      else {
        var b2 = J(M2);
        b2 !== null && g2(U2, b2.startTime - a);
      }
  }
  function V2(a, b2) {
    R2 = false;
    S2 && (S2 = false, h2());
    Q = true;
    var c2 = P2;
    try {
      T2(b2);
      for (O2 = J(L); O2 !== null && (!(O2.expirationTime > b2) || a && !exports.unstable_shouldYield()); ) {
        var d2 = O2.callback;
        if (typeof d2 === "function") {
          O2.callback = null;
          P2 = O2.priorityLevel;
          var e2 = d2(O2.expirationTime <= b2);
          b2 = exports.unstable_now();
          typeof e2 === "function" ? O2.callback = e2 : O2 === J(L) && K(L);
          T2(b2);
        } else
          K(L);
        O2 = J(L);
      }
      if (O2 !== null)
        var m2 = true;
      else {
        var n2 = J(M2);
        n2 !== null && g2(U2, n2.startTime - b2);
        m2 = false;
      }
      return m2;
    } finally {
      O2 = null, P2 = c2, Q = false;
    }
  }
  var W2 = k2;
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    R2 || Q || (R2 = true, f2(V2));
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return P2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return J(L);
  };
  exports.unstable_next = function(a) {
    switch (P2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = P2;
    }
    var c2 = P2;
    P2 = b2;
    try {
      return a();
    } finally {
      P2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = W2;
  exports.unstable_runWithPriority = function(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c2 = P2;
    P2 = a;
    try {
      return b2();
    } finally {
      P2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a, b2, c2) {
    var d2 = exports.unstable_now();
    typeof c2 === "object" && c2 !== null ? (c2 = c2.delay, c2 = typeof c2 === "number" && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a = {id: N2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1};
    c2 > d2 ? (a.sortIndex = c2, H2(M2, a), J(L) === null && a === J(M2) && (S2 ? h2() : S2 = true, g2(U2, c2 - d2))) : (a.sortIndex = e2, H2(L, a), R2 || Q || (R2 = true, f2(V2)));
    return a;
  };
  exports.unstable_wrapCallback = function(a) {
    var b2 = P2;
    return function() {
      var c2 = P2;
      P2 = b2;
      try {
        return a.apply(this, arguments);
      } finally {
        P2 = c2;
      }
    };
  };
});
var scheduler = createCommonjsModule(function(module) {
  {
    module.exports = scheduler_production_min;
  }
});
function y(a) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
if (!react)
  throw Error(y(227));
var ba = new Set();
var ca = {};
function da(a, b2) {
  ea(a, b2);
  ea(a + "Capture", b2);
}
function ea(a, b2) {
  ca[a] = b2;
  for (a = 0; a < b2.length; a++)
    ba.add(b2[a]);
}
var fa = !(typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined");
var ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
var ia = Object.prototype.hasOwnProperty;
var ja = {};
var ka = {};
function la(a) {
  if (ia.call(ka, a))
    return true;
  if (ia.call(ja, a))
    return false;
  if (ha.test(a))
    return ka[a] = true;
  ja[a] = true;
  return false;
}
function ma(a, b2, c2, d2) {
  if (c2 !== null && c2.type === 0)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (c2 !== null)
        return !c2.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return a !== "data-" && a !== "aria-";
    default:
      return false;
  }
}
function na(a, b2, c2, d2) {
  if (b2 === null || typeof b2 === "undefined" || ma(a, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (c2 !== null)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return b2 === false;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function B(a, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = b2 === 2 || b2 === 3 || b2 === 4;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var D = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  D[a] = new B(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b2 = a[0];
  D[b2] = new B(b2, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  D[a] = new B(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  D[a] = new B(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  D[a] = new B(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  D[a] = new B(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  D[a] = new B(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  D[a] = new B(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  D[a] = new B(a, 5, false, a.toLowerCase(), null, false, false);
});
var oa = /[\-:]([a-z])/g;
function pa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b2 = a.replace(oa, pa);
  D[b2] = new B(b2, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b2 = a.replace(oa, pa);
  D[b2] = new B(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b2 = a.replace(oa, pa);
  D[b2] = new B(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  D[a] = new B(a, 1, false, a.toLowerCase(), null, false, false);
});
D.xlinkHref = new B("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  D[a] = new B(a, 1, false, a.toLowerCase(), null, true, true);
});
function qa(a, b2, c2, d2) {
  var e2 = D.hasOwnProperty(b2) ? D[b2] : null;
  var f2 = e2 !== null ? e2.type === 0 : d2 ? false : !(2 < b2.length) || b2[0] !== "o" && b2[0] !== "O" || b2[1] !== "n" && b2[1] !== "N" ? false : true;
  f2 || (na(b2, c2, e2, d2) && (c2 = null), d2 || e2 === null ? la(b2) && (c2 === null ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = c2 === null ? e2.type === 3 ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, c2 === null ? a.removeAttribute(b2) : (e2 = e2.type, c2 = e2 === 3 || e2 === 4 && c2 === true ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2))));
}
var ra = react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
var sa = 60103;
var ta = 60106;
var ua = 60107;
var wa = 60108;
var xa = 60114;
var ya = 60109;
var za = 60110;
var Aa = 60112;
var Ba = 60113;
var Ca = 60120;
var Da = 60115;
var Ea = 60116;
var Fa = 60121;
var Ga = 60128;
var Ha = 60129;
var Ia = 60130;
var Ja = 60131;
if (typeof Symbol === "function" && Symbol.for) {
  E = Symbol.for;
  sa = E("react.element");
  ta = E("react.portal");
  ua = E("react.fragment");
  wa = E("react.strict_mode");
  xa = E("react.profiler");
  ya = E("react.provider");
  za = E("react.context");
  Aa = E("react.forward_ref");
  Ba = E("react.suspense");
  Ca = E("react.suspense_list");
  Da = E("react.memo");
  Ea = E("react.lazy");
  Fa = E("react.block");
  E("react.scope");
  Ga = E("react.opaque.id");
  Ha = E("react.debug_trace_mode");
  Ia = E("react.offscreen");
  Ja = E("react.legacy_hidden");
}
var E;
var Ka = typeof Symbol === "function" && Symbol.iterator;
function La(a) {
  if (a === null || typeof a !== "object")
    return null;
  a = Ka && a[Ka] || a["@@iterator"];
  return typeof a === "function" ? a : null;
}
var Ma;
function Na(a) {
  if (Ma === void 0)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      Ma = b2 && b2[1] || "";
    }
  return "\n" + Ma + a;
}
var Oa = false;
function Pa(a, b2) {
  if (!a || Oa)
    return "";
  Oa = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", {set: function() {
        throw Error();
      }}), typeof Reflect === "object" && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (k2) {
          var d2 = k2;
        }
        Reflect.construct(a, [], b2);
      } else {
        try {
          b2.call();
        } catch (k2) {
          d2 = k2;
        }
        a.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (k2) {
        d2 = k2;
      }
      a();
    }
  } catch (k2) {
    if (k2 && d2 && typeof k2.stack === "string") {
      for (var e2 = k2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (g2 !== 1 || h2 !== 1) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2])
                return "\n" + e2[g2].replace(" at new ", " at ");
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Oa = false, Error.prepareStackTrace = c2;
  }
  return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
}
function Qa(a) {
  switch (a.tag) {
    case 5:
      return Na(a.type);
    case 16:
      return Na("Lazy");
    case 13:
      return Na("Suspense");
    case 19:
      return Na("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Pa(a.type, false), a;
    case 11:
      return a = Pa(a.type.render, false), a;
    case 22:
      return a = Pa(a.type._render, false), a;
    case 1:
      return a = Pa(a.type, true), a;
    default:
      return "";
  }
}
function Ra(a) {
  if (a == null)
    return null;
  if (typeof a === "function")
    return a.displayName || a.name || null;
  if (typeof a === "string")
    return a;
  switch (a) {
    case ua:
      return "Fragment";
    case ta:
      return "Portal";
    case xa:
      return "Profiler";
    case wa:
      return "StrictMode";
    case Ba:
      return "Suspense";
    case Ca:
      return "SuspenseList";
  }
  if (typeof a === "object")
    switch (a.$$typeof) {
      case za:
        return (a.displayName || "Context") + ".Consumer";
      case ya:
        return (a._context.displayName || "Context") + ".Provider";
      case Aa:
        var b2 = a.render;
        b2 = b2.displayName || b2.name || "";
        return a.displayName || (b2 !== "" ? "ForwardRef(" + b2 + ")" : "ForwardRef");
      case Da:
        return Ra(a.type);
      case Fa:
        return Ra(a._render);
      case Ea:
        b2 = a._payload;
        a = a._init;
        try {
          return Ra(a(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b2 = a.type;
  return (a = a.nodeName) && a.toLowerCase() === "input" && (b2 === "checkbox" || b2 === "radio");
}
function Ua(a) {
  var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
  if (!a.hasOwnProperty(b2) && typeof c2 !== "undefined" && typeof c2.get === "function" && typeof c2.set === "function") {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a, b2, {configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d2 = "" + a2;
      f2.call(this, a2);
    }});
    Object.defineProperty(a, b2, {enumerable: c2.enumerable});
    return {getValue: function() {
      return d2;
    }, setValue: function(a2) {
      d2 = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b2];
    }};
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b2 = a._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d2;
  return a !== c2 ? (b2.setValue(a), true) : false;
}
function Xa(a) {
  a = a || (typeof document !== "undefined" ? document : void 0);
  if (typeof a === "undefined")
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b2) {
    return a.body;
  }
}
function Ya(a, b2) {
  var c2 = b2.checked;
  return objectAssign({}, b2, {defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c2 != null ? c2 : a._wrapperState.initialChecked});
}
function Za(a, b2) {
  var c2 = b2.defaultValue == null ? "" : b2.defaultValue, d2 = b2.checked != null ? b2.checked : b2.defaultChecked;
  c2 = Sa(b2.value != null ? b2.value : c2);
  a._wrapperState = {initialChecked: d2, initialValue: c2, controlled: b2.type === "checkbox" || b2.type === "radio" ? b2.checked != null : b2.value != null};
}
function $a(a, b2) {
  b2 = b2.checked;
  b2 != null && qa(a, "checked", b2, false);
}
function ab(a, b2) {
  $a(a, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (c2 != null)
    if (d2 === "number") {
      if (c2 === 0 && a.value === "" || a.value != c2)
        a.value = "" + c2;
    } else
      a.value !== "" + c2 && (a.value = "" + c2);
  else if (d2 === "submit" || d2 === "reset") {
    a.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? bb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && bb(a, b2.type, Sa(b2.defaultValue));
  b2.checked == null && b2.defaultChecked != null && (a.defaultChecked = !!b2.defaultChecked);
}
function cb(a, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!(d2 !== "submit" && d2 !== "reset" || b2.value !== void 0 && b2.value !== null))
      return;
    b2 = "" + a._wrapperState.initialValue;
    c2 || b2 === a.value || (a.value = b2);
    a.defaultValue = b2;
  }
  c2 = a.name;
  c2 !== "" && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  c2 !== "" && (a.name = c2);
}
function bb(a, b2, c2) {
  if (b2 !== "number" || Xa(a.ownerDocument) !== a)
    c2 == null ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
}
function db(a) {
  var b2 = "";
  react.Children.forEach(a, function(a2) {
    a2 != null && (b2 += a2);
  });
  return b2;
}
function eb(a, b2) {
  a = objectAssign({children: void 0}, b2);
  if (b2 = db(b2.children))
    a.children = b2;
  return a;
}
function fb(a, b2, c2, d2) {
  a = a.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a.length; c2++)
      e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c2) {
        a[e2].selected = true;
        d2 && (a[e2].defaultSelected = true);
        return;
      }
      b2 !== null || a[e2].disabled || (b2 = a[e2]);
    }
    b2 !== null && (b2.selected = true);
  }
}
function gb(a, b2) {
  if (b2.dangerouslySetInnerHTML != null)
    throw Error(y(91));
  return objectAssign({}, b2, {value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue});
}
function hb(a, b2) {
  var c2 = b2.value;
  if (c2 == null) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (c2 != null) {
      if (b2 != null)
        throw Error(y(92));
      if (Array.isArray(c2)) {
        if (!(1 >= c2.length))
          throw Error(y(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    b2 == null && (b2 = "");
    c2 = b2;
  }
  a._wrapperState = {initialValue: Sa(c2)};
}
function ib(a, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  c2 != null && (c2 = "" + c2, c2 !== a.value && (a.value = c2), b2.defaultValue == null && a.defaultValue !== c2 && (a.defaultValue = c2));
  d2 != null && (a.defaultValue = "" + d2);
}
function jb(a) {
  var b2 = a.textContent;
  b2 === a._wrapperState.initialValue && b2 !== "" && b2 !== null && (a.value = b2);
}
var kb = {html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg"};
function lb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mb(a, b2) {
  return a == null || a === "http://www.w3.org/1999/xhtml" ? lb(b2) : a === "http://www.w3.org/2000/svg" && b2 === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a;
}
var nb;
var ob = function(a) {
  return typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b2, c2, d2, e2);
    });
  } : a;
}(function(a, b2) {
  if (a.namespaceURI !== kb.svg || "innerHTML" in a)
    a.innerHTML = b2;
  else {
    nb = nb || document.createElement("div");
    nb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = nb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b2.firstChild; )
      a.appendChild(b2.firstChild);
  }
});
function pb(a, b2) {
  if (b2) {
    var c2 = a.firstChild;
    if (c2 && c2 === a.lastChild && c2.nodeType === 3) {
      c2.nodeValue = b2;
      return;
    }
  }
  a.textContent = b2;
}
var qb = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var rb = ["Webkit", "ms", "Moz", "O"];
Object.keys(qb).forEach(function(a) {
  rb.forEach(function(b2) {
    b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
    qb[b2] = qb[a];
  });
});
function sb(a, b2, c2) {
  return b2 == null || typeof b2 === "boolean" || b2 === "" ? "" : c2 || typeof b2 !== "number" || b2 === 0 || qb.hasOwnProperty(a) && qb[a] ? ("" + b2).trim() : b2 + "px";
}
function tb(a, b2) {
  a = a.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = c2.indexOf("--") === 0, e2 = sb(c2, b2[c2], d2);
      c2 === "float" && (c2 = "cssFloat");
      d2 ? a.setProperty(c2, e2) : a[c2] = e2;
    }
}
var ub = objectAssign({menuitem: true}, {area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true});
function vb(a, b2) {
  if (b2) {
    if (ub[a] && (b2.children != null || b2.dangerouslySetInnerHTML != null))
      throw Error(y(137, a));
    if (b2.dangerouslySetInnerHTML != null) {
      if (b2.children != null)
        throw Error(y(60));
      if (!(typeof b2.dangerouslySetInnerHTML === "object" && "__html" in b2.dangerouslySetInnerHTML))
        throw Error(y(61));
    }
    if (b2.style != null && typeof b2.style !== "object")
      throw Error(y(62));
  }
}
function wb(a, b2) {
  if (a.indexOf("-") === -1)
    return typeof b2.is === "string";
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return a.nodeType === 3 ? a.parentNode : a;
}
var yb = null;
var zb = null;
var Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if (typeof yb !== "function")
      throw Error(y(280));
    var b2 = a.stateNode;
    b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a);
    if (b2)
      for (a = 0; a < b2.length; a++)
        Bb(b2[a]);
  }
}
function Gb(a, b2) {
  return a(b2);
}
function Hb(a, b2, c2, d2, e2) {
  return a(b2, c2, d2, e2);
}
function Ib() {
}
var Jb = Gb;
var Kb = false;
var Lb = false;
function Mb() {
  if (zb !== null || Ab !== null)
    Ib(), Fb();
}
function Nb(a, b2, c2) {
  if (Lb)
    return a(b2, c2);
  Lb = true;
  try {
    return Jb(a, b2, c2);
  } finally {
    Lb = false, Mb();
  }
}
function Ob(a, b2) {
  var c2 = a.stateNode;
  if (c2 === null)
    return null;
  var d2 = Db(c2);
  if (d2 === null)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a = a.type, d2 = !(a === "button" || a === "input" || a === "select" || a === "textarea"));
        a = !d2;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c2 && typeof c2 !== "function")
    throw Error(y(231, b2, typeof c2));
  return c2;
}
var Pb = false;
if (fa)
  try {
    Qb = {};
    Object.defineProperty(Qb, "passive", {get: function() {
      Pb = true;
    }});
    window.addEventListener("test", Qb, Qb);
    window.removeEventListener("test", Qb, Qb);
  } catch (a) {
    Pb = false;
  }
var Qb;
function Rb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (n2) {
    this.onError(n2);
  }
}
var Sb = false;
var Tb = null;
var Ub = false;
var Vb = null;
var Wb = {onError: function(a) {
  Sb = true;
  Tb = a;
}};
function Xb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Sb = false;
  Tb = null;
  Rb.apply(Wb, arguments);
}
function Yb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Xb.apply(this, arguments);
  if (Sb) {
    if (Sb) {
      var l2 = Tb;
      Sb = false;
      Tb = null;
    } else
      throw Error(y(198));
    Ub || (Ub = true, Vb = l2);
  }
}
function Zb(a) {
  var b2 = a, c2 = a;
  if (a.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a = b2;
    do
      b2 = a, (b2.flags & 1026) !== 0 && (c2 = b2.return), a = b2.return;
    while (a);
  }
  return b2.tag === 3 ? c2 : null;
}
function $b(a) {
  if (a.tag === 13) {
    var b2 = a.memoizedState;
    b2 === null && (a = a.alternate, a !== null && (b2 = a.memoizedState));
    if (b2 !== null)
      return b2.dehydrated;
  }
  return null;
}
function ac(a) {
  if (Zb(a) !== a)
    throw Error(y(188));
}
function bc(a) {
  var b2 = a.alternate;
  if (!b2) {
    b2 = Zb(a);
    if (b2 === null)
      throw Error(y(188));
    return b2 !== a ? null : a;
  }
  for (var c2 = a, d2 = b2; ; ) {
    var e2 = c2.return;
    if (e2 === null)
      break;
    var f2 = e2.alternate;
    if (f2 === null) {
      d2 = e2.return;
      if (d2 !== null) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return ac(e2), a;
        if (f2 === d2)
          return ac(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(y(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(y(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(y(190));
  }
  if (c2.tag !== 3)
    throw Error(y(188));
  return c2.stateNode.current === c2 ? a : b2;
}
function cc(a) {
  a = bc(a);
  if (!a)
    return null;
  for (var b2 = a; ; ) {
    if (b2.tag === 5 || b2.tag === 6)
      return b2;
    if (b2.child)
      b2.child.return = b2, b2 = b2.child;
    else {
      if (b2 === a)
        break;
      for (; !b2.sibling; ) {
        if (!b2.return || b2.return === a)
          return null;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return null;
}
function dc(a, b2) {
  for (var c2 = a.alternate; b2 !== null; ) {
    if (b2 === a || b2 === c2)
      return true;
    b2 = b2.return;
  }
  return false;
}
var ec;
var fc;
var gc;
var hc;
var ic = false;
var jc = [];
var kc = null;
var lc = null;
var mc = null;
var nc = new Map();
var oc = new Map();
var pc = [];
var qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function rc(a, b2, c2, d2, e2) {
  return {blockedOn: a, domEventName: b2, eventSystemFlags: c2 | 16, nativeEvent: e2, targetContainers: [d2]};
}
function sc(a, b2) {
  switch (a) {
    case "focusin":
    case "focusout":
      kc = null;
      break;
    case "dragenter":
    case "dragleave":
      lc = null;
      break;
    case "mouseover":
    case "mouseout":
      mc = null;
      break;
    case "pointerover":
    case "pointerout":
      nc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      oc.delete(b2.pointerId);
  }
}
function tc(a, b2, c2, d2, e2, f2) {
  if (a === null || a.nativeEvent !== f2)
    return a = rc(b2, c2, d2, e2, f2), b2 !== null && (b2 = Cb(b2), b2 !== null && fc(b2)), a;
  a.eventSystemFlags |= d2;
  b2 = a.targetContainers;
  e2 !== null && b2.indexOf(e2) === -1 && b2.push(e2);
  return a;
}
function uc(a, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return kc = tc(kc, a, b2, c2, d2, e2), true;
    case "dragenter":
      return lc = tc(lc, a, b2, c2, d2, e2), true;
    case "mouseover":
      return mc = tc(mc, a, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      nc.set(f2, tc(nc.get(f2) || null, a, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, oc.set(f2, tc(oc.get(f2) || null, a, b2, c2, d2, e2)), true;
  }
  return false;
}
function vc(a) {
  var b2 = wc(a.target);
  if (b2 !== null) {
    var c2 = Zb(b2);
    if (c2 !== null) {
      if (b2 = c2.tag, b2 === 13) {
        if (b2 = $b(c2), b2 !== null) {
          a.blockedOn = b2;
          hc(a.lanePriority, function() {
            scheduler.unstable_runWithPriority(a.priority, function() {
              gc(c2);
            });
          });
          return;
        }
      } else if (b2 === 3 && c2.stateNode.hydrate) {
        a.blockedOn = c2.tag === 3 ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function xc(a) {
  if (a.blockedOn !== null)
    return false;
  for (var b2 = a.targetContainers; 0 < b2.length; ) {
    var c2 = yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
    if (c2 !== null)
      return b2 = Cb(c2), b2 !== null && fc(b2), a.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function zc(a, b2, c2) {
  xc(a) && c2.delete(b2);
}
function Ac() {
  for (ic = false; 0 < jc.length; ) {
    var a = jc[0];
    if (a.blockedOn !== null) {
      a = Cb(a.blockedOn);
      a !== null && ec(a);
      break;
    }
    for (var b2 = a.targetContainers; 0 < b2.length; ) {
      var c2 = yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
      if (c2 !== null) {
        a.blockedOn = c2;
        break;
      }
      b2.shift();
    }
    a.blockedOn === null && jc.shift();
  }
  kc !== null && xc(kc) && (kc = null);
  lc !== null && xc(lc) && (lc = null);
  mc !== null && xc(mc) && (mc = null);
  nc.forEach(zc);
  oc.forEach(zc);
}
function Bc(a, b2) {
  a.blockedOn === b2 && (a.blockedOn = null, ic || (ic = true, scheduler.unstable_scheduleCallback(scheduler.unstable_NormalPriority, Ac)));
}
function Cc(a) {
  function b2(b3) {
    return Bc(b3, a);
  }
  if (0 < jc.length) {
    Bc(jc[0], a);
    for (var c2 = 1; c2 < jc.length; c2++) {
      var d2 = jc[c2];
      d2.blockedOn === a && (d2.blockedOn = null);
    }
  }
  kc !== null && Bc(kc, a);
  lc !== null && Bc(lc, a);
  mc !== null && Bc(mc, a);
  nc.forEach(b2);
  oc.forEach(b2);
  for (c2 = 0; c2 < pc.length; c2++)
    d2 = pc[c2], d2.blockedOn === a && (d2.blockedOn = null);
  for (; 0 < pc.length && (c2 = pc[0], c2.blockedOn === null); )
    vc(c2), c2.blockedOn === null && pc.shift();
}
function Dc(a, b2) {
  var c2 = {};
  c2[a.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a] = "webkit" + b2;
  c2["Moz" + a] = "moz" + b2;
  return c2;
}
var Ec = {animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd")};
var Fc = {};
var Gc = {};
fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
function Hc(a) {
  if (Fc[a])
    return Fc[a];
  if (!Ec[a])
    return a;
  var b2 = Ec[a], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Gc)
      return Fc[a] = b2[c2];
  return a;
}
var Ic = Hc("animationend");
var Jc = Hc("animationiteration");
var Kc = Hc("animationstart");
var Lc = Hc("transitionend");
var Mc = new Map();
var Nc = new Map();
var Oc = [
  "abort",
  "abort",
  Ic,
  "animationEnd",
  Jc,
  "animationIteration",
  Kc,
  "animationStart",
  "canplay",
  "canPlay",
  "canplaythrough",
  "canPlayThrough",
  "durationchange",
  "durationChange",
  "emptied",
  "emptied",
  "encrypted",
  "encrypted",
  "ended",
  "ended",
  "error",
  "error",
  "gotpointercapture",
  "gotPointerCapture",
  "load",
  "load",
  "loadeddata",
  "loadedData",
  "loadedmetadata",
  "loadedMetadata",
  "loadstart",
  "loadStart",
  "lostpointercapture",
  "lostPointerCapture",
  "playing",
  "playing",
  "progress",
  "progress",
  "seeking",
  "seeking",
  "stalled",
  "stalled",
  "suspend",
  "suspend",
  "timeupdate",
  "timeUpdate",
  Lc,
  "transitionEnd",
  "waiting",
  "waiting"
];
function Pc(a, b2) {
  for (var c2 = 0; c2 < a.length; c2 += 2) {
    var d2 = a[c2], e2 = a[c2 + 1];
    e2 = "on" + (e2[0].toUpperCase() + e2.slice(1));
    Nc.set(d2, b2);
    Mc.set(d2, e2);
    da(e2, [d2]);
  }
}
var Qc = scheduler.unstable_now;
Qc();
var F = 8;
function Rc(a) {
  if ((1 & a) !== 0)
    return F = 15, 1;
  if ((2 & a) !== 0)
    return F = 14, 2;
  if ((4 & a) !== 0)
    return F = 13, 4;
  var b2 = 24 & a;
  if (b2 !== 0)
    return F = 12, b2;
  if ((a & 32) !== 0)
    return F = 11, 32;
  b2 = 192 & a;
  if (b2 !== 0)
    return F = 10, b2;
  if ((a & 256) !== 0)
    return F = 9, 256;
  b2 = 3584 & a;
  if (b2 !== 0)
    return F = 8, b2;
  if ((a & 4096) !== 0)
    return F = 7, 4096;
  b2 = 4186112 & a;
  if (b2 !== 0)
    return F = 6, b2;
  b2 = 62914560 & a;
  if (b2 !== 0)
    return F = 5, b2;
  if (a & 67108864)
    return F = 4, 67108864;
  if ((a & 134217728) !== 0)
    return F = 3, 134217728;
  b2 = 805306368 & a;
  if (b2 !== 0)
    return F = 2, b2;
  if ((1073741824 & a) !== 0)
    return F = 1, 1073741824;
  F = 8;
  return a;
}
function Sc(a) {
  switch (a) {
    case 99:
      return 15;
    case 98:
      return 10;
    case 97:
    case 96:
      return 8;
    case 95:
      return 2;
    default:
      return 0;
  }
}
function Tc(a) {
  switch (a) {
    case 15:
    case 14:
      return 99;
    case 13:
    case 12:
    case 11:
    case 10:
      return 98;
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;
    case 3:
    case 2:
    case 1:
      return 95;
    case 0:
      return 90;
    default:
      throw Error(y(358, a));
  }
}
function Uc(a, b2) {
  var c2 = a.pendingLanes;
  if (c2 === 0)
    return F = 0;
  var d2 = 0, e2 = 0, f2 = a.expiredLanes, g2 = a.suspendedLanes, h2 = a.pingedLanes;
  if (f2 !== 0)
    d2 = f2, e2 = F = 15;
  else if (f2 = c2 & 134217727, f2 !== 0) {
    var k2 = f2 & ~g2;
    k2 !== 0 ? (d2 = Rc(k2), e2 = F) : (h2 &= f2, h2 !== 0 && (d2 = Rc(h2), e2 = F));
  } else
    f2 = c2 & ~g2, f2 !== 0 ? (d2 = Rc(f2), e2 = F) : h2 !== 0 && (d2 = Rc(h2), e2 = F);
  if (d2 === 0)
    return 0;
  d2 = 31 - Vc(d2);
  d2 = c2 & ((0 > d2 ? 0 : 1 << d2) << 1) - 1;
  if (b2 !== 0 && b2 !== d2 && (b2 & g2) === 0) {
    Rc(b2);
    if (e2 <= F)
      return b2;
    F = e2;
  }
  b2 = a.entangledLanes;
  if (b2 !== 0)
    for (a = a.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - Vc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
  return d2;
}
function Wc(a) {
  a = a.pendingLanes & -1073741825;
  return a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
}
function Xc(a, b2) {
  switch (a) {
    case 15:
      return 1;
    case 14:
      return 2;
    case 12:
      return a = Yc(24 & ~b2), a === 0 ? Xc(10, b2) : a;
    case 10:
      return a = Yc(192 & ~b2), a === 0 ? Xc(8, b2) : a;
    case 8:
      return a = Yc(3584 & ~b2), a === 0 && (a = Yc(4186112 & ~b2), a === 0 && (a = 512)), a;
    case 2:
      return b2 = Yc(805306368 & ~b2), b2 === 0 && (b2 = 268435456), b2;
  }
  throw Error(y(358, a));
}
function Yc(a) {
  return a & -a;
}
function Zc(a) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a);
  return b2;
}
function $c(a, b2, c2) {
  a.pendingLanes |= b2;
  var d2 = b2 - 1;
  a.suspendedLanes &= d2;
  a.pingedLanes &= d2;
  a = a.eventTimes;
  b2 = 31 - Vc(b2);
  a[b2] = c2;
}
var Vc = Math.clz32 ? Math.clz32 : ad;
var bd = Math.log;
var cd = Math.LN2;
function ad(a) {
  return a === 0 ? 32 : 31 - (bd(a) / cd | 0) | 0;
}
var dd = scheduler.unstable_UserBlockingPriority;
var ed = scheduler.unstable_runWithPriority;
var fd = true;
function gd(a, b2, c2, d2) {
  Kb || Ib();
  var e2 = hd, f2 = Kb;
  Kb = true;
  try {
    Hb(e2, a, b2, c2, d2);
  } finally {
    (Kb = f2) || Mb();
  }
}
function id(a, b2, c2, d2) {
  ed(dd, hd.bind(null, a, b2, c2, d2));
}
function hd(a, b2, c2, d2) {
  if (fd) {
    var e2;
    if ((e2 = (b2 & 4) === 0) && 0 < jc.length && -1 < qc.indexOf(a))
      a = rc(null, a, b2, c2, d2), jc.push(a);
    else {
      var f2 = yc(a, b2, c2, d2);
      if (f2 === null)
        e2 && sc(a, d2);
      else {
        if (e2) {
          if (-1 < qc.indexOf(a)) {
            a = rc(f2, a, b2, c2, d2);
            jc.push(a);
            return;
          }
          if (uc(f2, a, b2, c2, d2))
            return;
          sc(a, d2);
        }
        jd(a, b2, d2, null, c2);
      }
    }
  }
}
function yc(a, b2, c2, d2) {
  var e2 = xb(d2);
  e2 = wc(e2);
  if (e2 !== null) {
    var f2 = Zb(e2);
    if (f2 === null)
      e2 = null;
    else {
      var g2 = f2.tag;
      if (g2 === 13) {
        e2 = $b(f2);
        if (e2 !== null)
          return e2;
        e2 = null;
      } else if (g2 === 3) {
        if (f2.stateNode.hydrate)
          return f2.tag === 3 ? f2.stateNode.containerInfo : null;
        e2 = null;
      } else
        f2 !== e2 && (e2 = null);
    }
  }
  jd(a, b2, d2, e2, c2);
  return null;
}
var kd = null;
var ld = null;
var md = null;
function nd() {
  if (md)
    return md;
  var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a = 0; a < c2 && b2[a] === e2[a]; a++)
    ;
  var g2 = c2 - a;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
}
function od(a) {
  var b2 = a.keyCode;
  "charCode" in a ? (a = a.charCode, a === 0 && b2 === 13 && (a = 13)) : a = b2;
  a === 10 && (a = 13);
  return 32 <= a || a === 13 ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a)
      a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (f2.defaultPrevented != null ? f2.defaultPrevented : f2.returnValue === false) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  objectAssign(b2.prototype, {preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : typeof a2.returnValue !== "unknown" && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : typeof a2.cancelBubble !== "unknown" && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd});
  return b2;
}
var sd = {eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0};
var td = rd(sd);
var ud = objectAssign({}, sd, {view: 0, detail: 0});
var vd = rd(ud);
var wd;
var xd;
var yd;
var Ad = objectAssign({}, ud, {screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && a.type === "mousemove" ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
}});
var Bd = rd(Ad);
var Cd = objectAssign({}, Ad, {dataTransfer: 0});
var Dd = rd(Cd);
var Ed = objectAssign({}, ud, {relatedTarget: 0});
var Fd = rd(Ed);
var Gd = objectAssign({}, sd, {animationName: 0, elapsedTime: 0, pseudoElement: 0});
var Hd = rd(Gd);
var Id = objectAssign({}, sd, {clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
}});
var Jd = rd(Id);
var Kd = objectAssign({}, sd, {data: 0});
var Ld = rd(Kd);
var Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
};
var Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
};
var Od = {Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey"};
function Pd(a) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
}
function zd() {
  return Pd;
}
var Qd = objectAssign({}, ud, {key: function(a) {
  if (a.key) {
    var b2 = Md[a.key] || a.key;
    if (b2 !== "Unidentified")
      return b2;
  }
  return a.type === "keypress" ? (a = od(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return a.type === "keypress" ? od(a) : 0;
}, keyCode: function(a) {
  return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
}, which: function(a) {
  return a.type === "keypress" ? od(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
}});
var Rd = rd(Qd);
var Sd = objectAssign({}, Ad, {pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0});
var Td = rd(Sd);
var Ud = objectAssign({}, ud, {touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd});
var Vd = rd(Ud);
var Wd = objectAssign({}, sd, {propertyName: 0, elapsedTime: 0, pseudoElement: 0});
var Xd = rd(Wd);
var Yd = objectAssign({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
});
var Zd = rd(Yd);
var $d = [9, 13, 27, 32];
var ae = fa && "CompositionEvent" in window;
var be = null;
fa && "documentMode" in document && (be = document.documentMode);
var ce = fa && "TextEvent" in window && !be;
var de = fa && (!ae || be && 8 < be && 11 >= be);
var ee = String.fromCharCode(32);
var fe = false;
function ge(a, b2) {
  switch (a) {
    case "keyup":
      return $d.indexOf(b2.keyCode) !== -1;
    case "keydown":
      return b2.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return typeof a === "object" && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b2) {
  switch (a) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (b2.which !== 32)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b2.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b2) {
  if (ie)
    return a === "compositionend" || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && b2.locale !== "ko" ? null : b2.data;
    default:
      return null;
  }
}
var le = {color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true};
function me(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 === "input" ? !!le[a.type] : b2 === "textarea" ? true : false;
}
function ne(a, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({event: c2, listeners: b2}));
}
var pe = null;
var qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b2 = ue(a);
  if (Wa(b2))
    return a;
}
function ve(a, b2) {
  if (a === "change")
    return b2;
}
var we = false;
if (fa) {
  if (fa) {
    ye = "oninput" in document;
    if (!ye) {
      ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = typeof ze.oninput === "function";
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
var xe;
var ye;
var ze;
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if (a.propertyName === "value" && te(qe)) {
    var b2 = [];
    ne(b2, qe, a, xb(a));
    a = re;
    if (Kb)
      a(b2);
    else {
      Kb = true;
      try {
        Gb(a, b2);
      } finally {
        Kb = false, Mb();
      }
    }
  }
}
function Ce(a, b2, c2) {
  a === "focusin" ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : a === "focusout" && Ae();
}
function De(a) {
  if (a === "selectionchange" || a === "keyup" || a === "keydown")
    return te(qe);
}
function Ee(a, b2) {
  if (a === "click")
    return te(b2);
}
function Fe(a, b2) {
  if (a === "input" || a === "change")
    return te(b2);
}
function Ge(a, b2) {
  return a === b2 && (a !== 0 || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var He = typeof Object.is === "function" ? Object.is : Ge;
var Ie = Object.prototype.hasOwnProperty;
function Je(a, b2) {
  if (He(a, b2))
    return true;
  if (typeof a !== "object" || a === null || typeof b2 !== "object" || b2 === null)
    return false;
  var c2 = Object.keys(a), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++)
    if (!Ie.call(b2, c2[d2]) || !He(a[c2[d2]], b2[c2[d2]]))
      return false;
  return true;
}
function Ke(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Le(a, b2) {
  var c2 = Ke(a);
  a = 0;
  for (var d2; c2; ) {
    if (c2.nodeType === 3) {
      d2 = a + c2.textContent.length;
      if (a <= b2 && d2 >= b2)
        return {node: c2, offset: b2 - a};
      a = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Ke(c2);
  }
}
function Me(a, b2) {
  return a && b2 ? a === b2 ? true : a && a.nodeType === 3 ? false : b2 && b2.nodeType === 3 ? Me(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
}
function Ne() {
  for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
    try {
      var c2 = typeof b2.contentWindow.location.href === "string";
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a = b2.contentWindow;
    else
      break;
    b2 = Xa(a.document);
  }
  return b2;
}
function Oe(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 && (b2 === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || b2 === "textarea" || a.contentEditable === "true");
}
var Pe = fa && "documentMode" in document && 11 >= document.documentMode;
var Qe = null;
var Re = null;
var Se = null;
var Te = false;
function Ue(a, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : c2.nodeType === 9 ? c2 : c2.ownerDocument;
  Te || Qe == null || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Oe(d2) ? d2 = {start: d2.selectionStart, end: d2.selectionEnd} : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = {anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset}), Se && Je(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({event: b2, listeners: d2}), b2.target = Qe)));
}
Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
Pc(Oc, 2);
for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
  Nc.set(Ve[We], 0);
ea("onMouseEnter", ["mouseout", "mouseover"]);
ea("onMouseLeave", ["mouseout", "mouseover"]);
ea("onPointerEnter", ["pointerout", "pointerover"]);
ea("onPointerLeave", ["pointerout", "pointerover"]);
da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
var Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
function Ze(a, b2, c2) {
  var d2 = a.type || "unknown-event";
  a.currentTarget = c2;
  Yb(d2, b2, void 0, a);
  a.currentTarget = null;
}
function se(a, b2) {
  b2 = (b2 & 4) !== 0;
  for (var c2 = 0; c2 < a.length; c2++) {
    var d2 = a[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          Ze(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          Ze(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Ub)
    throw a = Vb, Ub = false, Vb = null, a;
}
function G(a, b2) {
  var c2 = $e(b2), d2 = a + "__bubble";
  c2.has(d2) || (af(b2, a, 2, false), c2.add(d2));
}
var bf = "_reactListening" + Math.random().toString(36).slice(2);
function cf(a) {
  a[bf] || (a[bf] = true, ba.forEach(function(b2) {
    Ye.has(b2) || df(b2, false, a, null);
    df(b2, true, a, null);
  }));
}
function df(a, b2, c2, d2) {
  var e2 = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0, f2 = c2;
  a === "selectionchange" && c2.nodeType !== 9 && (f2 = c2.ownerDocument);
  if (d2 !== null && !b2 && Ye.has(a)) {
    if (a !== "scroll")
      return;
    e2 |= 2;
    f2 = d2;
  }
  var g2 = $e(f2), h2 = a + "__" + (b2 ? "capture" : "bubble");
  g2.has(h2) || (b2 && (e2 |= 4), af(f2, a, e2, b2), g2.add(h2));
}
function af(a, b2, c2, d2) {
  var e2 = Nc.get(b2);
  switch (e2 === void 0 ? 2 : e2) {
    case 0:
      e2 = gd;
      break;
    case 1:
      e2 = id;
      break;
    default:
      e2 = hd;
  }
  c2 = e2.bind(null, b2, c2, a);
  e2 = void 0;
  !Pb || b2 !== "touchstart" && b2 !== "touchmove" && b2 !== "wheel" || (e2 = true);
  d2 ? e2 !== void 0 ? a.addEventListener(b2, c2, {capture: true, passive: e2}) : a.addEventListener(b2, c2, true) : e2 !== void 0 ? a.addEventListener(b2, c2, {passive: e2}) : a.addEventListener(b2, c2, false);
}
function jd(a, b2, c2, d2, e2) {
  var f2 = d2;
  if ((b2 & 1) === 0 && (b2 & 2) === 0 && d2 !== null)
    a:
      for (; ; ) {
        if (d2 === null)
          return;
        var g2 = d2.tag;
        if (g2 === 3 || g2 === 4) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || h2.nodeType === 8 && h2.parentNode === e2)
            break;
          if (g2 === 4)
            for (g2 = d2.return; g2 !== null; ) {
              var k2 = g2.tag;
              if (k2 === 3 || k2 === 4) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || k2.nodeType === 8 && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; h2 !== null; ) {
            g2 = wc(h2);
            if (g2 === null)
              return;
            k2 = g2.tag;
            if (k2 === 5 || k2 === 6) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Nb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = Mc.get(a);
      if (h3 !== void 0) {
        var k3 = td, x2 = a;
        switch (a) {
          case "keypress":
            if (od(c2) === 0)
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            x2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            x2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (c2.button === 2)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case Ic:
          case Jc:
          case Kc:
            k3 = Hd;
            break;
          case Lc:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var w2 = (b2 & 4) !== 0, z2 = !w2 && a === "scroll", u = w2 ? h3 !== null ? h3 + "Capture" : null : h3;
        w2 = [];
        for (var t2 = d3, q2; t2 !== null; ) {
          q2 = t2;
          var v2 = q2.stateNode;
          q2.tag === 5 && v2 !== null && (q2 = v2, u !== null && (v2 = Ob(t2, u), v2 != null && w2.push(ef(t2, v2, q2))));
          if (z2)
            break;
          t2 = t2.return;
        }
        0 < w2.length && (h3 = new k3(h3, x2, null, c2, e3), g3.push({event: h3, listeners: w2}));
      }
    }
    if ((b2 & 7) === 0) {
      a: {
        h3 = a === "mouseover" || a === "pointerover";
        k3 = a === "mouseout" || a === "pointerout";
        if (h3 && (b2 & 16) === 0 && (x2 = c2.relatedTarget || c2.fromElement) && (wc(x2) || x2[ff]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (x2 = c2.relatedTarget || c2.toElement, k3 = d3, x2 = x2 ? wc(x2) : null, x2 !== null && (z2 = Zb(x2), x2 !== z2 || x2.tag !== 5 && x2.tag !== 6))
              x2 = null;
          } else
            k3 = null, x2 = d3;
          if (k3 !== x2) {
            w2 = Bd;
            v2 = "onMouseLeave";
            u = "onMouseEnter";
            t2 = "mouse";
            if (a === "pointerout" || a === "pointerover")
              w2 = Td, v2 = "onPointerLeave", u = "onPointerEnter", t2 = "pointer";
            z2 = k3 == null ? h3 : ue(k3);
            q2 = x2 == null ? h3 : ue(x2);
            h3 = new w2(v2, t2 + "leave", k3, c2, e3);
            h3.target = z2;
            h3.relatedTarget = q2;
            v2 = null;
            wc(e3) === d3 && (w2 = new w2(u, t2 + "enter", x2, c2, e3), w2.target = q2, w2.relatedTarget = z2, v2 = w2);
            z2 = v2;
            if (k3 && x2)
              b: {
                w2 = k3;
                u = x2;
                t2 = 0;
                for (q2 = w2; q2; q2 = gf(q2))
                  t2++;
                q2 = 0;
                for (v2 = u; v2; v2 = gf(v2))
                  q2++;
                for (; 0 < t2 - q2; )
                  w2 = gf(w2), t2--;
                for (; 0 < q2 - t2; )
                  u = gf(u), q2--;
                for (; t2--; ) {
                  if (w2 === u || u !== null && w2 === u.alternate)
                    break b;
                  w2 = gf(w2);
                  u = gf(u);
                }
                w2 = null;
              }
            else
              w2 = null;
            k3 !== null && hf(g3, h3, k3, w2, false);
            x2 !== null && z2 !== null && hf(g3, z2, x2, w2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if (k3 === "select" || k3 === "input" && h3.type === "file")
          var J = ve;
        else if (me(h3))
          if (we)
            J = Fe;
          else {
            J = De;
            var K = Ce;
          }
        else
          (k3 = h3.nodeName) && k3.toLowerCase() === "input" && (h3.type === "checkbox" || h3.type === "radio") && (J = Ee);
        if (J && (J = J(a, d3))) {
          ne(g3, J, c2, e3);
          break a;
        }
        K && K(a, h3, d3);
        a === "focusout" && (K = h3._wrapperState) && K.controlled && h3.type === "number" && bb(h3, "number", h3.value);
      }
      K = d3 ? ue(d3) : window;
      switch (a) {
        case "focusin":
          if (me(K) || K.contentEditable === "true")
            Qe = K, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var Q;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var L = "onCompositionStart";
              break b;
            case "compositionend":
              L = "onCompositionEnd";
              break b;
            case "compositionupdate":
              L = "onCompositionUpdate";
              break b;
          }
          L = void 0;
        }
      else
        ie ? ge(a, c2) && (L = "onCompositionEnd") : a === "keydown" && c2.keyCode === 229 && (L = "onCompositionStart");
      L && (de && c2.locale !== "ko" && (ie || L !== "onCompositionStart" ? L === "onCompositionEnd" && ie && (Q = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K = oe(d3, L), 0 < K.length && (L = new Ld(L, a, null, c2, e3), g3.push({event: L, listeners: K}), Q ? L.data = Q : (Q = he(c2), Q !== null && (L.data = Q))));
      if (Q = ce ? je(a, c2) : ke(a, c2))
        d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({event: e3, listeners: d3}), e3.data = Q);
    }
    se(g3, b2);
  });
}
function ef(a, b2, c2) {
  return {instance: a, listener: b2, currentTarget: c2};
}
function oe(a, b2) {
  for (var c2 = b2 + "Capture", d2 = []; a !== null; ) {
    var e2 = a, f2 = e2.stateNode;
    e2.tag === 5 && f2 !== null && (e2 = f2, f2 = Ob(a, c2), f2 != null && d2.unshift(ef(a, f2, e2)), f2 = Ob(a, b2), f2 != null && d2.push(ef(a, f2, e2)));
    a = a.return;
  }
  return d2;
}
function gf(a) {
  if (a === null)
    return null;
  do
    a = a.return;
  while (a && a.tag !== 5);
  return a ? a : null;
}
function hf(a, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; c2 !== null && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (k2 !== null && k2 === d2)
      break;
    h2.tag === 5 && l2 !== null && (h2 = l2, e2 ? (k2 = Ob(c2, f2), k2 != null && g2.unshift(ef(c2, k2, h2))) : e2 || (k2 = Ob(c2, f2), k2 != null && g2.push(ef(c2, k2, h2))));
    c2 = c2.return;
  }
  g2.length !== 0 && a.push({event: b2, listeners: g2});
}
function jf() {
}
var kf = null;
var lf = null;
function mf(a, b2) {
  switch (a) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!b2.autoFocus;
  }
  return false;
}
function nf(a, b2) {
  return a === "textarea" || a === "option" || a === "noscript" || typeof b2.children === "string" || typeof b2.children === "number" || typeof b2.dangerouslySetInnerHTML === "object" && b2.dangerouslySetInnerHTML !== null && b2.dangerouslySetInnerHTML.__html != null;
}
var of = typeof setTimeout === "function" ? setTimeout : void 0;
var pf = typeof clearTimeout === "function" ? clearTimeout : void 0;
function qf(a) {
  a.nodeType === 1 ? a.textContent = "" : a.nodeType === 9 && (a = a.body, a != null && (a.textContent = ""));
}
function rf(a) {
  for (; a != null; a = a.nextSibling) {
    var b2 = a.nodeType;
    if (b2 === 1 || b2 === 3)
      break;
  }
  return a;
}
function sf(a) {
  a = a.previousSibling;
  for (var b2 = 0; a; ) {
    if (a.nodeType === 8) {
      var c2 = a.data;
      if (c2 === "$" || c2 === "$!" || c2 === "$?") {
        if (b2 === 0)
          return a;
        b2--;
      } else
        c2 === "/$" && b2++;
    }
    a = a.previousSibling;
  }
  return null;
}
var tf = 0;
function uf(a) {
  return {$$typeof: Ga, toString: a, valueOf: a};
}
var vf = Math.random().toString(36).slice(2);
var wf = "__reactFiber$" + vf;
var xf = "__reactProps$" + vf;
var ff = "__reactContainer$" + vf;
var yf = "__reactEvents$" + vf;
function wc(a) {
  var b2 = a[wf];
  if (b2)
    return b2;
  for (var c2 = a.parentNode; c2; ) {
    if (b2 = c2[ff] || c2[wf]) {
      c2 = b2.alternate;
      if (b2.child !== null || c2 !== null && c2.child !== null)
        for (a = sf(a); a !== null; ) {
          if (c2 = a[wf])
            return c2;
          a = sf(a);
        }
      return b2;
    }
    a = c2;
    c2 = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[wf] || a[ff];
  return !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;
}
function ue(a) {
  if (a.tag === 5 || a.tag === 6)
    return a.stateNode;
  throw Error(y(33));
}
function Db(a) {
  return a[xf] || null;
}
function $e(a) {
  var b2 = a[yf];
  b2 === void 0 && (b2 = a[yf] = new Set());
  return b2;
}
var zf = [];
var Af = -1;
function Bf(a) {
  return {current: a};
}
function H(a) {
  0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
}
function I(a, b2) {
  Af++;
  zf[Af] = a.current;
  a.current = b2;
}
var Cf = {};
var M = Bf(Cf);
var N = Bf(false);
var Df = Cf;
function Ef(a, b2) {
  var c2 = a.type.contextTypes;
  if (!c2)
    return Cf;
  var d2 = a.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Ff(a) {
  a = a.childContextTypes;
  return a !== null && a !== void 0;
}
function Gf() {
  H(N);
  H(M);
}
function Hf(a, b2, c2) {
  if (M.current !== Cf)
    throw Error(y(168));
  I(M, b2);
  I(N, c2);
}
function If(a, b2, c2) {
  var d2 = a.stateNode;
  a = b2.childContextTypes;
  if (typeof d2.getChildContext !== "function")
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in a))
      throw Error(y(108, Ra(b2) || "Unknown", e2));
  return objectAssign({}, c2, d2);
}
function Jf(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
  Df = M.current;
  I(M, a);
  I(N, N.current);
  return true;
}
function Kf(a, b2, c2) {
  var d2 = a.stateNode;
  if (!d2)
    throw Error(y(169));
  c2 ? (a = If(a, b2, Df), d2.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);
  I(N, c2);
}
var Lf = null;
var Mf = null;
var Nf = scheduler.unstable_runWithPriority;
var Of = scheduler.unstable_scheduleCallback;
var Pf = scheduler.unstable_cancelCallback;
var Qf = scheduler.unstable_shouldYield;
var Rf = scheduler.unstable_requestPaint;
var Sf = scheduler.unstable_now;
var Tf = scheduler.unstable_getCurrentPriorityLevel;
var Uf = scheduler.unstable_ImmediatePriority;
var Vf = scheduler.unstable_UserBlockingPriority;
var Wf = scheduler.unstable_NormalPriority;
var Xf = scheduler.unstable_LowPriority;
var Yf = scheduler.unstable_IdlePriority;
var Zf = {};
var $f = Rf !== void 0 ? Rf : function() {
};
var ag = null;
var bg = null;
var cg = false;
var dg = Sf();
var O = 1e4 > dg ? Sf : function() {
  return Sf() - dg;
};
function eg() {
  switch (Tf()) {
    case Uf:
      return 99;
    case Vf:
      return 98;
    case Wf:
      return 97;
    case Xf:
      return 96;
    case Yf:
      return 95;
    default:
      throw Error(y(332));
  }
}
function fg(a) {
  switch (a) {
    case 99:
      return Uf;
    case 98:
      return Vf;
    case 97:
      return Wf;
    case 96:
      return Xf;
    case 95:
      return Yf;
    default:
      throw Error(y(332));
  }
}
function gg(a, b2) {
  a = fg(a);
  return Nf(a, b2);
}
function hg(a, b2, c2) {
  a = fg(a);
  return Of(a, b2, c2);
}
function ig() {
  if (bg !== null) {
    var a = bg;
    bg = null;
    Pf(a);
  }
  jg();
}
function jg() {
  if (!cg && ag !== null) {
    cg = true;
    var a = 0;
    try {
      var b2 = ag;
      gg(99, function() {
        for (; a < b2.length; a++) {
          var c2 = b2[a];
          do
            c2 = c2(true);
          while (c2 !== null);
        }
      });
      ag = null;
    } catch (c2) {
      throw ag !== null && (ag = ag.slice(a + 1)), Of(Uf, ig), c2;
    } finally {
      cg = false;
    }
  }
}
var kg = ra.ReactCurrentBatchConfig;
function lg(a, b2) {
  if (a && a.defaultProps) {
    b2 = objectAssign({}, b2);
    a = a.defaultProps;
    for (var c2 in a)
      b2[c2] === void 0 && (b2[c2] = a[c2]);
    return b2;
  }
  return b2;
}
var mg = Bf(null);
var ng = null;
var og = null;
var pg = null;
function qg() {
  pg = og = ng = null;
}
function rg(a) {
  var b2 = mg.current;
  H(mg);
  a.type._context._currentValue = b2;
}
function sg(a, b2) {
  for (; a !== null; ) {
    var c2 = a.alternate;
    if ((a.childLanes & b2) === b2)
      if (c2 === null || (c2.childLanes & b2) === b2)
        break;
      else
        c2.childLanes |= b2;
    else
      a.childLanes |= b2, c2 !== null && (c2.childLanes |= b2);
    a = a.return;
  }
}
function tg(a, b2) {
  ng = a;
  pg = og = null;
  a = a.dependencies;
  a !== null && a.firstContext !== null && ((a.lanes & b2) !== 0 && (ug = true), a.firstContext = null);
}
function vg(a, b2) {
  if (pg !== a && b2 !== false && b2 !== 0) {
    if (typeof b2 !== "number" || b2 === 1073741823)
      pg = a, b2 = 1073741823;
    b2 = {context: a, observedBits: b2, next: null};
    if (og === null) {
      if (ng === null)
        throw Error(y(308));
      og = b2;
      ng.dependencies = {lanes: 0, firstContext: b2, responders: null};
    } else
      og = og.next = b2;
  }
  return a._currentValue;
}
var wg = false;
function xg(a) {
  a.updateQueue = {baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: {pending: null}, effects: null};
}
function yg(a, b2) {
  a = a.updateQueue;
  b2.updateQueue === a && (b2.updateQueue = {baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects});
}
function zg(a, b2) {
  return {eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null};
}
function Ag(a, b2) {
  a = a.updateQueue;
  if (a !== null) {
    a = a.shared;
    var c2 = a.pending;
    c2 === null ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
    a.pending = b2;
  }
}
function Bg(a, b2) {
  var c2 = a.updateQueue, d2 = a.alternate;
  if (d2 !== null && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (c2 !== null) {
      do {
        var g2 = {eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null};
        f2 === null ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (c2 !== null);
      f2 === null ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = {baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects};
    a.updateQueue = c2;
    return;
  }
  a = c2.lastBaseUpdate;
  a === null ? c2.firstBaseUpdate = b2 : a.next = b2;
  c2.lastBaseUpdate = b2;
}
function Cg(a, b2, c2, d2) {
  var e2 = a.updateQueue;
  wg = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (h2 !== null) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    g2 === null ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var n2 = a.alternate;
    if (n2 !== null) {
      n2 = n2.updateQueue;
      var A2 = n2.lastBaseUpdate;
      A2 !== g2 && (A2 === null ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k2);
    }
  }
  if (f2 !== null) {
    A2 = e2.baseState;
    g2 = 0;
    n2 = l2 = k2 = null;
    do {
      h2 = f2.lane;
      var p2 = f2.eventTime;
      if ((d2 & h2) === h2) {
        n2 !== null && (n2 = n2.next = {
          eventTime: p2,
          lane: 0,
          tag: f2.tag,
          payload: f2.payload,
          callback: f2.callback,
          next: null
        });
        a: {
          var C = a, x2 = f2;
          h2 = b2;
          p2 = c2;
          switch (x2.tag) {
            case 1:
              C = x2.payload;
              if (typeof C === "function") {
                A2 = C.call(p2, A2, h2);
                break a;
              }
              A2 = C;
              break a;
            case 3:
              C.flags = C.flags & -4097 | 64;
            case 0:
              C = x2.payload;
              h2 = typeof C === "function" ? C.call(p2, A2, h2) : C;
              if (h2 === null || h2 === void 0)
                break a;
              A2 = objectAssign({}, A2, h2);
              break a;
            case 2:
              wg = true;
          }
        }
        f2.callback !== null && (a.flags |= 32, h2 = e2.effects, h2 === null ? e2.effects = [f2] : h2.push(f2));
      } else
        p2 = {eventTime: p2, lane: h2, tag: f2.tag, payload: f2.payload, callback: f2.callback, next: null}, n2 === null ? (l2 = n2 = p2, k2 = A2) : n2 = n2.next = p2, g2 |= h2;
      f2 = f2.next;
      if (f2 === null)
        if (h2 = e2.shared.pending, h2 === null)
          break;
        else
          f2 = h2.next, h2.next = null, e2.lastBaseUpdate = h2, e2.shared.pending = null;
    } while (1);
    n2 === null && (k2 = A2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = n2;
    Dg |= g2;
    a.lanes = g2;
    a.memoizedState = A2;
  }
}
function Eg(a, b2, c2) {
  a = b2.effects;
  b2.effects = null;
  if (a !== null)
    for (b2 = 0; b2 < a.length; b2++) {
      var d2 = a[b2], e2 = d2.callback;
      if (e2 !== null) {
        d2.callback = null;
        d2 = c2;
        if (typeof e2 !== "function")
          throw Error(y(191, e2));
        e2.call(d2);
      }
    }
}
var Fg = new react.Component().refs;
function Gg(a, b2, c2, d2) {
  b2 = a.memoizedState;
  c2 = c2(d2, b2);
  c2 = c2 === null || c2 === void 0 ? b2 : objectAssign({}, b2, c2);
  a.memoizedState = c2;
  a.lanes === 0 && (a.updateQueue.baseState = c2);
}
var Kg = {isMounted: function(a) {
  return (a = a._reactInternals) ? Zb(a) === a : false;
}, enqueueSetState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = Hg(), e2 = Ig(a), f2 = zg(d2, e2);
  f2.payload = b2;
  c2 !== void 0 && c2 !== null && (f2.callback = c2);
  Ag(a, f2);
  Jg(a, e2, d2);
}, enqueueReplaceState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = Hg(), e2 = Ig(a), f2 = zg(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  c2 !== void 0 && c2 !== null && (f2.callback = c2);
  Ag(a, f2);
  Jg(a, e2, d2);
}, enqueueForceUpdate: function(a, b2) {
  a = a._reactInternals;
  var c2 = Hg(), d2 = Ig(a), e2 = zg(c2, d2);
  e2.tag = 2;
  b2 !== void 0 && b2 !== null && (e2.callback = b2);
  Ag(a, e2);
  Jg(a, d2, c2);
}};
function Lg(a, b2, c2, d2, e2, f2, g2) {
  a = a.stateNode;
  return typeof a.shouldComponentUpdate === "function" ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Je(c2, d2) || !Je(e2, f2) : true;
}
function Mg(a, b2, c2) {
  var d2 = false, e2 = Cf;
  var f2 = b2.contextType;
  typeof f2 === "object" && f2 !== null ? f2 = vg(f2) : (e2 = Ff(b2) ? Df : M.current, d2 = b2.contextTypes, f2 = (d2 = d2 !== null && d2 !== void 0) ? Ef(a, e2) : Cf);
  b2 = new b2(c2, f2);
  a.memoizedState = b2.state !== null && b2.state !== void 0 ? b2.state : null;
  b2.updater = Kg;
  a.stateNode = b2;
  b2._reactInternals = a;
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Ng(a, b2, c2, d2) {
  a = b2.state;
  typeof b2.componentWillReceiveProps === "function" && b2.componentWillReceiveProps(c2, d2);
  typeof b2.UNSAFE_componentWillReceiveProps === "function" && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a && Kg.enqueueReplaceState(b2, b2.state, null);
}
function Og(a, b2, c2, d2) {
  var e2 = a.stateNode;
  e2.props = c2;
  e2.state = a.memoizedState;
  e2.refs = Fg;
  xg(a);
  var f2 = b2.contextType;
  typeof f2 === "object" && f2 !== null ? e2.context = vg(f2) : (f2 = Ff(b2) ? Df : M.current, e2.context = Ef(a, f2));
  Cg(a, c2, e2, d2);
  e2.state = a.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  typeof f2 === "function" && (Gg(a, b2, f2, c2), e2.state = a.memoizedState);
  typeof b2.getDerivedStateFromProps === "function" || typeof e2.getSnapshotBeforeUpdate === "function" || typeof e2.UNSAFE_componentWillMount !== "function" && typeof e2.componentWillMount !== "function" || (b2 = e2.state, typeof e2.componentWillMount === "function" && e2.componentWillMount(), typeof e2.UNSAFE_componentWillMount === "function" && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Kg.enqueueReplaceState(e2, e2.state, null), Cg(a, c2, e2, d2), e2.state = a.memoizedState);
  typeof e2.componentDidMount === "function" && (a.flags |= 4);
}
var Pg = Array.isArray;
function Qg(a, b2, c2) {
  a = c2.ref;
  if (a !== null && typeof a !== "function" && typeof a !== "object") {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (c2.tag !== 1)
          throw Error(y(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(y(147, a));
      var e2 = "" + a;
      if (b2 !== null && b2.ref !== null && typeof b2.ref === "function" && b2.ref._stringRef === e2)
        return b2.ref;
      b2 = function(a2) {
        var b3 = d2.refs;
        b3 === Fg && (b3 = d2.refs = {});
        a2 === null ? delete b3[e2] : b3[e2] = a2;
      };
      b2._stringRef = e2;
      return b2;
    }
    if (typeof a !== "string")
      throw Error(y(284));
    if (!c2._owner)
      throw Error(y(290, a));
  }
  return a;
}
function Rg(a, b2) {
  if (a.type !== "textarea")
    throw Error(y(31, Object.prototype.toString.call(b2) === "[object Object]" ? "object with keys {" + Object.keys(b2).join(", ") + "}" : b2));
}
function Sg(a) {
  function b2(b3, c3) {
    if (a) {
      var d3 = b3.lastEffect;
      d3 !== null ? (d3.nextEffect = c3, b3.lastEffect = c3) : b3.firstEffect = b3.lastEffect = c3;
      c3.nextEffect = null;
      c3.flags = 8;
    }
  }
  function c2(c3, d3) {
    if (!a)
      return null;
    for (; d3 !== null; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a2, b3) {
    for (a2 = new Map(); b3 !== null; )
      b3.key !== null ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
    return a2;
  }
  function e2(a2, b3) {
    a2 = Tg(a2, b3);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a)
      return c3;
    d3 = b3.alternate;
    if (d3 !== null)
      return d3 = d3.index, d3 < c3 ? (b3.flags = 2, c3) : d3;
    b3.flags = 2;
    return c3;
  }
  function g2(b3) {
    a && b3.alternate === null && (b3.flags = 2);
    return b3;
  }
  function h2(a2, b3, c3, d3) {
    if (b3 === null || b3.tag !== 6)
      return b3 = Ug(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function k2(a2, b3, c3, d3) {
    if (b3 !== null && b3.elementType === c3.type)
      return d3 = e2(b3, c3.props), d3.ref = Qg(a2, b3, c3), d3.return = a2, d3;
    d3 = Vg(c3.type, c3.key, c3.props, null, a2.mode, d3);
    d3.ref = Qg(a2, b3, c3);
    d3.return = a2;
    return d3;
  }
  function l2(a2, b3, c3, d3) {
    if (b3 === null || b3.tag !== 4 || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = Wg(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a2;
    return b3;
  }
  function n2(a2, b3, c3, d3, f3) {
    if (b3 === null || b3.tag !== 7)
      return b3 = Xg(c3, a2.mode, d3, f3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function A2(a2, b3, c3) {
    if (typeof b3 === "string" || typeof b3 === "number")
      return b3 = Ug("" + b3, a2.mode, c3), b3.return = a2, b3;
    if (typeof b3 === "object" && b3 !== null) {
      switch (b3.$$typeof) {
        case sa:
          return c3 = Vg(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = Qg(a2, null, b3), c3.return = a2, c3;
        case ta:
          return b3 = Wg(b3, a2.mode, c3), b3.return = a2, b3;
      }
      if (Pg(b3) || La(b3))
        return b3 = Xg(b3, a2.mode, c3, null), b3.return = a2, b3;
      Rg(a2, b3);
    }
    return null;
  }
  function p2(a2, b3, c3, d3) {
    var e3 = b3 !== null ? b3.key : null;
    if (typeof c3 === "string" || typeof c3 === "number")
      return e3 !== null ? null : h2(a2, b3, "" + c3, d3);
    if (typeof c3 === "object" && c3 !== null) {
      switch (c3.$$typeof) {
        case sa:
          return c3.key === e3 ? c3.type === ua ? n2(a2, b3, c3.props.children, d3, e3) : k2(a2, b3, c3, d3) : null;
        case ta:
          return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
      }
      if (Pg(c3) || La(c3))
        return e3 !== null ? null : n2(a2, b3, c3, d3, null);
      Rg(a2, c3);
    }
    return null;
  }
  function C(a2, b3, c3, d3, e3) {
    if (typeof d3 === "string" || typeof d3 === "number")
      return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
    if (typeof d3 === "object" && d3 !== null) {
      switch (d3.$$typeof) {
        case sa:
          return a2 = a2.get(d3.key === null ? c3 : d3.key) || null, d3.type === ua ? n2(b3, a2, d3.props.children, e3, d3.key) : k2(b3, a2, d3, e3);
        case ta:
          return a2 = a2.get(d3.key === null ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
      }
      if (Pg(d3) || La(d3))
        return a2 = a2.get(c3) || null, n2(b3, a2, d3, e3, null);
      Rg(b3, d3);
    }
    return null;
  }
  function x2(e3, g3, h3, k3) {
    for (var l3 = null, t2 = null, u = g3, z2 = g3 = 0, q2 = null; u !== null && z2 < h3.length; z2++) {
      u.index > z2 ? (q2 = u, u = null) : q2 = u.sibling;
      var n3 = p2(e3, u, h3[z2], k3);
      if (n3 === null) {
        u === null && (u = q2);
        break;
      }
      a && u && n3.alternate === null && b2(e3, u);
      g3 = f2(n3, g3, z2);
      t2 === null ? l3 = n3 : t2.sibling = n3;
      t2 = n3;
      u = q2;
    }
    if (z2 === h3.length)
      return c2(e3, u), l3;
    if (u === null) {
      for (; z2 < h3.length; z2++)
        u = A2(e3, h3[z2], k3), u !== null && (g3 = f2(u, g3, z2), t2 === null ? l3 = u : t2.sibling = u, t2 = u);
      return l3;
    }
    for (u = d2(e3, u); z2 < h3.length; z2++)
      q2 = C(u, e3, z2, h3[z2], k3), q2 !== null && (a && q2.alternate !== null && u.delete(q2.key === null ? z2 : q2.key), g3 = f2(q2, g3, z2), t2 === null ? l3 = q2 : t2.sibling = q2, t2 = q2);
    a && u.forEach(function(a2) {
      return b2(e3, a2);
    });
    return l3;
  }
  function w2(e3, g3, h3, k3) {
    var l3 = La(h3);
    if (typeof l3 !== "function")
      throw Error(y(150));
    h3 = l3.call(h3);
    if (h3 == null)
      throw Error(y(151));
    for (var t2 = l3 = null, u = g3, z2 = g3 = 0, q2 = null, n3 = h3.next(); u !== null && !n3.done; z2++, n3 = h3.next()) {
      u.index > z2 ? (q2 = u, u = null) : q2 = u.sibling;
      var w3 = p2(e3, u, n3.value, k3);
      if (w3 === null) {
        u === null && (u = q2);
        break;
      }
      a && u && w3.alternate === null && b2(e3, u);
      g3 = f2(w3, g3, z2);
      t2 === null ? l3 = w3 : t2.sibling = w3;
      t2 = w3;
      u = q2;
    }
    if (n3.done)
      return c2(e3, u), l3;
    if (u === null) {
      for (; !n3.done; z2++, n3 = h3.next())
        n3 = A2(e3, n3.value, k3), n3 !== null && (g3 = f2(n3, g3, z2), t2 === null ? l3 = n3 : t2.sibling = n3, t2 = n3);
      return l3;
    }
    for (u = d2(e3, u); !n3.done; z2++, n3 = h3.next())
      n3 = C(u, e3, z2, n3.value, k3), n3 !== null && (a && n3.alternate !== null && u.delete(n3.key === null ? z2 : n3.key), g3 = f2(n3, g3, z2), t2 === null ? l3 = n3 : t2.sibling = n3, t2 = n3);
    a && u.forEach(function(a2) {
      return b2(e3, a2);
    });
    return l3;
  }
  return function(a2, d3, f3, h3) {
    var k3 = typeof f3 === "object" && f3 !== null && f3.type === ua && f3.key === null;
    k3 && (f3 = f3.props.children);
    var l3 = typeof f3 === "object" && f3 !== null;
    if (l3)
      switch (f3.$$typeof) {
        case sa:
          a: {
            l3 = f3.key;
            for (k3 = d3; k3 !== null; ) {
              if (k3.key === l3) {
                switch (k3.tag) {
                  case 7:
                    if (f3.type === ua) {
                      c2(a2, k3.sibling);
                      d3 = e2(k3, f3.props.children);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    }
                    break;
                  default:
                    if (k3.elementType === f3.type) {
                      c2(a2, k3.sibling);
                      d3 = e2(k3, f3.props);
                      d3.ref = Qg(a2, k3, f3);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    }
                }
                c2(a2, k3);
                break;
              } else
                b2(a2, k3);
              k3 = k3.sibling;
            }
            f3.type === ua ? (d3 = Xg(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = Vg(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Qg(a2, d3, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case ta:
          a: {
            for (k3 = f3.key; d3 !== null; ) {
              if (d3.key === k3)
                if (d3.tag === 4 && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a2, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                } else {
                  c2(a2, d3);
                  break;
                }
              else
                b2(a2, d3);
              d3 = d3.sibling;
            }
            d3 = Wg(f3, a2.mode, h3);
            d3.return = a2;
            a2 = d3;
          }
          return g2(a2);
      }
    if (typeof f3 === "string" || typeof f3 === "number")
      return f3 = "" + f3, d3 !== null && d3.tag === 6 ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = Ug(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2);
    if (Pg(f3))
      return x2(a2, d3, f3, h3);
    if (La(f3))
      return w2(a2, d3, f3, h3);
    l3 && Rg(a2, f3);
    if (typeof f3 === "undefined" && !k3)
      switch (a2.tag) {
        case 1:
        case 22:
        case 0:
        case 11:
        case 15:
          throw Error(y(152, Ra(a2.type) || "Component"));
      }
    return c2(a2, d3);
  };
}
var Yg = Sg(true);
var Zg = Sg(false);
var $g = {};
var ah = Bf($g);
var bh = Bf($g);
var ch = Bf($g);
function dh(a) {
  if (a === $g)
    throw Error(y(174));
  return a;
}
function eh(a, b2) {
  I(ch, b2);
  I(bh, a);
  I(ah, $g);
  a = b2.nodeType;
  switch (a) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : mb(null, "");
      break;
    default:
      a = a === 8 ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = mb(b2, a);
  }
  H(ah);
  I(ah, b2);
}
function fh() {
  H(ah);
  H(bh);
  H(ch);
}
function gh(a) {
  dh(ch.current);
  var b2 = dh(ah.current);
  var c2 = mb(b2, a.type);
  b2 !== c2 && (I(bh, a), I(ah, c2));
}
function hh(a) {
  bh.current === a && (H(ah), H(bh));
}
var P = Bf(0);
function ih(a) {
  for (var b2 = a; b2 !== null; ) {
    if (b2.tag === 13) {
      var c2 = b2.memoizedState;
      if (c2 !== null && (c2 = c2.dehydrated, c2 === null || c2.data === "$?" || c2.data === "$!"))
        return b2;
    } else if (b2.tag === 19 && b2.memoizedProps.revealOrder !== void 0) {
      if ((b2.flags & 64) !== 0)
        return b2;
    } else if (b2.child !== null) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a)
      break;
    for (; b2.sibling === null; ) {
      if (b2.return === null || b2.return === a)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var jh = null;
var kh = null;
var lh = false;
function mh(a, b2) {
  var c2 = nh(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.type = "DELETED";
  c2.stateNode = b2;
  c2.return = a;
  c2.flags = 8;
  a.lastEffect !== null ? (a.lastEffect.nextEffect = c2, a.lastEffect = c2) : a.firstEffect = a.lastEffect = c2;
}
function oh(a, b2) {
  switch (a.tag) {
    case 5:
      var c2 = a.type;
      b2 = b2.nodeType !== 1 || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return b2 !== null ? (a.stateNode = b2, true) : false;
    case 6:
      return b2 = a.pendingProps === "" || b2.nodeType !== 3 ? null : b2, b2 !== null ? (a.stateNode = b2, true) : false;
    case 13:
      return false;
    default:
      return false;
  }
}
function ph(a) {
  if (lh) {
    var b2 = kh;
    if (b2) {
      var c2 = b2;
      if (!oh(a, b2)) {
        b2 = rf(c2.nextSibling);
        if (!b2 || !oh(a, b2)) {
          a.flags = a.flags & -1025 | 2;
          lh = false;
          jh = a;
          return;
        }
        mh(jh, c2);
      }
      jh = a;
      kh = rf(b2.firstChild);
    } else
      a.flags = a.flags & -1025 | 2, lh = false, jh = a;
  }
}
function qh(a) {
  for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
    a = a.return;
  jh = a;
}
function rh(a) {
  if (a !== jh)
    return false;
  if (!lh)
    return qh(a), lh = true, false;
  var b2 = a.type;
  if (a.tag !== 5 || b2 !== "head" && b2 !== "body" && !nf(b2, a.memoizedProps))
    for (b2 = kh; b2; )
      mh(a, b2), b2 = rf(b2.nextSibling);
  qh(a);
  if (a.tag === 13) {
    a = a.memoizedState;
    a = a !== null ? a.dehydrated : null;
    if (!a)
      throw Error(y(317));
    a: {
      a = a.nextSibling;
      for (b2 = 0; a; ) {
        if (a.nodeType === 8) {
          var c2 = a.data;
          if (c2 === "/$") {
            if (b2 === 0) {
              kh = rf(a.nextSibling);
              break a;
            }
            b2--;
          } else
            c2 !== "$" && c2 !== "$!" && c2 !== "$?" || b2++;
        }
        a = a.nextSibling;
      }
      kh = null;
    }
  } else
    kh = jh ? rf(a.stateNode.nextSibling) : null;
  return true;
}
function sh() {
  kh = jh = null;
  lh = false;
}
var th = [];
function uh() {
  for (var a = 0; a < th.length; a++)
    th[a]._workInProgressVersionPrimary = null;
  th.length = 0;
}
var vh = ra.ReactCurrentDispatcher;
var wh = ra.ReactCurrentBatchConfig;
var xh = 0;
var R = null;
var S = null;
var T = null;
var yh = false;
var zh = false;
function Ah() {
  throw Error(y(321));
}
function Bh(a, b2) {
  if (b2 === null)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++)
    if (!He(a[c2], b2[c2]))
      return false;
  return true;
}
function Ch(a, b2, c2, d2, e2, f2) {
  xh = f2;
  R = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  vh.current = a === null || a.memoizedState === null ? Dh : Eh;
  a = c2(d2, e2);
  if (zh) {
    f2 = 0;
    do {
      zh = false;
      if (!(25 > f2))
        throw Error(y(301));
      f2 += 1;
      T = S = null;
      b2.updateQueue = null;
      vh.current = Fh;
      a = c2(d2, e2);
    } while (zh);
  }
  vh.current = Gh;
  b2 = S !== null && S.next !== null;
  xh = 0;
  T = S = R = null;
  yh = false;
  if (b2)
    throw Error(y(300));
  return a;
}
function Hh() {
  var a = {memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null};
  T === null ? R.memoizedState = T = a : T = T.next = a;
  return T;
}
function Ih() {
  if (S === null) {
    var a = R.alternate;
    a = a !== null ? a.memoizedState : null;
  } else
    a = S.next;
  var b2 = T === null ? R.memoizedState : T.next;
  if (b2 !== null)
    T = b2, S = a;
  else {
    if (a === null)
      throw Error(y(310));
    S = a;
    a = {memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null};
    T === null ? R.memoizedState = T = a : T = T.next = a;
  }
  return T;
}
function Jh(a, b2) {
  return typeof b2 === "function" ? b2(a) : b2;
}
function Kh(a) {
  var b2 = Ih(), c2 = b2.queue;
  if (c2 === null)
    throw Error(y(311));
  c2.lastRenderedReducer = a;
  var d2 = S, e2 = d2.baseQueue, f2 = c2.pending;
  if (f2 !== null) {
    if (e2 !== null) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (e2 !== null) {
    e2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = f2 = null, k2 = e2;
    do {
      var l2 = k2.lane;
      if ((xh & l2) === l2)
        h2 !== null && (h2 = h2.next = {lane: 0, action: k2.action, eagerReducer: k2.eagerReducer, eagerState: k2.eagerState, next: null}), d2 = k2.eagerReducer === a ? k2.eagerState : a(d2, k2.action);
      else {
        var n2 = {
          lane: l2,
          action: k2.action,
          eagerReducer: k2.eagerReducer,
          eagerState: k2.eagerState,
          next: null
        };
        h2 === null ? (g2 = h2 = n2, f2 = d2) : h2 = h2.next = n2;
        R.lanes |= l2;
        Dg |= l2;
      }
      k2 = k2.next;
    } while (k2 !== null && k2 !== e2);
    h2 === null ? f2 = d2 : h2.next = g2;
    He(d2, b2.memoizedState) || (ug = true);
    b2.memoizedState = d2;
    b2.baseState = f2;
    b2.baseQueue = h2;
    c2.lastRenderedState = d2;
  }
  return [b2.memoizedState, c2.dispatch];
}
function Lh(a) {
  var b2 = Ih(), c2 = b2.queue;
  if (c2 === null)
    throw Error(y(311));
  c2.lastRenderedReducer = a;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (e2 !== null) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (ug = true);
    b2.memoizedState = f2;
    b2.baseQueue === null && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Mh(a, b2, c2) {
  var d2 = b2._getVersion;
  d2 = d2(b2._source);
  var e2 = b2._workInProgressVersionPrimary;
  if (e2 !== null)
    a = e2 === d2;
  else if (a = a.mutableReadLanes, a = (xh & a) === a)
    b2._workInProgressVersionPrimary = d2, th.push(b2);
  if (a)
    return c2(b2._source);
  th.push(b2);
  throw Error(y(350));
}
function Nh(a, b2, c2, d2) {
  var e2 = U;
  if (e2 === null)
    throw Error(y(349));
  var f2 = b2._getVersion, g2 = f2(b2._source), h2 = vh.current, k2 = h2.useState(function() {
    return Mh(e2, b2, c2);
  }), l2 = k2[1], n2 = k2[0];
  k2 = T;
  var A2 = a.memoizedState, p2 = A2.refs, C = p2.getSnapshot, x2 = A2.source;
  A2 = A2.subscribe;
  var w2 = R;
  a.memoizedState = {refs: p2, source: b2, subscribe: d2};
  h2.useEffect(function() {
    p2.getSnapshot = c2;
    p2.setSnapshot = l2;
    var a2 = f2(b2._source);
    if (!He(g2, a2)) {
      a2 = c2(b2._source);
      He(n2, a2) || (l2(a2), a2 = Ig(w2), e2.mutableReadLanes |= a2 & e2.pendingLanes);
      a2 = e2.mutableReadLanes;
      e2.entangledLanes |= a2;
      for (var d3 = e2.entanglements, h3 = a2; 0 < h3; ) {
        var k3 = 31 - Vc(h3), v2 = 1 << k3;
        d3[k3] |= a2;
        h3 &= ~v2;
      }
    }
  }, [c2, b2, d2]);
  h2.useEffect(function() {
    return d2(b2._source, function() {
      var a2 = p2.getSnapshot, c3 = p2.setSnapshot;
      try {
        c3(a2(b2._source));
        var d3 = Ig(w2);
        e2.mutableReadLanes |= d3 & e2.pendingLanes;
      } catch (q2) {
        c3(function() {
          throw q2;
        });
      }
    });
  }, [b2, d2]);
  He(C, c2) && He(x2, b2) && He(A2, d2) || (a = {pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2}, a.dispatch = l2 = Oh.bind(null, R, a), k2.queue = a, k2.baseQueue = null, n2 = Mh(e2, b2, c2), k2.memoizedState = k2.baseState = n2);
  return n2;
}
function Ph(a, b2, c2) {
  var d2 = Ih();
  return Nh(d2, a, b2, c2);
}
function Qh(a) {
  var b2 = Hh();
  typeof a === "function" && (a = a());
  b2.memoizedState = b2.baseState = a;
  a = b2.queue = {pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a};
  a = a.dispatch = Oh.bind(null, R, a);
  return [b2.memoizedState, a];
}
function Rh(a, b2, c2, d2) {
  a = {tag: a, create: b2, destroy: c2, deps: d2, next: null};
  b2 = R.updateQueue;
  b2 === null ? (b2 = {lastEffect: null}, R.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, c2 === null ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
  return a;
}
function Sh(a) {
  var b2 = Hh();
  a = {current: a};
  return b2.memoizedState = a;
}
function Th() {
  return Ih().memoizedState;
}
function Uh(a, b2, c2, d2) {
  var e2 = Hh();
  R.flags |= a;
  e2.memoizedState = Rh(1 | b2, c2, void 0, d2 === void 0 ? null : d2);
}
function Vh(a, b2, c2, d2) {
  var e2 = Ih();
  d2 = d2 === void 0 ? null : d2;
  var f2 = void 0;
  if (S !== null) {
    var g2 = S.memoizedState;
    f2 = g2.destroy;
    if (d2 !== null && Bh(d2, g2.deps)) {
      Rh(b2, c2, f2, d2);
      return;
    }
  }
  R.flags |= a;
  e2.memoizedState = Rh(1 | b2, c2, f2, d2);
}
function Wh(a, b2) {
  return Uh(516, 4, a, b2);
}
function Xh(a, b2) {
  return Vh(516, 4, a, b2);
}
function Yh(a, b2) {
  return Vh(4, 2, a, b2);
}
function Zh(a, b2) {
  if (typeof b2 === "function")
    return a = a(), b2(a), function() {
      b2(null);
    };
  if (b2 !== null && b2 !== void 0)
    return a = a(), b2.current = a, function() {
      b2.current = null;
    };
}
function $h(a, b2, c2) {
  c2 = c2 !== null && c2 !== void 0 ? c2.concat([a]) : null;
  return Vh(4, 2, Zh.bind(null, b2, a), c2);
}
function ai() {
}
function bi(a, b2) {
  var c2 = Ih();
  b2 = b2 === void 0 ? null : b2;
  var d2 = c2.memoizedState;
  if (d2 !== null && b2 !== null && Bh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a, b2];
  return a;
}
function ci(a, b2) {
  var c2 = Ih();
  b2 = b2 === void 0 ? null : b2;
  var d2 = c2.memoizedState;
  if (d2 !== null && b2 !== null && Bh(b2, d2[1]))
    return d2[0];
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}
function di(a, b2) {
  var c2 = eg();
  gg(98 > c2 ? 98 : c2, function() {
    a(true);
  });
  gg(97 < c2 ? 97 : c2, function() {
    var c3 = wh.transition;
    wh.transition = 1;
    try {
      a(false), b2();
    } finally {
      wh.transition = c3;
    }
  });
}
function Oh(a, b2, c2) {
  var d2 = Hg(), e2 = Ig(a), f2 = {lane: e2, action: c2, eagerReducer: null, eagerState: null, next: null}, g2 = b2.pending;
  g2 === null ? f2.next = f2 : (f2.next = g2.next, g2.next = f2);
  b2.pending = f2;
  g2 = a.alternate;
  if (a === R || g2 !== null && g2 === R)
    zh = yh = true;
  else {
    if (a.lanes === 0 && (g2 === null || g2.lanes === 0) && (g2 = b2.lastRenderedReducer, g2 !== null))
      try {
        var h2 = b2.lastRenderedState, k2 = g2(h2, c2);
        f2.eagerReducer = g2;
        f2.eagerState = k2;
        if (He(k2, h2))
          return;
      } catch (l2) {
      } finally {
      }
    Jg(a, e2, d2);
  }
}
var Gh = {readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false};
var Dh = {readContext: vg, useCallback: function(a, b2) {
  Hh().memoizedState = [a, b2 === void 0 ? null : b2];
  return a;
}, useContext: vg, useEffect: Wh, useImperativeHandle: function(a, b2, c2) {
  c2 = c2 !== null && c2 !== void 0 ? c2.concat([a]) : null;
  return Uh(4, 2, Zh.bind(null, b2, a), c2);
}, useLayoutEffect: function(a, b2) {
  return Uh(4, 2, a, b2);
}, useMemo: function(a, b2) {
  var c2 = Hh();
  b2 = b2 === void 0 ? null : b2;
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}, useReducer: function(a, b2, c2) {
  var d2 = Hh();
  b2 = c2 !== void 0 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a = d2.queue = {pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2};
  a = a.dispatch = Oh.bind(null, R, a);
  return [d2.memoizedState, a];
}, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a) {
  var b2 = Qh(a), c2 = b2[0], d2 = b2[1];
  Wh(function() {
    var b3 = wh.transition;
    wh.transition = 1;
    try {
      d2(a);
    } finally {
      wh.transition = b3;
    }
  }, [a]);
  return c2;
}, useTransition: function() {
  var a = Qh(false), b2 = a[0];
  a = di.bind(null, a[1]);
  Sh(a);
  return [a, b2];
}, useMutableSource: function(a, b2, c2) {
  var d2 = Hh();
  d2.memoizedState = {refs: {getSnapshot: b2, setSnapshot: null}, source: a, subscribe: c2};
  return Nh(d2, a, b2, c2);
}, useOpaqueIdentifier: function() {
  if (lh) {
    var a = false, b2 = uf(function() {
      a || (a = true, c2("r:" + (tf++).toString(36)));
      throw Error(y(355));
    }), c2 = Qh(b2)[1];
    (R.mode & 2) === 0 && (R.flags |= 516, Rh(5, function() {
      c2("r:" + (tf++).toString(36));
    }, void 0, null));
    return b2;
  }
  b2 = "r:" + (tf++).toString(36);
  Qh(b2);
  return b2;
}, unstable_isNewReconciler: false};
var Eh = {readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
  return Kh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b2 = Kh(Jh), c2 = b2[0], d2 = b2[1];
  Xh(function() {
    var b3 = wh.transition;
    wh.transition = 1;
    try {
      d2(a);
    } finally {
      wh.transition = b3;
    }
  }, [a]);
  return c2;
}, useTransition: function() {
  var a = Kh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Kh(Jh)[0];
}, unstable_isNewReconciler: false};
var Fh = {readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
  return Lh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b2 = Lh(Jh), c2 = b2[0], d2 = b2[1];
  Xh(function() {
    var b3 = wh.transition;
    wh.transition = 1;
    try {
      d2(a);
    } finally {
      wh.transition = b3;
    }
  }, [a]);
  return c2;
}, useTransition: function() {
  var a = Lh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Lh(Jh)[0];
}, unstable_isNewReconciler: false};
var ei = ra.ReactCurrentOwner;
var ug = false;
function fi(a, b2, c2, d2) {
  b2.child = a === null ? Zg(b2, null, c2, d2) : Yg(b2, a.child, c2, d2);
}
function gi(a, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  tg(b2, e2);
  d2 = Ch(a, b2, c2, d2, f2, e2);
  if (a !== null && !ug)
    return b2.updateQueue = a.updateQueue, b2.flags &= -517, a.lanes &= ~e2, hi(a, b2, e2);
  b2.flags |= 1;
  fi(a, b2, d2, e2);
  return b2.child;
}
function ii(a, b2, c2, d2, e2, f2) {
  if (a === null) {
    var g2 = c2.type;
    if (typeof g2 === "function" && !ji(g2) && g2.defaultProps === void 0 && c2.compare === null && c2.defaultProps === void 0)
      return b2.tag = 15, b2.type = g2, ki(a, b2, g2, d2, e2, f2);
    a = Vg(c2.type, null, d2, b2, b2.mode, f2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  g2 = a.child;
  if ((e2 & f2) === 0 && (e2 = g2.memoizedProps, c2 = c2.compare, c2 = c2 !== null ? c2 : Je, c2(e2, d2) && a.ref === b2.ref))
    return hi(a, b2, f2);
  b2.flags |= 1;
  a = Tg(g2, d2);
  a.ref = b2.ref;
  a.return = b2;
  return b2.child = a;
}
function ki(a, b2, c2, d2, e2, f2) {
  if (a !== null && Je(a.memoizedProps, d2) && a.ref === b2.ref)
    if (ug = false, (f2 & e2) !== 0)
      (a.flags & 16384) !== 0 && (ug = true);
    else
      return b2.lanes = a.lanes, hi(a, b2, f2);
  return li(a, b2, c2, d2, f2);
}
function mi(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = a !== null ? a.memoizedState : null;
  if (d2.mode === "hidden" || d2.mode === "unstable-defer-without-hiding")
    if ((b2.mode & 4) === 0)
      b2.memoizedState = {baseLanes: 0}, ni(b2, c2);
    else if ((c2 & 1073741824) !== 0)
      b2.memoizedState = {baseLanes: 0}, ni(b2, f2 !== null ? f2.baseLanes : c2);
    else
      return a = f2 !== null ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = {baseLanes: a}, ni(b2, a), null;
  else
    f2 !== null ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, ni(b2, d2);
  fi(a, b2, e2, c2);
  return b2.child;
}
function oi(a, b2) {
  var c2 = b2.ref;
  if (a === null && c2 !== null || a !== null && a.ref !== c2)
    b2.flags |= 128;
}
function li(a, b2, c2, d2, e2) {
  var f2 = Ff(c2) ? Df : M.current;
  f2 = Ef(b2, f2);
  tg(b2, e2);
  c2 = Ch(a, b2, c2, d2, f2, e2);
  if (a !== null && !ug)
    return b2.updateQueue = a.updateQueue, b2.flags &= -517, a.lanes &= ~e2, hi(a, b2, e2);
  b2.flags |= 1;
  fi(a, b2, c2, e2);
  return b2.child;
}
function pi(a, b2, c2, d2, e2) {
  if (Ff(c2)) {
    var f2 = true;
    Jf(b2);
  } else
    f2 = false;
  tg(b2, e2);
  if (b2.stateNode === null)
    a !== null && (a.alternate = null, b2.alternate = null, b2.flags |= 2), Mg(b2, c2, d2), Og(b2, c2, d2, e2), d2 = true;
  else if (a === null) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    typeof l2 === "object" && l2 !== null ? l2 = vg(l2) : (l2 = Ff(c2) ? Df : M.current, l2 = Ef(b2, l2));
    var n2 = c2.getDerivedStateFromProps, A2 = typeof n2 === "function" || typeof g2.getSnapshotBeforeUpdate === "function";
    A2 || typeof g2.UNSAFE_componentWillReceiveProps !== "function" && typeof g2.componentWillReceiveProps !== "function" || (h2 !== d2 || k2 !== l2) && Ng(b2, g2, d2, l2);
    wg = false;
    var p2 = b2.memoizedState;
    g2.state = p2;
    Cg(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || p2 !== k2 || N.current || wg ? (typeof n2 === "function" && (Gg(b2, c2, n2, d2), k2 = b2.memoizedState), (h2 = wg || Lg(b2, c2, h2, d2, p2, k2, l2)) ? (A2 || typeof g2.UNSAFE_componentWillMount !== "function" && typeof g2.componentWillMount !== "function" || (typeof g2.componentWillMount === "function" && g2.componentWillMount(), typeof g2.UNSAFE_componentWillMount === "function" && g2.UNSAFE_componentWillMount()), typeof g2.componentDidMount === "function" && (b2.flags |= 4)) : (typeof g2.componentDidMount === "function" && (b2.flags |= 4), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : (typeof g2.componentDidMount === "function" && (b2.flags |= 4), d2 = false);
  } else {
    g2 = b2.stateNode;
    yg(a, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : lg(b2.type, h2);
    g2.props = l2;
    A2 = b2.pendingProps;
    p2 = g2.context;
    k2 = c2.contextType;
    typeof k2 === "object" && k2 !== null ? k2 = vg(k2) : (k2 = Ff(c2) ? Df : M.current, k2 = Ef(b2, k2));
    var C = c2.getDerivedStateFromProps;
    (n2 = typeof C === "function" || typeof g2.getSnapshotBeforeUpdate === "function") || typeof g2.UNSAFE_componentWillReceiveProps !== "function" && typeof g2.componentWillReceiveProps !== "function" || (h2 !== A2 || p2 !== k2) && Ng(b2, g2, d2, k2);
    wg = false;
    p2 = b2.memoizedState;
    g2.state = p2;
    Cg(b2, d2, g2, e2);
    var x2 = b2.memoizedState;
    h2 !== A2 || p2 !== x2 || N.current || wg ? (typeof C === "function" && (Gg(b2, c2, C, d2), x2 = b2.memoizedState), (l2 = wg || Lg(b2, c2, l2, d2, p2, x2, k2)) ? (n2 || typeof g2.UNSAFE_componentWillUpdate !== "function" && typeof g2.componentWillUpdate !== "function" || (typeof g2.componentWillUpdate === "function" && g2.componentWillUpdate(d2, x2, k2), typeof g2.UNSAFE_componentWillUpdate === "function" && g2.UNSAFE_componentWillUpdate(d2, x2, k2)), typeof g2.componentDidUpdate === "function" && (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate === "function" && (b2.flags |= 256)) : (typeof g2.componentDidUpdate !== "function" || h2 === a.memoizedProps && p2 === a.memoizedState || (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate !== "function" || h2 === a.memoizedProps && p2 === a.memoizedState || (b2.flags |= 256), b2.memoizedProps = d2, b2.memoizedState = x2), g2.props = d2, g2.state = x2, g2.context = k2, d2 = l2) : (typeof g2.componentDidUpdate !== "function" || h2 === a.memoizedProps && p2 === a.memoizedState || (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate !== "function" || h2 === a.memoizedProps && p2 === a.memoizedState || (b2.flags |= 256), d2 = false);
  }
  return qi(a, b2, c2, d2, f2, e2);
}
function qi(a, b2, c2, d2, e2, f2) {
  oi(a, b2);
  var g2 = (b2.flags & 64) !== 0;
  if (!d2 && !g2)
    return e2 && Kf(b2, c2, false), hi(a, b2, f2);
  d2 = b2.stateNode;
  ei.current = b2;
  var h2 = g2 && typeof c2.getDerivedStateFromError !== "function" ? null : d2.render();
  b2.flags |= 1;
  a !== null && g2 ? (b2.child = Yg(b2, a.child, null, f2), b2.child = Yg(b2, null, h2, f2)) : fi(a, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && Kf(b2, c2, true);
  return b2.child;
}
function ri(a) {
  var b2 = a.stateNode;
  b2.pendingContext ? Hf(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && Hf(a, b2.context, false);
  eh(a, b2.containerInfo);
}
var si = {dehydrated: null, retryLane: 0};
function ti(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = P.current, f2 = false, g2;
  (g2 = (b2.flags & 64) !== 0) || (g2 = a !== null && a.memoizedState === null ? false : (e2 & 2) !== 0);
  g2 ? (f2 = true, b2.flags &= -65) : a !== null && a.memoizedState === null || d2.fallback === void 0 || d2.unstable_avoidThisFallback === true || (e2 |= 1);
  I(P, e2 & 1);
  if (a === null) {
    d2.fallback !== void 0 && ph(b2);
    a = d2.children;
    e2 = d2.fallback;
    if (f2)
      return a = ui(b2, a, e2, c2), b2.child.memoizedState = {baseLanes: c2}, b2.memoizedState = si, a;
    if (typeof d2.unstable_expectedLoadTime === "number")
      return a = ui(b2, a, e2, c2), b2.child.memoizedState = {baseLanes: c2}, b2.memoizedState = si, b2.lanes = 33554432, a;
    c2 = vi({mode: "visible", children: a}, b2.mode, c2, null);
    c2.return = b2;
    return b2.child = c2;
  }
  if (a.memoizedState !== null) {
    if (f2)
      return d2 = wi(a, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a.child.memoizedState, f2.memoizedState = e2 === null ? {baseLanes: c2} : {baseLanes: e2.baseLanes | c2}, f2.childLanes = a.childLanes & ~c2, b2.memoizedState = si, d2;
    c2 = xi(a, b2, d2.children, c2);
    b2.memoizedState = null;
    return c2;
  }
  if (f2)
    return d2 = wi(a, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a.child.memoizedState, f2.memoizedState = e2 === null ? {baseLanes: c2} : {baseLanes: e2.baseLanes | c2}, f2.childLanes = a.childLanes & ~c2, b2.memoizedState = si, d2;
  c2 = xi(a, b2, d2.children, c2);
  b2.memoizedState = null;
  return c2;
}
function ui(a, b2, c2, d2) {
  var e2 = a.mode, f2 = a.child;
  b2 = {mode: "hidden", children: b2};
  (e2 & 2) === 0 && f2 !== null ? (f2.childLanes = 0, f2.pendingProps = b2) : f2 = vi(b2, e2, 0, null);
  c2 = Xg(c2, e2, d2, null);
  f2.return = a;
  c2.return = a;
  f2.sibling = c2;
  a.child = f2;
  return c2;
}
function xi(a, b2, c2, d2) {
  var e2 = a.child;
  a = e2.sibling;
  c2 = Tg(e2, {mode: "visible", children: c2});
  (b2.mode & 2) === 0 && (c2.lanes = d2);
  c2.return = b2;
  c2.sibling = null;
  a !== null && (a.nextEffect = null, a.flags = 8, b2.firstEffect = b2.lastEffect = a);
  return b2.child = c2;
}
function wi(a, b2, c2, d2, e2) {
  var f2 = b2.mode, g2 = a.child;
  a = g2.sibling;
  var h2 = {mode: "hidden", children: c2};
  (f2 & 2) === 0 && b2.child !== g2 ? (c2 = b2.child, c2.childLanes = 0, c2.pendingProps = h2, g2 = c2.lastEffect, g2 !== null ? (b2.firstEffect = c2.firstEffect, b2.lastEffect = g2, g2.nextEffect = null) : b2.firstEffect = b2.lastEffect = null) : c2 = Tg(g2, h2);
  a !== null ? d2 = Tg(a, d2) : (d2 = Xg(d2, f2, e2, null), d2.flags |= 2);
  d2.return = b2;
  c2.return = b2;
  c2.sibling = d2;
  b2.child = c2;
  return d2;
}
function yi(a, b2) {
  a.lanes |= b2;
  var c2 = a.alternate;
  c2 !== null && (c2.lanes |= b2);
  sg(a.return, b2);
}
function zi(a, b2, c2, d2, e2, f2) {
  var g2 = a.memoizedState;
  g2 === null ? a.memoizedState = {isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2, lastEffect: f2} : (g2.isBackwards = b2, g2.rendering = null, g2.renderingStartTime = 0, g2.last = d2, g2.tail = c2, g2.tailMode = e2, g2.lastEffect = f2);
}
function Ai(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  fi(a, b2, d2.children, c2);
  d2 = P.current;
  if ((d2 & 2) !== 0)
    d2 = d2 & 1 | 2, b2.flags |= 64;
  else {
    if (a !== null && (a.flags & 64) !== 0)
      a:
        for (a = b2.child; a !== null; ) {
          if (a.tag === 13)
            a.memoizedState !== null && yi(a, c2);
          else if (a.tag === 19)
            yi(a, c2);
          else if (a.child !== null) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b2)
            break a;
          for (; a.sibling === null; ) {
            if (a.return === null || a.return === b2)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d2 &= 1;
  }
  I(P, d2);
  if ((b2.mode & 2) === 0)
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; c2 !== null; )
          a = c2.alternate, a !== null && ih(a) === null && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        c2 === null ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        zi(b2, false, e2, c2, f2, b2.lastEffect);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; e2 !== null; ) {
          a = e2.alternate;
          if (a !== null && ih(a) === null) {
            b2.child = e2;
            break;
          }
          a = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a;
        }
        zi(b2, true, c2, null, f2, b2.lastEffect);
        break;
      case "together":
        zi(b2, false, null, null, void 0, b2.lastEffect);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function hi(a, b2, c2) {
  a !== null && (b2.dependencies = a.dependencies);
  Dg |= b2.lanes;
  if ((c2 & b2.childLanes) !== 0) {
    if (a !== null && b2.child !== a.child)
      throw Error(y(153));
    if (b2.child !== null) {
      a = b2.child;
      c2 = Tg(a, a.pendingProps);
      b2.child = c2;
      for (c2.return = b2; a.sibling !== null; )
        a = a.sibling, c2 = c2.sibling = Tg(a, a.pendingProps), c2.return = b2;
      c2.sibling = null;
    }
    return b2.child;
  }
  return null;
}
var Bi;
var Ci;
var Di;
var Ei;
Bi = function(a, b2) {
  for (var c2 = b2.child; c2 !== null; ) {
    if (c2.tag === 5 || c2.tag === 6)
      a.appendChild(c2.stateNode);
    else if (c2.tag !== 4 && c2.child !== null) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; c2.sibling === null; ) {
      if (c2.return === null || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Ci = function() {
};
Di = function(a, b2, c2, d2) {
  var e2 = a.memoizedProps;
  if (e2 !== d2) {
    a = b2.stateNode;
    dh(ah.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a, e2);
        d2 = Ya(a, d2);
        f2 = [];
        break;
      case "option":
        e2 = eb(a, e2);
        d2 = eb(a, d2);
        f2 = [];
        break;
      case "select":
        e2 = objectAssign({}, e2, {value: void 0});
        d2 = objectAssign({}, d2, {value: void 0});
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a, e2);
        d2 = gb(a, d2);
        f2 = [];
        break;
      default:
        typeof e2.onClick !== "function" && typeof d2.onClick === "function" && (a.onclick = jf);
    }
    vb(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && e2[l2] != null)
        if (l2 === "style") {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          l2 !== "dangerouslySetInnerHTML" && l2 !== "children" && l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && l2 !== "autoFocus" && (ca.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = e2 != null ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (k2 != null || h2 != null))
        if (l2 === "style")
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(l2, c2)), c2 = k2;
        else
          l2 === "dangerouslySetInnerHTML" ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, k2 != null && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : l2 === "children" ? typeof k2 !== "string" && typeof k2 !== "number" || (f2 = f2 || []).push(l2, "" + k2) : l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && (ca.hasOwnProperty(l2) ? (k2 != null && l2 === "onScroll" && G("scroll", a), f2 || h2 === k2 || (f2 = [])) : typeof k2 === "object" && k2 !== null && k2.$$typeof === Ga ? k2.toString() : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Ei = function(a, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Fi(a, b2) {
  if (!lh)
    switch (a.tailMode) {
      case "hidden":
        b2 = a.tail;
        for (var c2 = null; b2 !== null; )
          b2.alternate !== null && (c2 = b2), b2 = b2.sibling;
        c2 === null ? a.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a.tail;
        for (var d2 = null; c2 !== null; )
          c2.alternate !== null && (d2 = c2), c2 = c2.sibling;
        d2 === null ? b2 || a.tail === null ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
    }
}
function Gi(a, b2, c2) {
  var d2 = b2.pendingProps;
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;
    case 1:
      return Ff(b2.type) && Gf(), null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      d2 = b2.stateNode;
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (a === null || a.child === null)
        rh(b2) ? b2.flags |= 4 : d2.hydrate || (b2.flags |= 256);
      Ci(b2);
      return null;
    case 5:
      hh(b2);
      var e2 = dh(ch.current);
      c2 = b2.type;
      if (a !== null && b2.stateNode != null)
        Di(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 128);
      else {
        if (!d2) {
          if (b2.stateNode === null)
            throw Error(y(166));
          return null;
        }
        a = dh(ah.current);
        if (rh(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[wf] = b2;
          d2[xf] = f2;
          switch (c2) {
            case "dialog":
              G("cancel", d2);
              G("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", d2);
              break;
            case "video":
            case "audio":
              for (a = 0; a < Xe.length; a++)
                G(Xe[a], d2);
              break;
            case "source":
              G("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              G("error", d2);
              G("load", d2);
              break;
            case "details":
              G("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              G("invalid", d2);
              break;
            case "select":
              d2._wrapperState = {wasMultiple: !!f2.multiple};
              G("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), G("invalid", d2);
          }
          vb(c2, f2);
          a = null;
          for (var g2 in f2)
            f2.hasOwnProperty(g2) && (e2 = f2[g2], g2 === "children" ? typeof e2 === "string" ? d2.textContent !== e2 && (a = ["children", e2]) : typeof e2 === "number" && d2.textContent !== "" + e2 && (a = ["children", "" + e2]) : ca.hasOwnProperty(g2) && e2 != null && g2 === "onScroll" && G("scroll", d2));
          switch (c2) {
            case "input":
              Va(d2);
              cb(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof f2.onClick === "function" && (d2.onclick = jf);
          }
          d2 = a;
          b2.updateQueue = d2;
          d2 !== null && (b2.flags |= 4);
        } else {
          g2 = e2.nodeType === 9 ? e2 : e2.ownerDocument;
          a === kb.html && (a = lb(c2));
          a === kb.html ? c2 === "script" ? (a = g2.createElement("div"), a.innerHTML = "<script></script>", a = a.removeChild(a.firstChild)) : typeof d2.is === "string" ? a = g2.createElement(c2, {is: d2.is}) : (a = g2.createElement(c2), c2 === "select" && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
          a[wf] = b2;
          a[xf] = d2;
          Bi(a, b2, false, false);
          b2.stateNode = a;
          g2 = wb(c2, d2);
          switch (c2) {
            case "dialog":
              G("cancel", a);
              G("close", a);
              e2 = d2;
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", a);
              e2 = d2;
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < Xe.length; e2++)
                G(Xe[e2], a);
              e2 = d2;
              break;
            case "source":
              G("error", a);
              e2 = d2;
              break;
            case "img":
            case "image":
            case "link":
              G("error", a);
              G("load", a);
              e2 = d2;
              break;
            case "details":
              G("toggle", a);
              e2 = d2;
              break;
            case "input":
              Za(a, d2);
              e2 = Ya(a, d2);
              G("invalid", a);
              break;
            case "option":
              e2 = eb(a, d2);
              break;
            case "select":
              a._wrapperState = {wasMultiple: !!d2.multiple};
              e2 = objectAssign({}, d2, {value: void 0});
              G("invalid", a);
              break;
            case "textarea":
              hb(a, d2);
              e2 = gb(a, d2);
              G("invalid", a);
              break;
            default:
              e2 = d2;
          }
          vb(c2, e2);
          var h2 = e2;
          for (f2 in h2)
            if (h2.hasOwnProperty(f2)) {
              var k2 = h2[f2];
              f2 === "style" ? tb(a, k2) : f2 === "dangerouslySetInnerHTML" ? (k2 = k2 ? k2.__html : void 0, k2 != null && ob(a, k2)) : f2 === "children" ? typeof k2 === "string" ? (c2 !== "textarea" || k2 !== "") && pb(a, k2) : typeof k2 === "number" && pb(a, "" + k2) : f2 !== "suppressContentEditableWarning" && f2 !== "suppressHydrationWarning" && f2 !== "autoFocus" && (ca.hasOwnProperty(f2) ? k2 != null && f2 === "onScroll" && G("scroll", a) : k2 != null && qa(a, f2, k2, g2));
            }
          switch (c2) {
            case "input":
              Va(a);
              cb(a, d2, false);
              break;
            case "textarea":
              Va(a);
              jb(a);
              break;
            case "option":
              d2.value != null && a.setAttribute("value", "" + Sa(d2.value));
              break;
            case "select":
              a.multiple = !!d2.multiple;
              f2 = d2.value;
              f2 != null ? fb(a, !!d2.multiple, f2, false) : d2.defaultValue != null && fb(a, !!d2.multiple, d2.defaultValue, true);
              break;
            default:
              typeof e2.onClick === "function" && (a.onclick = jf);
          }
          mf(c2, d2) && (b2.flags |= 4);
        }
        b2.ref !== null && (b2.flags |= 128);
      }
      return null;
    case 6:
      if (a && b2.stateNode != null)
        Ei(a, b2, a.memoizedProps, d2);
      else {
        if (typeof d2 !== "string" && b2.stateNode === null)
          throw Error(y(166));
        c2 = dh(ch.current);
        dh(ah.current);
        rh(b2) ? (d2 = b2.stateNode, c2 = b2.memoizedProps, d2[wf] = b2, d2.nodeValue !== c2 && (b2.flags |= 4)) : (d2 = (c2.nodeType === 9 ? c2 : c2.ownerDocument).createTextNode(d2), d2[wf] = b2, b2.stateNode = d2);
      }
      return null;
    case 13:
      H(P);
      d2 = b2.memoizedState;
      if ((b2.flags & 64) !== 0)
        return b2.lanes = c2, b2;
      d2 = d2 !== null;
      c2 = false;
      a === null ? b2.memoizedProps.fallback !== void 0 && rh(b2) : c2 = a.memoizedState !== null;
      if (d2 && !c2 && (b2.mode & 2) !== 0)
        if (a === null && b2.memoizedProps.unstable_avoidThisFallback !== true || (P.current & 1) !== 0)
          V === 0 && (V = 3);
        else {
          if (V === 0 || V === 3)
            V = 4;
          U === null || (Dg & 134217727) === 0 && (Hi & 134217727) === 0 || Ii(U, W);
        }
      if (d2 || c2)
        b2.flags |= 4;
      return null;
    case 4:
      return fh(), Ci(b2), a === null && cf(b2.stateNode.containerInfo), null;
    case 10:
      return rg(b2), null;
    case 17:
      return Ff(b2.type) && Gf(), null;
    case 19:
      H(P);
      d2 = b2.memoizedState;
      if (d2 === null)
        return null;
      f2 = (b2.flags & 64) !== 0;
      g2 = d2.rendering;
      if (g2 === null)
        if (f2)
          Fi(d2, false);
        else {
          if (V !== 0 || a !== null && (a.flags & 64) !== 0)
            for (a = b2.child; a !== null; ) {
              g2 = ih(a);
              if (g2 !== null) {
                b2.flags |= 64;
                Fi(d2, false);
                f2 = g2.updateQueue;
                f2 !== null && (b2.updateQueue = f2, b2.flags |= 4);
                d2.lastEffect === null && (b2.firstEffect = null);
                b2.lastEffect = d2.lastEffect;
                d2 = c2;
                for (c2 = b2.child; c2 !== null; )
                  f2 = c2, a = d2, f2.flags &= 2, f2.nextEffect = null, f2.firstEffect = null, f2.lastEffect = null, g2 = f2.alternate, g2 === null ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = a === null ? null : {lanes: a.lanes, firstContext: a.firstContext}), c2 = c2.sibling;
                I(P, P.current & 1 | 2);
                return b2.child;
              }
              a = a.sibling;
            }
          d2.tail !== null && O() > Ji && (b2.flags |= 64, f2 = true, Fi(d2, false), b2.lanes = 33554432);
        }
      else {
        if (!f2)
          if (a = ih(g2), a !== null) {
            if (b2.flags |= 64, f2 = true, c2 = a.updateQueue, c2 !== null && (b2.updateQueue = c2, b2.flags |= 4), Fi(d2, true), d2.tail === null && d2.tailMode === "hidden" && !g2.alternate && !lh)
              return b2 = b2.lastEffect = d2.lastEffect, b2 !== null && (b2.nextEffect = null), null;
          } else
            2 * O() - d2.renderingStartTime > Ji && c2 !== 1073741824 && (b2.flags |= 64, f2 = true, Fi(d2, false), b2.lanes = 33554432);
        d2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = d2.last, c2 !== null ? c2.sibling = g2 : b2.child = g2, d2.last = g2);
      }
      return d2.tail !== null ? (c2 = d2.tail, d2.rendering = c2, d2.tail = c2.sibling, d2.lastEffect = b2.lastEffect, d2.renderingStartTime = O(), c2.sibling = null, b2 = P.current, I(P, f2 ? b2 & 1 | 2 : b2 & 1), c2) : null;
    case 23:
    case 24:
      return Ki(), a !== null && a.memoizedState !== null !== (b2.memoizedState !== null) && d2.mode !== "unstable-defer-without-hiding" && (b2.flags |= 4), null;
  }
  throw Error(y(156, b2.tag));
}
function Li(a) {
  switch (a.tag) {
    case 1:
      Ff(a.type) && Gf();
      var b2 = a.flags;
      return b2 & 4096 ? (a.flags = b2 & -4097 | 64, a) : null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      b2 = a.flags;
      if ((b2 & 64) !== 0)
        throw Error(y(285));
      a.flags = b2 & -4097 | 64;
      return a;
    case 5:
      return hh(a), null;
    case 13:
      return H(P), b2 = a.flags, b2 & 4096 ? (a.flags = b2 & -4097 | 64, a) : null;
    case 19:
      return H(P), null;
    case 4:
      return fh(), null;
    case 10:
      return rg(a), null;
    case 23:
    case 24:
      return Ki(), null;
    default:
      return null;
  }
}
function Mi(a, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Qa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return {value: a, source: b2, stack: e2};
}
function Ni(a, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Oi = typeof WeakMap === "function" ? WeakMap : Map;
function Pi(a, b2, c2) {
  c2 = zg(-1, c2);
  c2.tag = 3;
  c2.payload = {element: null};
  var d2 = b2.value;
  c2.callback = function() {
    Qi || (Qi = true, Ri = d2);
    Ni(a, b2);
  };
  return c2;
}
function Si(a, b2, c2) {
  c2 = zg(-1, c2);
  c2.tag = 3;
  var d2 = a.type.getDerivedStateFromError;
  if (typeof d2 === "function") {
    var e2 = b2.value;
    c2.payload = function() {
      Ni(a, b2);
      return d2(e2);
    };
  }
  var f2 = a.stateNode;
  f2 !== null && typeof f2.componentDidCatch === "function" && (c2.callback = function() {
    typeof d2 !== "function" && (Ti === null ? Ti = new Set([this]) : Ti.add(this), Ni(a, b2));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, {componentStack: c3 !== null ? c3 : ""});
  });
  return c2;
}
var Ui = typeof WeakSet === "function" ? WeakSet : Set;
function Vi(a) {
  var b2 = a.ref;
  if (b2 !== null)
    if (typeof b2 === "function")
      try {
        b2(null);
      } catch (c2) {
        Wi(a, c2);
      }
    else
      b2.current = null;
}
function Xi(a, b2) {
  switch (b2.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;
    case 1:
      if (b2.flags & 256 && a !== null) {
        var c2 = a.memoizedProps, d2 = a.memoizedState;
        a = b2.stateNode;
        b2 = a.getSnapshotBeforeUpdate(b2.elementType === b2.type ? c2 : lg(b2.type, c2), d2);
        a.__reactInternalSnapshotBeforeUpdate = b2;
      }
      return;
    case 3:
      b2.flags & 256 && qf(b2.stateNode.containerInfo);
      return;
    case 5:
    case 6:
    case 4:
    case 17:
      return;
  }
  throw Error(y(163));
}
function Yi(a, b2, c2) {
  switch (c2.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      b2 = c2.updateQueue;
      b2 = b2 !== null ? b2.lastEffect : null;
      if (b2 !== null) {
        a = b2 = b2.next;
        do {
          if ((a.tag & 3) === 3) {
            var d2 = a.create;
            a.destroy = d2();
          }
          a = a.next;
        } while (a !== b2);
      }
      b2 = c2.updateQueue;
      b2 = b2 !== null ? b2.lastEffect : null;
      if (b2 !== null) {
        a = b2 = b2.next;
        do {
          var e2 = a;
          d2 = e2.next;
          e2 = e2.tag;
          (e2 & 4) !== 0 && (e2 & 1) !== 0 && (Zi(c2, a), $i(c2, a));
          a = d2;
        } while (a !== b2);
      }
      return;
    case 1:
      a = c2.stateNode;
      c2.flags & 4 && (b2 === null ? a.componentDidMount() : (d2 = c2.elementType === c2.type ? b2.memoizedProps : lg(c2.type, b2.memoizedProps), a.componentDidUpdate(d2, b2.memoizedState, a.__reactInternalSnapshotBeforeUpdate)));
      b2 = c2.updateQueue;
      b2 !== null && Eg(c2, b2, a);
      return;
    case 3:
      b2 = c2.updateQueue;
      if (b2 !== null) {
        a = null;
        if (c2.child !== null)
          switch (c2.child.tag) {
            case 5:
              a = c2.child.stateNode;
              break;
            case 1:
              a = c2.child.stateNode;
          }
        Eg(c2, b2, a);
      }
      return;
    case 5:
      a = c2.stateNode;
      b2 === null && c2.flags & 4 && mf(c2.type, c2.memoizedProps) && a.focus();
      return;
    case 6:
      return;
    case 4:
      return;
    case 12:
      return;
    case 13:
      c2.memoizedState === null && (c2 = c2.alternate, c2 !== null && (c2 = c2.memoizedState, c2 !== null && (c2 = c2.dehydrated, c2 !== null && Cc(c2))));
      return;
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return;
  }
  throw Error(y(163));
}
function aj(a, b2) {
  for (var c2 = a; ; ) {
    if (c2.tag === 5) {
      var d2 = c2.stateNode;
      if (b2)
        d2 = d2.style, typeof d2.setProperty === "function" ? d2.setProperty("display", "none", "important") : d2.display = "none";
      else {
        d2 = c2.stateNode;
        var e2 = c2.memoizedProps.style;
        e2 = e2 !== void 0 && e2 !== null && e2.hasOwnProperty("display") ? e2.display : null;
        d2.style.display = sb("display", e2);
      }
    } else if (c2.tag === 6)
      c2.stateNode.nodeValue = b2 ? "" : c2.memoizedProps;
    else if ((c2.tag !== 23 && c2.tag !== 24 || c2.memoizedState === null || c2 === a) && c2.child !== null) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === a)
      break;
    for (; c2.sibling === null; ) {
      if (c2.return === null || c2.return === a)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
}
function bj(a, b2) {
  if (Mf && typeof Mf.onCommitFiberUnmount === "function")
    try {
      Mf.onCommitFiberUnmount(Lf, b2);
    } catch (f2) {
    }
  switch (b2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      a = b2.updateQueue;
      if (a !== null && (a = a.lastEffect, a !== null)) {
        var c2 = a = a.next;
        do {
          var d2 = c2, e2 = d2.destroy;
          d2 = d2.tag;
          if (e2 !== void 0)
            if ((d2 & 4) !== 0)
              Zi(b2, c2);
            else {
              d2 = b2;
              try {
                e2();
              } catch (f2) {
                Wi(d2, f2);
              }
            }
          c2 = c2.next;
        } while (c2 !== a);
      }
      break;
    case 1:
      Vi(b2);
      a = b2.stateNode;
      if (typeof a.componentWillUnmount === "function")
        try {
          a.props = b2.memoizedProps, a.state = b2.memoizedState, a.componentWillUnmount();
        } catch (f2) {
          Wi(b2, f2);
        }
      break;
    case 5:
      Vi(b2);
      break;
    case 4:
      cj(a, b2);
  }
}
function dj(a) {
  a.alternate = null;
  a.child = null;
  a.dependencies = null;
  a.firstEffect = null;
  a.lastEffect = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.return = null;
  a.updateQueue = null;
}
function ej(a) {
  return a.tag === 5 || a.tag === 3 || a.tag === 4;
}
function fj(a) {
  a: {
    for (var b2 = a.return; b2 !== null; ) {
      if (ej(b2))
        break a;
      b2 = b2.return;
    }
    throw Error(y(160));
  }
  var c2 = b2;
  b2 = c2.stateNode;
  switch (c2.tag) {
    case 5:
      var d2 = false;
      break;
    case 3:
      b2 = b2.containerInfo;
      d2 = true;
      break;
    case 4:
      b2 = b2.containerInfo;
      d2 = true;
      break;
    default:
      throw Error(y(161));
  }
  c2.flags & 16 && (pb(b2, ""), c2.flags &= -17);
  a:
    b:
      for (c2 = a; ; ) {
        for (; c2.sibling === null; ) {
          if (c2.return === null || ej(c2.return)) {
            c2 = null;
            break a;
          }
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        for (c2 = c2.sibling; c2.tag !== 5 && c2.tag !== 6 && c2.tag !== 18; ) {
          if (c2.flags & 2)
            continue b;
          if (c2.child === null || c2.tag === 4)
            continue b;
          else
            c2.child.return = c2, c2 = c2.child;
        }
        if (!(c2.flags & 2)) {
          c2 = c2.stateNode;
          break a;
        }
      }
  d2 ? gj(a, c2, b2) : hj(a, c2, b2);
}
function gj(a, b2, c2) {
  var d2 = a.tag, e2 = d2 === 5 || d2 === 6;
  if (e2)
    a = e2 ? a.stateNode : a.stateNode.instance, b2 ? c2.nodeType === 8 ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (c2.nodeType === 8 ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, c2 !== null && c2 !== void 0 || b2.onclick !== null || (b2.onclick = jf));
  else if (d2 !== 4 && (a = a.child, a !== null))
    for (gj(a, b2, c2), a = a.sibling; a !== null; )
      gj(a, b2, c2), a = a.sibling;
}
function hj(a, b2, c2) {
  var d2 = a.tag, e2 = d2 === 5 || d2 === 6;
  if (e2)
    a = e2 ? a.stateNode : a.stateNode.instance, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
  else if (d2 !== 4 && (a = a.child, a !== null))
    for (hj(a, b2, c2), a = a.sibling; a !== null; )
      hj(a, b2, c2), a = a.sibling;
}
function cj(a, b2) {
  for (var c2 = b2, d2 = false, e2, f2; ; ) {
    if (!d2) {
      d2 = c2.return;
      a:
        for (; ; ) {
          if (d2 === null)
            throw Error(y(160));
          e2 = d2.stateNode;
          switch (d2.tag) {
            case 5:
              f2 = false;
              break a;
            case 3:
              e2 = e2.containerInfo;
              f2 = true;
              break a;
            case 4:
              e2 = e2.containerInfo;
              f2 = true;
              break a;
          }
          d2 = d2.return;
        }
      d2 = true;
    }
    if (c2.tag === 5 || c2.tag === 6) {
      a:
        for (var g2 = a, h2 = c2, k2 = h2; ; )
          if (bj(g2, k2), k2.child !== null && k2.tag !== 4)
            k2.child.return = k2, k2 = k2.child;
          else {
            if (k2 === h2)
              break a;
            for (; k2.sibling === null; ) {
              if (k2.return === null || k2.return === h2)
                break a;
              k2 = k2.return;
            }
            k2.sibling.return = k2.return;
            k2 = k2.sibling;
          }
      f2 ? (g2 = e2, h2 = c2.stateNode, g2.nodeType === 8 ? g2.parentNode.removeChild(h2) : g2.removeChild(h2)) : e2.removeChild(c2.stateNode);
    } else if (c2.tag === 4) {
      if (c2.child !== null) {
        e2 = c2.stateNode.containerInfo;
        f2 = true;
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
    } else if (bj(a, c2), c2.child !== null) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; c2.sibling === null; ) {
      if (c2.return === null || c2.return === b2)
        return;
      c2 = c2.return;
      c2.tag === 4 && (d2 = false);
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
}
function ij(a, b2) {
  switch (b2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var c2 = b2.updateQueue;
      c2 = c2 !== null ? c2.lastEffect : null;
      if (c2 !== null) {
        var d2 = c2 = c2.next;
        do
          (d2.tag & 3) === 3 && (a = d2.destroy, d2.destroy = void 0, a !== void 0 && a()), d2 = d2.next;
        while (d2 !== c2);
      }
      return;
    case 1:
      return;
    case 5:
      c2 = b2.stateNode;
      if (c2 != null) {
        d2 = b2.memoizedProps;
        var e2 = a !== null ? a.memoizedProps : d2;
        a = b2.type;
        var f2 = b2.updateQueue;
        b2.updateQueue = null;
        if (f2 !== null) {
          c2[xf] = d2;
          a === "input" && d2.type === "radio" && d2.name != null && $a(c2, d2);
          wb(a, e2);
          b2 = wb(a, d2);
          for (e2 = 0; e2 < f2.length; e2 += 2) {
            var g2 = f2[e2], h2 = f2[e2 + 1];
            g2 === "style" ? tb(c2, h2) : g2 === "dangerouslySetInnerHTML" ? ob(c2, h2) : g2 === "children" ? pb(c2, h2) : qa(c2, g2, h2, b2);
          }
          switch (a) {
            case "input":
              ab(c2, d2);
              break;
            case "textarea":
              ib(c2, d2);
              break;
            case "select":
              a = c2._wrapperState.wasMultiple, c2._wrapperState.wasMultiple = !!d2.multiple, f2 = d2.value, f2 != null ? fb(c2, !!d2.multiple, f2, false) : a !== !!d2.multiple && (d2.defaultValue != null ? fb(c2, !!d2.multiple, d2.defaultValue, true) : fb(c2, !!d2.multiple, d2.multiple ? [] : "", false));
          }
        }
      }
      return;
    case 6:
      if (b2.stateNode === null)
        throw Error(y(162));
      b2.stateNode.nodeValue = b2.memoizedProps;
      return;
    case 3:
      c2 = b2.stateNode;
      c2.hydrate && (c2.hydrate = false, Cc(c2.containerInfo));
      return;
    case 12:
      return;
    case 13:
      b2.memoizedState !== null && (jj = O(), aj(b2.child, true));
      kj(b2);
      return;
    case 19:
      kj(b2);
      return;
    case 17:
      return;
    case 23:
    case 24:
      aj(b2, b2.memoizedState !== null);
      return;
  }
  throw Error(y(163));
}
function kj(a) {
  var b2 = a.updateQueue;
  if (b2 !== null) {
    a.updateQueue = null;
    var c2 = a.stateNode;
    c2 === null && (c2 = a.stateNode = new Ui());
    b2.forEach(function(b3) {
      var d2 = lj.bind(null, a, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function mj(a, b2) {
  return a !== null && (a = a.memoizedState, a === null || a.dehydrated !== null) ? (b2 = b2.memoizedState, b2 !== null && b2.dehydrated === null) : false;
}
var nj = Math.ceil;
var oj = ra.ReactCurrentDispatcher;
var pj = ra.ReactCurrentOwner;
var X = 0;
var U = null;
var Y = null;
var W = 0;
var qj = 0;
var rj = Bf(0);
var V = 0;
var sj = null;
var tj = 0;
var Dg = 0;
var Hi = 0;
var uj = 0;
var vj = null;
var jj = 0;
var Ji = Infinity;
function wj() {
  Ji = O() + 500;
}
var Z = null;
var Qi = false;
var Ri = null;
var Ti = null;
var xj = false;
var yj = null;
var zj = 90;
var Aj = [];
var Bj = [];
var Cj = null;
var Dj = 0;
var Ej = null;
var Fj = -1;
var Gj = 0;
var Hj = 0;
var Ij = null;
var Jj = false;
function Hg() {
  return (X & 48) !== 0 ? O() : Fj !== -1 ? Fj : Fj = O();
}
function Ig(a) {
  a = a.mode;
  if ((a & 2) === 0)
    return 1;
  if ((a & 4) === 0)
    return eg() === 99 ? 1 : 2;
  Gj === 0 && (Gj = tj);
  if (kg.transition !== 0) {
    Hj !== 0 && (Hj = vj !== null ? vj.pendingLanes : 0);
    a = Gj;
    var b2 = 4186112 & ~Hj;
    b2 &= -b2;
    b2 === 0 && (a = 4186112 & ~a, b2 = a & -a, b2 === 0 && (b2 = 8192));
    return b2;
  }
  a = eg();
  (X & 4) !== 0 && a === 98 ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));
  return a;
}
function Jg(a, b2, c2) {
  if (50 < Dj)
    throw Dj = 0, Ej = null, Error(y(185));
  a = Kj(a, b2);
  if (a === null)
    return null;
  $c(a, b2, c2);
  a === U && (Hi |= b2, V === 4 && Ii(a, W));
  var d2 = eg();
  b2 === 1 ? (X & 8) !== 0 && (X & 48) === 0 ? Lj(a) : (Mj(a, c2), X === 0 && (wj(), ig())) : ((X & 4) === 0 || d2 !== 98 && d2 !== 99 || (Cj === null ? Cj = new Set([a]) : Cj.add(a)), Mj(a, c2));
  vj = a;
}
function Kj(a, b2) {
  a.lanes |= b2;
  var c2 = a.alternate;
  c2 !== null && (c2.lanes |= b2);
  c2 = a;
  for (a = a.return; a !== null; )
    a.childLanes |= b2, c2 = a.alternate, c2 !== null && (c2.childLanes |= b2), c2 = a, a = a.return;
  return c2.tag === 3 ? c2.stateNode : null;
}
function Mj(a, b2) {
  for (var c2 = a.callbackNode, d2 = a.suspendedLanes, e2 = a.pingedLanes, f2 = a.expirationTimes, g2 = a.pendingLanes; 0 < g2; ) {
    var h2 = 31 - Vc(g2), k2 = 1 << h2, l2 = f2[h2];
    if (l2 === -1) {
      if ((k2 & d2) === 0 || (k2 & e2) !== 0) {
        l2 = b2;
        Rc(k2);
        var n2 = F;
        f2[h2] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
      }
    } else
      l2 <= b2 && (a.expiredLanes |= k2);
    g2 &= ~k2;
  }
  d2 = Uc(a, a === U ? W : 0);
  b2 = F;
  if (d2 === 0)
    c2 !== null && (c2 !== Zf && Pf(c2), a.callbackNode = null, a.callbackPriority = 0);
  else {
    if (c2 !== null) {
      if (a.callbackPriority === b2)
        return;
      c2 !== Zf && Pf(c2);
    }
    b2 === 15 ? (c2 = Lj.bind(null, a), ag === null ? (ag = [c2], bg = Of(Uf, jg)) : ag.push(c2), c2 = Zf) : b2 === 14 ? c2 = hg(99, Lj.bind(null, a)) : (c2 = Tc(b2), c2 = hg(c2, Nj.bind(null, a)));
    a.callbackPriority = b2;
    a.callbackNode = c2;
  }
}
function Nj(a) {
  Fj = -1;
  Hj = Gj = 0;
  if ((X & 48) !== 0)
    throw Error(y(327));
  var b2 = a.callbackNode;
  if (Oj() && a.callbackNode !== b2)
    return null;
  var c2 = Uc(a, a === U ? W : 0);
  if (c2 === 0)
    return null;
  var d2 = c2;
  var e2 = X;
  X |= 16;
  var f2 = Pj();
  if (U !== a || W !== d2)
    wj(), Qj(a, d2);
  do
    try {
      Rj();
      break;
    } catch (h2) {
      Sj(a, h2);
    }
  while (1);
  qg();
  oj.current = f2;
  X = e2;
  Y !== null ? d2 = 0 : (U = null, W = 0, d2 = V);
  if ((tj & Hi) !== 0)
    Qj(a, 0);
  else if (d2 !== 0) {
    d2 === 2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), c2 = Wc(a), c2 !== 0 && (d2 = Tj(a, c2)));
    if (d2 === 1)
      throw b2 = sj, Qj(a, 0), Ii(a, c2), Mj(a, O()), b2;
    a.finishedWork = a.current.alternate;
    a.finishedLanes = c2;
    switch (d2) {
      case 0:
      case 1:
        throw Error(y(345));
      case 2:
        Uj(a);
        break;
      case 3:
        Ii(a, c2);
        if ((c2 & 62914560) === c2 && (d2 = jj + 500 - O(), 10 < d2)) {
          if (Uc(a, 0) !== 0)
            break;
          e2 = a.suspendedLanes;
          if ((e2 & c2) !== c2) {
            Hg();
            a.pingedLanes |= a.suspendedLanes & e2;
            break;
          }
          a.timeoutHandle = of(Uj.bind(null, a), d2);
          break;
        }
        Uj(a);
        break;
      case 4:
        Ii(a, c2);
        if ((c2 & 4186112) === c2)
          break;
        d2 = a.eventTimes;
        for (e2 = -1; 0 < c2; ) {
          var g2 = 31 - Vc(c2);
          f2 = 1 << g2;
          g2 = d2[g2];
          g2 > e2 && (e2 = g2);
          c2 &= ~f2;
        }
        c2 = e2;
        c2 = O() - c2;
        c2 = (120 > c2 ? 120 : 480 > c2 ? 480 : 1080 > c2 ? 1080 : 1920 > c2 ? 1920 : 3e3 > c2 ? 3e3 : 4320 > c2 ? 4320 : 1960 * nj(c2 / 1960)) - c2;
        if (10 < c2) {
          a.timeoutHandle = of(Uj.bind(null, a), c2);
          break;
        }
        Uj(a);
        break;
      case 5:
        Uj(a);
        break;
      default:
        throw Error(y(329));
    }
  }
  Mj(a, O());
  return a.callbackNode === b2 ? Nj.bind(null, a) : null;
}
function Ii(a, b2) {
  b2 &= ~uj;
  b2 &= ~Hi;
  a.suspendedLanes |= b2;
  a.pingedLanes &= ~b2;
  for (a = a.expirationTimes; 0 < b2; ) {
    var c2 = 31 - Vc(b2), d2 = 1 << c2;
    a[c2] = -1;
    b2 &= ~d2;
  }
}
function Lj(a) {
  if ((X & 48) !== 0)
    throw Error(y(327));
  Oj();
  if (a === U && (a.expiredLanes & W) !== 0) {
    var b2 = W;
    var c2 = Tj(a, b2);
    (tj & Hi) !== 0 && (b2 = Uc(a, b2), c2 = Tj(a, b2));
  } else
    b2 = Uc(a, 0), c2 = Tj(a, b2);
  a.tag !== 0 && c2 === 2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), b2 = Wc(a), b2 !== 0 && (c2 = Tj(a, b2)));
  if (c2 === 1)
    throw c2 = sj, Qj(a, 0), Ii(a, b2), Mj(a, O()), c2;
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b2;
  Uj(a);
  Mj(a, O());
  return null;
}
function Vj() {
  if (Cj !== null) {
    var a = Cj;
    Cj = null;
    a.forEach(function(a2) {
      a2.expiredLanes |= 24 & a2.pendingLanes;
      Mj(a2, O());
    });
  }
  ig();
}
function Wj(a, b2) {
  var c2 = X;
  X |= 1;
  try {
    return a(b2);
  } finally {
    X = c2, X === 0 && (wj(), ig());
  }
}
function Xj(a, b2) {
  var c2 = X;
  X &= -2;
  X |= 8;
  try {
    return a(b2);
  } finally {
    X = c2, X === 0 && (wj(), ig());
  }
}
function ni(a, b2) {
  I(rj, qj);
  qj |= b2;
  tj |= b2;
}
function Ki() {
  qj = rj.current;
  H(rj);
}
function Qj(a, b2) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c2 = a.timeoutHandle;
  c2 !== -1 && (a.timeoutHandle = -1, pf(c2));
  if (Y !== null)
    for (c2 = Y.return; c2 !== null; ) {
      var d2 = c2;
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          d2 !== null && d2 !== void 0 && Gf();
          break;
        case 3:
          fh();
          H(N);
          H(M);
          uh();
          break;
        case 5:
          hh(d2);
          break;
        case 4:
          fh();
          break;
        case 13:
          H(P);
          break;
        case 19:
          H(P);
          break;
        case 10:
          rg(d2);
          break;
        case 23:
        case 24:
          Ki();
      }
      c2 = c2.return;
    }
  U = a;
  Y = Tg(a.current, null);
  W = qj = tj = b2;
  V = 0;
  sj = null;
  uj = Hi = Dg = 0;
}
function Sj(a, b2) {
  do {
    var c2 = Y;
    try {
      qg();
      vh.current = Gh;
      if (yh) {
        for (var d2 = R.memoizedState; d2 !== null; ) {
          var e2 = d2.queue;
          e2 !== null && (e2.pending = null);
          d2 = d2.next;
        }
        yh = false;
      }
      xh = 0;
      T = S = R = null;
      zh = false;
      pj.current = null;
      if (c2 === null || c2.return === null) {
        V = 1;
        sj = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = W;
        h2.flags |= 2048;
        h2.firstEffect = h2.lastEffect = null;
        if (k2 !== null && typeof k2 === "object" && typeof k2.then === "function") {
          var l2 = k2;
          if ((h2.mode & 2) === 0) {
            var n2 = h2.alternate;
            n2 ? (h2.updateQueue = n2.updateQueue, h2.memoizedState = n2.memoizedState, h2.lanes = n2.lanes) : (h2.updateQueue = null, h2.memoizedState = null);
          }
          var A2 = (P.current & 1) !== 0, p2 = g2;
          do {
            var C;
            if (C = p2.tag === 13) {
              var x2 = p2.memoizedState;
              if (x2 !== null)
                C = x2.dehydrated !== null ? true : false;
              else {
                var w2 = p2.memoizedProps;
                C = w2.fallback === void 0 ? false : w2.unstable_avoidThisFallback !== true ? true : A2 ? false : true;
              }
            }
            if (C) {
              var z2 = p2.updateQueue;
              if (z2 === null) {
                var u = new Set();
                u.add(l2);
                p2.updateQueue = u;
              } else
                z2.add(l2);
              if ((p2.mode & 2) === 0) {
                p2.flags |= 64;
                h2.flags |= 16384;
                h2.flags &= -2981;
                if (h2.tag === 1)
                  if (h2.alternate === null)
                    h2.tag = 17;
                  else {
                    var t2 = zg(-1, 1);
                    t2.tag = 2;
                    Ag(h2, t2);
                  }
                h2.lanes |= 1;
                break a;
              }
              k2 = void 0;
              h2 = b2;
              var q2 = f2.pingCache;
              q2 === null ? (q2 = f2.pingCache = new Oi(), k2 = new Set(), q2.set(l2, k2)) : (k2 = q2.get(l2), k2 === void 0 && (k2 = new Set(), q2.set(l2, k2)));
              if (!k2.has(h2)) {
                k2.add(h2);
                var v2 = Yj.bind(null, f2, l2, h2);
                l2.then(v2, v2);
              }
              p2.flags |= 4096;
              p2.lanes = b2;
              break a;
            }
            p2 = p2.return;
          } while (p2 !== null);
          k2 = Error((Ra(h2.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
        }
        V !== 5 && (V = 2);
        k2 = Mi(k2, h2);
        p2 = g2;
        do {
          switch (p2.tag) {
            case 3:
              f2 = k2;
              p2.flags |= 4096;
              b2 &= -b2;
              p2.lanes |= b2;
              var J = Pi(p2, f2, b2);
              Bg(p2, J);
              break a;
            case 1:
              f2 = k2;
              var K = p2.type, Q = p2.stateNode;
              if ((p2.flags & 64) === 0 && (typeof K.getDerivedStateFromError === "function" || Q !== null && typeof Q.componentDidCatch === "function" && (Ti === null || !Ti.has(Q)))) {
                p2.flags |= 4096;
                b2 &= -b2;
                p2.lanes |= b2;
                var L = Si(p2, f2, b2);
                Bg(p2, L);
                break a;
              }
          }
          p2 = p2.return;
        } while (p2 !== null);
      }
      Zj(c2);
    } catch (va) {
      b2 = va;
      Y === c2 && c2 !== null && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Pj() {
  var a = oj.current;
  oj.current = Gh;
  return a === null ? Gh : a;
}
function Tj(a, b2) {
  var c2 = X;
  X |= 16;
  var d2 = Pj();
  U === a && W === b2 || Qj(a, b2);
  do
    try {
      ak();
      break;
    } catch (e2) {
      Sj(a, e2);
    }
  while (1);
  qg();
  X = c2;
  oj.current = d2;
  if (Y !== null)
    throw Error(y(261));
  U = null;
  W = 0;
  return V;
}
function ak() {
  for (; Y !== null; )
    bk(Y);
}
function Rj() {
  for (; Y !== null && !Qf(); )
    bk(Y);
}
function bk(a) {
  var b2 = ck(a.alternate, a, qj);
  a.memoizedProps = a.pendingProps;
  b2 === null ? Zj(a) : Y = b2;
  pj.current = null;
}
function Zj(a) {
  var b2 = a;
  do {
    var c2 = b2.alternate;
    a = b2.return;
    if ((b2.flags & 2048) === 0) {
      c2 = Gi(c2, b2, qj);
      if (c2 !== null) {
        Y = c2;
        return;
      }
      c2 = b2;
      if (c2.tag !== 24 && c2.tag !== 23 || c2.memoizedState === null || (qj & 1073741824) !== 0 || (c2.mode & 4) === 0) {
        for (var d2 = 0, e2 = c2.child; e2 !== null; )
          d2 |= e2.lanes | e2.childLanes, e2 = e2.sibling;
        c2.childLanes = d2;
      }
      a !== null && (a.flags & 2048) === 0 && (a.firstEffect === null && (a.firstEffect = b2.firstEffect), b2.lastEffect !== null && (a.lastEffect !== null && (a.lastEffect.nextEffect = b2.firstEffect), a.lastEffect = b2.lastEffect), 1 < b2.flags && (a.lastEffect !== null ? a.lastEffect.nextEffect = b2 : a.firstEffect = b2, a.lastEffect = b2));
    } else {
      c2 = Li(b2);
      if (c2 !== null) {
        c2.flags &= 2047;
        Y = c2;
        return;
      }
      a !== null && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
    }
    b2 = b2.sibling;
    if (b2 !== null) {
      Y = b2;
      return;
    }
    Y = b2 = a;
  } while (b2 !== null);
  V === 0 && (V = 5);
}
function Uj(a) {
  var b2 = eg();
  gg(99, dk.bind(null, a, b2));
  return null;
}
function dk(a, b2) {
  do
    Oj();
  while (yj !== null);
  if ((X & 48) !== 0)
    throw Error(y(327));
  var c2 = a.finishedWork;
  if (c2 === null)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c2 === a.current)
    throw Error(y(177));
  a.callbackNode = null;
  var d2 = c2.lanes | c2.childLanes, e2 = d2, f2 = a.pendingLanes & ~e2;
  a.pendingLanes = e2;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= e2;
  a.mutableReadLanes &= e2;
  a.entangledLanes &= e2;
  e2 = a.entanglements;
  for (var g2 = a.eventTimes, h2 = a.expirationTimes; 0 < f2; ) {
    var k2 = 31 - Vc(f2), l2 = 1 << k2;
    e2[k2] = 0;
    g2[k2] = -1;
    h2[k2] = -1;
    f2 &= ~l2;
  }
  Cj !== null && (d2 & 24) === 0 && Cj.has(a) && Cj.delete(a);
  a === U && (Y = U = null, W = 0);
  1 < c2.flags ? c2.lastEffect !== null ? (c2.lastEffect.nextEffect = c2, d2 = c2.firstEffect) : d2 = c2 : d2 = c2.firstEffect;
  if (d2 !== null) {
    e2 = X;
    X |= 32;
    pj.current = null;
    kf = fd;
    g2 = Ne();
    if (Oe(g2)) {
      if ("selectionStart" in g2)
        h2 = {start: g2.selectionStart, end: g2.selectionEnd};
      else
        a:
          if (h2 = (h2 = g2.ownerDocument) && h2.defaultView || window, (l2 = h2.getSelection && h2.getSelection()) && l2.rangeCount !== 0) {
            h2 = l2.anchorNode;
            f2 = l2.anchorOffset;
            k2 = l2.focusNode;
            l2 = l2.focusOffset;
            try {
              h2.nodeType, k2.nodeType;
            } catch (va) {
              h2 = null;
              break a;
            }
            var n2 = 0, A2 = -1, p2 = -1, C = 0, x2 = 0, w2 = g2, z2 = null;
            b:
              for (; ; ) {
                for (var u; ; ) {
                  w2 !== h2 || f2 !== 0 && w2.nodeType !== 3 || (A2 = n2 + f2);
                  w2 !== k2 || l2 !== 0 && w2.nodeType !== 3 || (p2 = n2 + l2);
                  w2.nodeType === 3 && (n2 += w2.nodeValue.length);
                  if ((u = w2.firstChild) === null)
                    break;
                  z2 = w2;
                  w2 = u;
                }
                for (; ; ) {
                  if (w2 === g2)
                    break b;
                  z2 === h2 && ++C === f2 && (A2 = n2);
                  z2 === k2 && ++x2 === l2 && (p2 = n2);
                  if ((u = w2.nextSibling) !== null)
                    break;
                  w2 = z2;
                  z2 = w2.parentNode;
                }
                w2 = u;
              }
            h2 = A2 === -1 || p2 === -1 ? null : {start: A2, end: p2};
          } else
            h2 = null;
      h2 = h2 || {start: 0, end: 0};
    } else
      h2 = null;
    lf = {focusedElem: g2, selectionRange: h2};
    fd = false;
    Ij = null;
    Jj = false;
    Z = d2;
    do
      try {
        ek();
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    Ij = null;
    Z = d2;
    do
      try {
        for (g2 = a; Z !== null; ) {
          var t2 = Z.flags;
          t2 & 16 && pb(Z.stateNode, "");
          if (t2 & 128) {
            var q2 = Z.alternate;
            if (q2 !== null) {
              var v2 = q2.ref;
              v2 !== null && (typeof v2 === "function" ? v2(null) : v2.current = null);
            }
          }
          switch (t2 & 1038) {
            case 2:
              fj(Z);
              Z.flags &= -3;
              break;
            case 6:
              fj(Z);
              Z.flags &= -3;
              ij(Z.alternate, Z);
              break;
            case 1024:
              Z.flags &= -1025;
              break;
            case 1028:
              Z.flags &= -1025;
              ij(Z.alternate, Z);
              break;
            case 4:
              ij(Z.alternate, Z);
              break;
            case 8:
              h2 = Z;
              cj(g2, h2);
              var J = h2.alternate;
              dj(h2);
              J !== null && dj(J);
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    v2 = lf;
    q2 = Ne();
    t2 = v2.focusedElem;
    g2 = v2.selectionRange;
    if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {
      g2 !== null && Oe(t2) && (q2 = g2.start, v2 = g2.end, v2 === void 0 && (v2 = q2), "selectionStart" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h2 = t2.textContent.length, J = Math.min(g2.start, h2), g2 = g2.end === void 0 ? J : Math.min(g2.end, h2), !v2.extend && J > g2 && (h2 = g2, g2 = J, J = h2), h2 = Le(t2, J), f2 = Le(t2, g2), h2 && f2 && (v2.rangeCount !== 1 || v2.anchorNode !== h2.node || v2.anchorOffset !== h2.offset || v2.focusNode !== f2.node || v2.focusOffset !== f2.offset) && (q2 = q2.createRange(), q2.setStart(h2.node, h2.offset), v2.removeAllRanges(), J > g2 ? (v2.addRange(q2), v2.extend(f2.node, f2.offset)) : (q2.setEnd(f2.node, f2.offset), v2.addRange(q2))))));
      q2 = [];
      for (v2 = t2; v2 = v2.parentNode; )
        v2.nodeType === 1 && q2.push({element: v2, left: v2.scrollLeft, top: v2.scrollTop});
      typeof t2.focus === "function" && t2.focus();
      for (t2 = 0; t2 < q2.length; t2++)
        v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;
    }
    fd = !!kf;
    lf = kf = null;
    a.current = c2;
    Z = d2;
    do
      try {
        for (t2 = a; Z !== null; ) {
          var K = Z.flags;
          K & 36 && Yi(t2, Z.alternate, Z);
          if (K & 128) {
            q2 = void 0;
            var Q = Z.ref;
            if (Q !== null) {
              var L = Z.stateNode;
              switch (Z.tag) {
                case 5:
                  q2 = L;
                  break;
                default:
                  q2 = L;
              }
              typeof Q === "function" ? Q(q2) : Q.current = q2;
            }
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    Z = null;
    $f();
    X = e2;
  } else
    a.current = c2;
  if (xj)
    xj = false, yj = a, zj = b2;
  else
    for (Z = d2; Z !== null; )
      b2 = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K = Z, K.sibling = null, K.stateNode = null), Z = b2;
  d2 = a.pendingLanes;
  d2 === 0 && (Ti = null);
  d2 === 1 ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
  c2 = c2.stateNode;
  if (Mf && typeof Mf.onCommitFiberRoot === "function")
    try {
      Mf.onCommitFiberRoot(Lf, c2, void 0, (c2.current.flags & 64) === 64);
    } catch (va) {
    }
  Mj(a, O());
  if (Qi)
    throw Qi = false, a = Ri, Ri = null, a;
  if ((X & 8) !== 0)
    return null;
  ig();
  return null;
}
function ek() {
  for (; Z !== null; ) {
    var a = Z.alternate;
    Jj || Ij === null || ((Z.flags & 8) !== 0 ? dc(Z, Ij) && (Jj = true) : Z.tag === 13 && mj(a, Z) && dc(Z, Ij) && (Jj = true));
    var b2 = Z.flags;
    (b2 & 256) !== 0 && Xi(a, Z);
    (b2 & 512) === 0 || xj || (xj = true, hg(97, function() {
      Oj();
      return null;
    }));
    Z = Z.nextEffect;
  }
}
function Oj() {
  if (zj !== 90) {
    var a = 97 < zj ? 97 : zj;
    zj = 90;
    return gg(a, fk);
  }
  return false;
}
function $i(a, b2) {
  Aj.push(b2, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function Zi(a, b2) {
  Bj.push(b2, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function fk() {
  if (yj === null)
    return false;
  var a = yj;
  yj = null;
  if ((X & 48) !== 0)
    throw Error(y(331));
  var b2 = X;
  X |= 32;
  var c2 = Bj;
  Bj = [];
  for (var d2 = 0; d2 < c2.length; d2 += 2) {
    var e2 = c2[d2], f2 = c2[d2 + 1], g2 = e2.destroy;
    e2.destroy = void 0;
    if (typeof g2 === "function")
      try {
        g2();
      } catch (k2) {
        if (f2 === null)
          throw Error(y(330));
        Wi(f2, k2);
      }
  }
  c2 = Aj;
  Aj = [];
  for (d2 = 0; d2 < c2.length; d2 += 2) {
    e2 = c2[d2];
    f2 = c2[d2 + 1];
    try {
      var h2 = e2.create;
      e2.destroy = h2();
    } catch (k2) {
      if (f2 === null)
        throw Error(y(330));
      Wi(f2, k2);
    }
  }
  for (h2 = a.current.firstEffect; h2 !== null; )
    a = h2.nextEffect, h2.nextEffect = null, h2.flags & 8 && (h2.sibling = null, h2.stateNode = null), h2 = a;
  X = b2;
  ig();
  return true;
}
function gk(a, b2, c2) {
  b2 = Mi(c2, b2);
  b2 = Pi(a, b2, 1);
  Ag(a, b2);
  b2 = Hg();
  a = Kj(a, 1);
  a !== null && ($c(a, 1, b2), Mj(a, b2));
}
function Wi(a, b2) {
  if (a.tag === 3)
    gk(a, a, b2);
  else
    for (var c2 = a.return; c2 !== null; ) {
      if (c2.tag === 3) {
        gk(c2, a, b2);
        break;
      } else if (c2.tag === 1) {
        var d2 = c2.stateNode;
        if (typeof c2.type.getDerivedStateFromError === "function" || typeof d2.componentDidCatch === "function" && (Ti === null || !Ti.has(d2))) {
          a = Mi(b2, a);
          var e2 = Si(c2, a, 1);
          Ag(c2, e2);
          e2 = Hg();
          c2 = Kj(c2, 1);
          if (c2 !== null)
            $c(c2, 1, e2), Mj(c2, e2);
          else if (typeof d2.componentDidCatch === "function" && (Ti === null || !Ti.has(d2)))
            try {
              d2.componentDidCatch(b2, a);
            } catch (f2) {
            }
          break;
        }
      }
      c2 = c2.return;
    }
}
function Yj(a, b2, c2) {
  var d2 = a.pingCache;
  d2 !== null && d2.delete(b2);
  b2 = Hg();
  a.pingedLanes |= a.suspendedLanes & c2;
  U === a && (W & c2) === c2 && (V === 4 || V === 3 && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c2);
  Mj(a, b2);
}
function lj(a, b2) {
  var c2 = a.stateNode;
  c2 !== null && c2.delete(b2);
  b2 = 0;
  b2 === 0 && (b2 = a.mode, (b2 & 2) === 0 ? b2 = 1 : (b2 & 4) === 0 ? b2 = eg() === 99 ? 1 : 2 : (Gj === 0 && (Gj = tj), b2 = Yc(62914560 & ~Gj), b2 === 0 && (b2 = 4194304)));
  c2 = Hg();
  a = Kj(a, b2);
  a !== null && ($c(a, b2, c2), Mj(a, c2));
}
var ck;
ck = function(a, b2, c2) {
  var d2 = b2.lanes;
  if (a !== null)
    if (a.memoizedProps !== b2.pendingProps || N.current)
      ug = true;
    else if ((c2 & d2) !== 0)
      ug = (a.flags & 16384) !== 0 ? true : false;
    else {
      ug = false;
      switch (b2.tag) {
        case 3:
          ri(b2);
          sh();
          break;
        case 5:
          gh(b2);
          break;
        case 1:
          Ff(b2.type) && Jf(b2);
          break;
        case 4:
          eh(b2, b2.stateNode.containerInfo);
          break;
        case 10:
          d2 = b2.memoizedProps.value;
          var e2 = b2.type._context;
          I(mg, e2._currentValue);
          e2._currentValue = d2;
          break;
        case 13:
          if (b2.memoizedState !== null) {
            if ((c2 & b2.child.childLanes) !== 0)
              return ti(a, b2, c2);
            I(P, P.current & 1);
            b2 = hi(a, b2, c2);
            return b2 !== null ? b2.sibling : null;
          }
          I(P, P.current & 1);
          break;
        case 19:
          d2 = (c2 & b2.childLanes) !== 0;
          if ((a.flags & 64) !== 0) {
            if (d2)
              return Ai(a, b2, c2);
            b2.flags |= 64;
          }
          e2 = b2.memoizedState;
          e2 !== null && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
          I(P, P.current);
          if (d2)
            break;
          else
            return null;
        case 23:
        case 24:
          return b2.lanes = 0, mi(a, b2, c2);
      }
      return hi(a, b2, c2);
    }
  else
    ug = false;
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      d2 = b2.type;
      a !== null && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
      a = b2.pendingProps;
      e2 = Ef(b2, M.current);
      tg(b2, c2);
      e2 = Ch(null, b2, d2, a, e2, c2);
      b2.flags |= 1;
      if (typeof e2 === "object" && e2 !== null && typeof e2.render === "function" && e2.$$typeof === void 0) {
        b2.tag = 1;
        b2.memoizedState = null;
        b2.updateQueue = null;
        if (Ff(d2)) {
          var f2 = true;
          Jf(b2);
        } else
          f2 = false;
        b2.memoizedState = e2.state !== null && e2.state !== void 0 ? e2.state : null;
        xg(b2);
        var g2 = d2.getDerivedStateFromProps;
        typeof g2 === "function" && Gg(b2, d2, g2, a);
        e2.updater = Kg;
        b2.stateNode = e2;
        e2._reactInternals = b2;
        Og(b2, d2, a, c2);
        b2 = qi(null, b2, d2, true, f2, c2);
      } else
        b2.tag = 0, fi(null, b2, e2, c2), b2 = b2.child;
      return b2;
    case 16:
      e2 = b2.elementType;
      a: {
        a !== null && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
        a = b2.pendingProps;
        f2 = e2._init;
        e2 = f2(e2._payload);
        b2.type = e2;
        f2 = b2.tag = hk(e2);
        a = lg(e2, a);
        switch (f2) {
          case 0:
            b2 = li(null, b2, e2, a, c2);
            break a;
          case 1:
            b2 = pi(null, b2, e2, a, c2);
            break a;
          case 11:
            b2 = gi(null, b2, e2, a, c2);
            break a;
          case 14:
            b2 = ii(null, b2, e2, lg(e2.type, a), d2, c2);
            break a;
        }
        throw Error(y(306, e2, ""));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), li(a, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), pi(a, b2, d2, e2, c2);
    case 3:
      ri(b2);
      d2 = b2.updateQueue;
      if (a === null || d2 === null)
        throw Error(y(282));
      d2 = b2.pendingProps;
      e2 = b2.memoizedState;
      e2 = e2 !== null ? e2.element : null;
      yg(a, b2);
      Cg(b2, d2, null, c2);
      d2 = b2.memoizedState.element;
      if (d2 === e2)
        sh(), b2 = hi(a, b2, c2);
      else {
        e2 = b2.stateNode;
        if (f2 = e2.hydrate)
          kh = rf(b2.stateNode.containerInfo.firstChild), jh = b2, f2 = lh = true;
        if (f2) {
          a = e2.mutableSourceEagerHydrationData;
          if (a != null)
            for (e2 = 0; e2 < a.length; e2 += 2)
              f2 = a[e2], f2._workInProgressVersionPrimary = a[e2 + 1], th.push(f2);
          c2 = Zg(b2, null, d2, c2);
          for (b2.child = c2; c2; )
            c2.flags = c2.flags & -3 | 1024, c2 = c2.sibling;
        } else
          fi(a, b2, d2, c2), sh();
        b2 = b2.child;
      }
      return b2;
    case 5:
      return gh(b2), a === null && ph(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = a !== null ? a.memoizedProps : null, g2 = e2.children, nf(d2, e2) ? g2 = null : f2 !== null && nf(d2, f2) && (b2.flags |= 16), oi(a, b2), fi(a, b2, g2, c2), b2.child;
    case 6:
      return a === null && ph(b2), null;
    case 13:
      return ti(a, b2, c2);
    case 4:
      return eh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, a === null ? b2.child = Yg(b2, null, d2, c2) : fi(a, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), gi(a, b2, d2, e2, c2);
    case 7:
      return fi(a, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return fi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return fi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        g2 = b2.memoizedProps;
        f2 = e2.value;
        var h2 = b2.type._context;
        I(mg, h2._currentValue);
        h2._currentValue = f2;
        if (g2 !== null)
          if (h2 = g2.value, f2 = He(h2, f2) ? 0 : (typeof d2._calculateChangedBits === "function" ? d2._calculateChangedBits(h2, f2) : 1073741823) | 0, f2 === 0) {
            if (g2.children === e2.children && !N.current) {
              b2 = hi(a, b2, c2);
              break a;
            }
          } else
            for (h2 = b2.child, h2 !== null && (h2.return = b2); h2 !== null; ) {
              var k2 = h2.dependencies;
              if (k2 !== null) {
                g2 = h2.child;
                for (var l2 = k2.firstContext; l2 !== null; ) {
                  if (l2.context === d2 && (l2.observedBits & f2) !== 0) {
                    h2.tag === 1 && (l2 = zg(-1, c2 & -c2), l2.tag = 2, Ag(h2, l2));
                    h2.lanes |= c2;
                    l2 = h2.alternate;
                    l2 !== null && (l2.lanes |= c2);
                    sg(h2.return, c2);
                    k2.lanes |= c2;
                    break;
                  }
                  l2 = l2.next;
                }
              } else
                g2 = h2.tag === 10 ? h2.type === b2.type ? null : h2.child : h2.child;
              if (g2 !== null)
                g2.return = h2;
              else
                for (g2 = h2; g2 !== null; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  h2 = g2.sibling;
                  if (h2 !== null) {
                    h2.return = g2.return;
                    g2 = h2;
                    break;
                  }
                  g2 = g2.return;
                }
              h2 = g2;
            }
        fi(a, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, f2 = b2.pendingProps, d2 = f2.children, tg(b2, c2), e2 = vg(e2, f2.unstable_observedBits), d2 = d2(e2), b2.flags |= 1, fi(a, b2, d2, c2), b2.child;
    case 14:
      return e2 = b2.type, f2 = lg(e2, b2.pendingProps), f2 = lg(e2.type, f2), ii(a, b2, e2, f2, d2, c2);
    case 15:
      return ki(a, b2, b2.type, b2.pendingProps, d2, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), a !== null && (a.alternate = null, b2.alternate = null, b2.flags |= 2), b2.tag = 1, Ff(d2) ? (a = true, Jf(b2)) : a = false, tg(b2, c2), Mg(b2, d2, e2), Og(b2, d2, e2, c2), qi(null, b2, d2, true, a, c2);
    case 19:
      return Ai(a, b2, c2);
    case 23:
      return mi(a, b2, c2);
    case 24:
      return mi(a, b2, c2);
  }
  throw Error(y(156, b2.tag));
};
function ik(a, b2, c2, d2) {
  this.tag = a;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.flags = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function nh(a, b2, c2, d2) {
  return new ik(a, b2, c2, d2);
}
function ji(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function hk(a) {
  if (typeof a === "function")
    return ji(a) ? 1 : 0;
  if (a !== void 0 && a !== null) {
    a = a.$$typeof;
    if (a === Aa)
      return 11;
    if (a === Da)
      return 14;
  }
  return 2;
}
function Tg(a, b2) {
  var c2 = a.alternate;
  c2 === null ? (c2 = nh(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.nextEffect = null, c2.firstEffect = null, c2.lastEffect = null);
  c2.childLanes = a.childLanes;
  c2.lanes = a.lanes;
  c2.child = a.child;
  c2.memoizedProps = a.memoizedProps;
  c2.memoizedState = a.memoizedState;
  c2.updateQueue = a.updateQueue;
  b2 = a.dependencies;
  c2.dependencies = b2 === null ? null : {lanes: b2.lanes, firstContext: b2.firstContext};
  c2.sibling = a.sibling;
  c2.index = a.index;
  c2.ref = a.ref;
  return c2;
}
function Vg(a, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a;
  if (typeof a === "function")
    ji(a) && (g2 = 1);
  else if (typeof a === "string")
    g2 = 5;
  else
    a:
      switch (a) {
        case ua:
          return Xg(c2.children, e2, f2, b2);
        case Ha:
          g2 = 8;
          e2 |= 16;
          break;
        case wa:
          g2 = 8;
          e2 |= 1;
          break;
        case xa:
          return a = nh(12, c2, b2, e2 | 8), a.elementType = xa, a.type = xa, a.lanes = f2, a;
        case Ba:
          return a = nh(13, c2, b2, e2), a.type = Ba, a.elementType = Ba, a.lanes = f2, a;
        case Ca:
          return a = nh(19, c2, b2, e2), a.elementType = Ca, a.lanes = f2, a;
        case Ia:
          return vi(c2, e2, f2, b2);
        case Ja:
          return a = nh(24, c2, b2, e2), a.elementType = Ja, a.lanes = f2, a;
        default:
          if (typeof a === "object" && a !== null)
            switch (a.$$typeof) {
              case ya:
                g2 = 10;
                break a;
              case za:
                g2 = 9;
                break a;
              case Aa:
                g2 = 11;
                break a;
              case Da:
                g2 = 14;
                break a;
              case Ea:
                g2 = 16;
                d2 = null;
                break a;
              case Fa:
                g2 = 22;
                break a;
            }
          throw Error(y(130, a == null ? a : typeof a, ""));
      }
  b2 = nh(g2, c2, b2, e2);
  b2.elementType = a;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Xg(a, b2, c2, d2) {
  a = nh(7, a, d2, b2);
  a.lanes = c2;
  return a;
}
function vi(a, b2, c2, d2) {
  a = nh(23, a, d2, b2);
  a.elementType = Ia;
  a.lanes = c2;
  return a;
}
function Ug(a, b2, c2) {
  a = nh(6, a, null, b2);
  a.lanes = c2;
  return a;
}
function Wg(a, b2, c2) {
  b2 = nh(4, a.children !== null ? a.children : [], a.key, b2);
  b2.lanes = c2;
  b2.stateNode = {containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation};
  return b2;
}
function jk(a, b2, c2) {
  this.tag = b2;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.pendingContext = this.context = null;
  this.hydrate = c2;
  this.callbackNode = null;
  this.callbackPriority = 0;
  this.eventTimes = Zc(0);
  this.expirationTimes = Zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = Zc(0);
  this.mutableSourceEagerHydrationData = null;
}
function kk(a, b2, c2) {
  var d2 = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {$$typeof: ta, key: d2 == null ? null : "" + d2, children: a, containerInfo: b2, implementation: c2};
}
function lk(a, b2, c2, d2) {
  var e2 = b2.current, f2 = Hg(), g2 = Ig(e2);
  a:
    if (c2) {
      c2 = c2._reactInternals;
      b: {
        if (Zb(c2) !== c2 || c2.tag !== 1)
          throw Error(y(170));
        var h2 = c2;
        do {
          switch (h2.tag) {
            case 3:
              h2 = h2.stateNode.context;
              break b;
            case 1:
              if (Ff(h2.type)) {
                h2 = h2.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }
          }
          h2 = h2.return;
        } while (h2 !== null);
        throw Error(y(171));
      }
      if (c2.tag === 1) {
        var k2 = c2.type;
        if (Ff(k2)) {
          c2 = If(c2, k2, h2);
          break a;
        }
      }
      c2 = h2;
    } else
      c2 = Cf;
  b2.context === null ? b2.context = c2 : b2.pendingContext = c2;
  b2 = zg(f2, g2);
  b2.payload = {element: a};
  d2 = d2 === void 0 ? null : d2;
  d2 !== null && (b2.callback = d2);
  Ag(e2, b2);
  Jg(e2, g2, f2);
  return g2;
}
function mk(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function nk(a, b2) {
  a = a.memoizedState;
  if (a !== null && a.dehydrated !== null) {
    var c2 = a.retryLane;
    a.retryLane = c2 !== 0 && c2 < b2 ? c2 : b2;
  }
}
function ok(a, b2) {
  nk(a, b2);
  (a = a.alternate) && nk(a, b2);
}
function pk() {
  return null;
}
function qk(a, b2, c2) {
  var d2 = c2 != null && c2.hydrationOptions != null && c2.hydrationOptions.mutableSources || null;
  c2 = new jk(a, b2, c2 != null && c2.hydrate === true);
  b2 = nh(3, null, null, b2 === 2 ? 7 : b2 === 1 ? 3 : 0);
  c2.current = b2;
  b2.stateNode = c2;
  xg(b2);
  a[ff] = c2.current;
  cf(a.nodeType === 8 ? a.parentNode : a);
  if (d2)
    for (a = 0; a < d2.length; a++) {
      b2 = d2[a];
      var e2 = b2._getVersion;
      e2 = e2(b2._source);
      c2.mutableSourceEagerHydrationData == null ? c2.mutableSourceEagerHydrationData = [b2, e2] : c2.mutableSourceEagerHydrationData.push(b2, e2);
    }
  this._internalRoot = c2;
}
qk.prototype.render = function(a) {
  lk(a, this._internalRoot, null, null);
};
qk.prototype.unmount = function() {
  var a = this._internalRoot, b2 = a.containerInfo;
  lk(null, a, null, function() {
    b2[ff] = null;
  });
};
function rk(a) {
  return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "));
}
function sk(a, b2) {
  b2 || (b2 = a ? a.nodeType === 9 ? a.documentElement : a.firstChild : null, b2 = !(!b2 || b2.nodeType !== 1 || !b2.hasAttribute("data-reactroot")));
  if (!b2)
    for (var c2; c2 = a.lastChild; )
      a.removeChild(c2);
  return new qk(a, 0, b2 ? {hydrate: true} : void 0);
}
function tk(a, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2._internalRoot;
    if (typeof e2 === "function") {
      var h2 = e2;
      e2 = function() {
        var a2 = mk(g2);
        h2.call(a2);
      };
    }
    lk(b2, g2, a, e2);
  } else {
    f2 = c2._reactRootContainer = sk(c2, d2);
    g2 = f2._internalRoot;
    if (typeof e2 === "function") {
      var k2 = e2;
      e2 = function() {
        var a2 = mk(g2);
        k2.call(a2);
      };
    }
    Xj(function() {
      lk(b2, g2, a, e2);
    });
  }
  return mk(g2);
}
ec = function(a) {
  if (a.tag === 13) {
    var b2 = Hg();
    Jg(a, 4, b2);
    ok(a, 4);
  }
};
fc = function(a) {
  if (a.tag === 13) {
    var b2 = Hg();
    Jg(a, 67108864, b2);
    ok(a, 67108864);
  }
};
gc = function(a) {
  if (a.tag === 13) {
    var b2 = Hg(), c2 = Ig(a);
    Jg(a, c2, b2);
    ok(a, c2);
  }
};
hc = function(a, b2) {
  return b2();
};
yb = function(a, b2, c2) {
  switch (b2) {
    case "input":
      ab(a, c2);
      b2 = c2.name;
      if (c2.type === "radio" && b2 != null) {
        for (c2 = a; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a && d2.form === a.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(y(90));
            Wa(d2);
            ab(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c2);
      break;
    case "select":
      b2 = c2.value, b2 != null && fb(a, !!c2.multiple, b2, false);
  }
};
Gb = Wj;
Hb = function(a, b2, c2, d2, e2) {
  var f2 = X;
  X |= 4;
  try {
    return gg(98, a.bind(null, b2, c2, d2, e2));
  } finally {
    X = f2, X === 0 && (wj(), ig());
  }
};
Ib = function() {
  (X & 49) === 0 && (Vj(), Oj());
};
Jb = function(a, b2) {
  var c2 = X;
  X |= 2;
  try {
    return a(b2);
  } finally {
    X = c2, X === 0 && (wj(), ig());
  }
};
function uk(a, b2) {
  var c2 = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!rk(b2))
    throw Error(y(200));
  return kk(a, b2, null, c2);
}
var vk = {Events: [Cb, ue, Db, Eb, Fb, Oj, {current: false}]};
var wk = {findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom"};
var xk = {bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = cc(a);
  return a === null ? null : a.stateNode;
}, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined") {
  yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!yk.isDisabled && yk.supportsFiber)
    try {
      Lf = yk.inject(xk), Mf = yk;
    } catch (a) {
    }
}
var yk;
var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
var createPortal = uk;
var findDOMNode = function(a) {
  if (a == null)
    return null;
  if (a.nodeType === 1)
    return a;
  var b2 = a._reactInternals;
  if (b2 === void 0) {
    if (typeof a.render === "function")
      throw Error(y(188));
    throw Error(y(268, Object.keys(a)));
  }
  a = cc(b2);
  a = a === null ? null : a.stateNode;
  return a;
};
var flushSync = function(a, b2) {
  var c2 = X;
  if ((c2 & 48) !== 0)
    return a(b2);
  X |= 1;
  try {
    if (a)
      return gg(99, a.bind(null, b2));
  } finally {
    X = c2, ig();
  }
};
var hydrate = function(a, b2, c2) {
  if (!rk(b2))
    throw Error(y(200));
  return tk(null, a, b2, true, c2);
};
var render = function(a, b2, c2) {
  if (!rk(b2))
    throw Error(y(200));
  return tk(null, a, b2, false, c2);
};
var unmountComponentAtNode = function(a) {
  if (!rk(a))
    throw Error(y(40));
  return a._reactRootContainer ? (Xj(function() {
    tk(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[ff] = null;
    });
  }), true) : false;
};
var unstable_batchedUpdates = Wj;
var unstable_createPortal = function(a, b2) {
  return uk(a, b2, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null);
};
var unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
  if (!rk(c2))
    throw Error(y(200));
  if (a == null || a._reactInternals === void 0)
    throw Error(y(38));
  return tk(a, b2, c2, false, d2);
};
var version = "17.0.2";
var reactDom_production_min = {
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  createPortal,
  findDOMNode,
  flushSync,
  hydrate,
  render,
  unmountComponentAtNode,
  unstable_batchedUpdates,
  unstable_createPortal,
  unstable_renderSubtreeIntoContainer,
  version
};
var reactDom = createCommonjsModule(function(module) {
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    module.exports = reactDom_production_min;
  }
});
var react_dom_default = reactDom;

// build/dist/pkg/common/index-ce016b4a.js
var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret_1) {
      return;
    }
    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
var propTypes = createCommonjsModule(function(module) {
  {
    module.exports = factoryWithThrowingShims();
  }
});

// build/dist/pkg/react-router-dom.js
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function isAbsolute(pathname) {
  return pathname.charAt(0) === "/";
}
function spliceOne(list, index2) {
  for (var i = index2, k2 = i + 1, n2 = list.length; k2 < n2; i += 1, k2 += 1) {
    list[i] = list[k2];
  }
  list.pop();
}
function resolvePathname(to, from) {
  if (from === void 0)
    from = "";
  var toParts = to && to.split("/") || [];
  var fromParts = from && from.split("/") || [];
  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;
  if (to && isAbsolute(to)) {
    fromParts = toParts;
  } else if (toParts.length) {
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }
  if (!fromParts.length)
    return "/";
  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === "." || last === ".." || last === "";
  } else {
    hasTrailingSlash = false;
  }
  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];
    if (part === ".") {
      spliceOne(fromParts, i);
    } else if (part === "..") {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }
  if (!mustEndAbs)
    for (; up--; up)
      fromParts.unshift("..");
  if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0])))
    fromParts.unshift("");
  var result = fromParts.join("/");
  if (hasTrailingSlash && result.substr(-1) !== "/")
    result += "/";
  return result;
}
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  {
    throw new Error(prefix);
  }
}
function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}
function stripLeadingSlash(path) {
  return path.charAt(0) === "/" ? path.substr(1) : path;
}
function hasBasename(path, prefix2) {
  return path.toLowerCase().indexOf(prefix2.toLowerCase()) === 0 && "/?#".indexOf(path.charAt(prefix2.length)) !== -1;
}
function stripBasename(path, prefix2) {
  return hasBasename(path, prefix2) ? path.substr(prefix2.length) : path;
}
function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === "/" ? path.slice(0, -1) : path;
}
function parsePath(path) {
  var pathname = path || "/";
  var search = "";
  var hash = "";
  var hashIndex = pathname.indexOf("#");
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }
  var searchIndex = pathname.indexOf("?");
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }
  return {
    pathname,
    search: search === "?" ? "" : search,
    hash: hash === "#" ? "" : hash
  };
}
function createPath(location) {
  var pathname = location.pathname, search = location.search, hash = location.hash;
  var path = pathname || "/";
  if (search && search !== "?")
    path += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    path += hash.charAt(0) === "#" ? hash : "#" + hash;
  return path;
}
function createLocation(path, state, key, currentLocation) {
  var location;
  if (typeof path === "string") {
    location = parsePath(path);
    location.state = state;
  } else {
    location = _extends({}, path);
    if (location.pathname === void 0)
      location.pathname = "";
    if (location.search) {
      if (location.search.charAt(0) !== "?")
        location.search = "?" + location.search;
    } else {
      location.search = "";
    }
    if (location.hash) {
      if (location.hash.charAt(0) !== "#")
        location.hash = "#" + location.hash;
    } else {
      location.hash = "";
    }
    if (state !== void 0 && location.state === void 0)
      location.state = state;
  }
  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e2) {
    if (e2 instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.');
    } else {
      throw e2;
    }
  }
  if (key)
    location.key = key;
  if (currentLocation) {
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== "/") {
      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
    }
  } else {
    if (!location.pathname) {
      location.pathname = "/";
    }
  }
  return location;
}
function createTransitionManager() {
  var prompt = null;
  function setPrompt(nextPrompt) {
    prompt = nextPrompt;
    return function() {
      if (prompt === nextPrompt)
        prompt = null;
    };
  }
  function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    if (prompt != null) {
      var result = typeof prompt === "function" ? prompt(location, action) : prompt;
      if (typeof result === "string") {
        if (typeof getUserConfirmation === "function") {
          getUserConfirmation(result, callback);
        } else {
          callback(true);
        }
      } else {
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }
  var listeners = [];
  function appendListener(fn) {
    var isActive = true;
    function listener() {
      if (isActive)
        fn.apply(void 0, arguments);
    }
    listeners.push(listener);
    return function() {
      isActive = false;
      listeners = listeners.filter(function(item) {
        return item !== listener;
      });
    };
  }
  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    listeners.forEach(function(listener) {
      return listener.apply(void 0, args);
    });
  }
  return {
    setPrompt,
    confirmTransitionTo,
    appendListener,
    notifyListeners
  };
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message));
}
function supportsHistory() {
  var ua2 = window.navigator.userAgent;
  if ((ua2.indexOf("Android 2.") !== -1 || ua2.indexOf("Android 4.0") !== -1) && ua2.indexOf("Mobile Safari") !== -1 && ua2.indexOf("Chrome") === -1 && ua2.indexOf("Windows Phone") === -1)
    return false;
  return window.history && "pushState" in window.history;
}
function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf("Trident") === -1;
}
function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf("Firefox") === -1;
}
function isExtraneousPopstateEvent(event) {
  return event.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1;
}
var PopStateEvent = "popstate";
var HashChangeEvent = "hashchange";
function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e2) {
    return {};
  }
}
function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? invariant(false) : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props, _props$forceRefresh = _props.forceRefresh, forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
  function getDOMLocation(historyState) {
    var _ref = historyState || {}, key = _ref.key, state = _ref.state;
    var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;
    var path = pathname + search + hash;
    if (basename)
      path = stripBasename(path, basename);
    return createLocation(path, state, key);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function handlePopState(event) {
    if (isExtraneousPopstateEvent(event))
      return;
    handlePop(getDOMLocation(event.state));
  }
  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }
  var forceNextPop = false;
  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
        if (ok2) {
          setState({
            action,
            location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1)
      toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1)
      fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];
  function createHref(location) {
    return basename + createPath(location);
  }
  function push(path, state) {
    var action = "PUSH";
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var href = createHref(location);
      var key = location.key, state2 = location.state;
      if (canUseHistory) {
        globalHistory.pushState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location.key);
          allKeys = nextKeys;
          setState({
            action,
            location
          });
        }
      } else {
        window.location.href = href;
      }
    });
  }
  function replace(path, state) {
    var action = "REPLACE";
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var href = createHref(location);
      var key = location.key, state2 = location.state;
      if (canUseHistory) {
        globalHistory.replaceState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1)
            allKeys[prevIndex] = location.key;
          setState({
            action,
            location
          });
        }
      } else {
        window.location.replace(href);
      }
    });
  }
  function go(n2) {
    globalHistory.go(n2);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener)
        window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener)
        window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
var HashChangeEvent$1 = "hashchange";
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === "!" ? path : "!/" + stripLeadingSlash(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === "!" ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
};
function stripHash(url) {
  var hashIndex = url.indexOf("#");
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}
function getHashPath() {
  var href = window.location.href;
  var hashIndex = href.indexOf("#");
  return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
}
function pushHashPath(path) {
  window.location.hash = path;
}
function replaceHashPath(path) {
  window.location.replace(stripHash(window.location.href) + "#" + path);
}
function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? invariant(false) : void 0;
  var globalHistory = window.history;
  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
  var _props = props, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
  var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath2 = _HashPathCoders$hashT.encodePath, decodePath2 = _HashPathCoders$hashT.decodePath;
  function getDOMLocation() {
    var path2 = decodePath2(getHashPath());
    if (basename)
      path2 = stripBasename(path2, basename);
    return createLocation(path2);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  var forceNextPop = false;
  var ignorePath = null;
  function locationsAreEqual$$1(a, b2) {
    return a.pathname === b2.pathname && a.search === b2.search && a.hash === b2.hash;
  }
  function handleHashChange() {
    var path2 = getHashPath();
    var encodedPath2 = encodePath2(path2);
    if (path2 !== encodedPath2) {
      replaceHashPath(encodedPath2);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location))
        return;
      if (ignorePath === createPath(location))
        return;
      ignorePath = null;
      handlePop(location);
    }
  }
  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
        if (ok2) {
          setState({
            action,
            location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1)
      toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1)
      fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var path = getHashPath();
  var encodedPath = encodePath2(path);
  if (path !== encodedPath)
    replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)];
  function createHref(location) {
    var baseTag = document.querySelector("base");
    var href = "";
    if (baseTag && baseTag.getAttribute("href")) {
      href = stripHash(window.location.href);
    }
    return href + "#" + encodePath2(basename + createPath(location));
  }
  function push(path2, state) {
    var action = "PUSH";
    var location = createLocation(path2, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var path3 = createPath(location);
      var encodedPath2 = encodePath2(basename + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        pushHashPath(encodedPath2);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path3);
        allPaths = nextPaths;
        setState({
          action,
          location
        });
      } else {
        setState();
      }
    });
  }
  function replace(path2, state) {
    var action = "REPLACE";
    var location = createLocation(path2, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var path3 = createPath(location);
      var encodedPath2 = encodePath2(basename + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        replaceHashPath(encodedPath2);
      }
      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1)
        allPaths[prevIndex] = path3;
      setState({
        action,
        location
      });
    });
  }
  function go(n2) {
    globalHistory.go(n2);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
function clamp(n2, lowerBound, upperBound) {
  return Math.min(Math.max(n2, lowerBound), upperBound);
}
function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }
  var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? ["/"] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends(history, nextState);
    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var index2 = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function(entry) {
    return typeof entry === "string" ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
  });
  var createHref = createPath;
  function push(path, state) {
    var action = "PUSH";
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }
      setState({
        action,
        location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }
  function replace(path, state) {
    var action = "REPLACE";
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      history.entries[history.index] = location;
      setState({
        action,
        location
      });
    });
  }
  function go(n2) {
    var nextIndex = clamp(history.index + n2, 0, history.entries.length - 1);
    var action = "POP";
    var location = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (ok2) {
        setState({
          action,
          location,
          index: nextIndex
        });
      } else {
        setState();
      }
    });
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  function canGo(n2) {
    var nextIndex = history.index + n2;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    return transitionManager.setPrompt(prompt);
  }
  function listen(listener) {
    return transitionManager.appendListener(listener);
  }
  var history = {
    length: entries.length,
    action: "POP",
    location: entries[index2],
    index: index2,
    entries,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    canGo,
    block,
    listen
  };
  return history;
}
var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
function getUniqueId() {
  var key = "__global_unique_id__";
  return commonjsGlobal2[key] = (commonjsGlobal2[key] || 0) + 1;
}
function objectIs(x2, y3) {
  if (x2 === y3) {
    return x2 !== 0 || 1 / x2 === 1 / y3;
  } else {
    return x2 !== x2 && y3 !== y3;
  }
}
function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function(h2) {
        return h2 !== handler;
      });
    },
    get: function get2() {
      return value;
    },
    set: function set2(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function(handler) {
        return handler(value, changedBits);
      });
    }
  };
}
function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}
function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;
  var contextProp = "__create-react-context-" + getUniqueId() + "__";
  var Provider = /* @__PURE__ */ function(_Component) {
    _inheritsLoose(Provider2, _Component);
    function Provider2() {
      var _this;
      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }
    var _proto = Provider2.prototype;
    _proto.getChildContext = function getChildContext() {
      var _ref;
      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };
    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;
        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          changedBits |= 0;
          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };
    _proto.render = function render2() {
      return this.props.children;
    };
    return Provider2;
  }(react.Component);
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = propTypes.object.isRequired, _Provider$childContex);
  var Consumer = /* @__PURE__ */ function(_Component2) {
    _inheritsLoose(Consumer2, _Component2);
    function Consumer2() {
      var _this2;
      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };
      _this2.onUpdate = function(newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };
      return _this2;
    }
    var _proto2 = Consumer2.prototype;
    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };
    _proto2.getValue = function getValue2() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };
    _proto2.render = function render2() {
      return onlyChild(this.props.children)(this.state.value);
    };
    return Consumer2;
  }(react.Component);
  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = propTypes.object, _Consumer$contextType);
  return {
    Provider,
    Consumer
  };
}
var index = react.createContext || createReactContext;
var isarray = Array.isArray || function(arr) {
  return Object.prototype.toString.call(arr) == "[object Array]";
};
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;
var PATH_REGEXP = new RegExp([
  "(\\\\.)",
  "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
].join("|"), "g");
function parse(str2, options) {
  var tokens = [];
  var key = 0;
  var index2 = 0;
  var path = "";
  var defaultDelimiter = options && options.delimiter || "/";
  var res;
  while ((res = PATH_REGEXP.exec(str2)) != null) {
    var m2 = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str2.slice(index2, offset);
    index2 = offset + m2.length;
    if (escaped) {
      path += escaped[1];
      continue;
    }
    var next = str2[index2];
    var prefix2 = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];
    if (path) {
      tokens.push(path);
      path = "";
    }
    var partial = prefix2 != null && next != null && next !== prefix2;
    var repeat2 = modifier === "+" || modifier === "*";
    var optional = modifier === "?" || modifier === "*";
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;
    tokens.push({
      name: name || key++,
      prefix: prefix2 || "",
      delimiter,
      optional,
      repeat: repeat2,
      partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? ".*" : "[^" + escapeString(delimiter) + "]+?"
    });
  }
  if (index2 < str2.length) {
    path += str2.substr(index2);
  }
  if (path) {
    tokens.push(path);
  }
  return tokens;
}
function compile(str2, options) {
  return tokensToFunction(parse(str2, options), options);
}
function encodeURIComponentPretty(str2) {
  return encodeURI(str2).replace(/[\/?#]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeAsterisk(str2) {
  return encodeURI(str2).replace(/[?#]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function tokensToFunction(tokens, options) {
  var matches = new Array(tokens.length);
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === "object") {
      matches[i] = new RegExp("^(?:" + tokens[i].pattern + ")$", flags(options));
    }
  }
  return function(obj, opts) {
    var path = "";
    var data = obj || {};
    var options2 = opts || {};
    var encode = options2.pretty ? encodeURIComponentPretty : encodeURIComponent;
    for (var i2 = 0; i2 < tokens.length; i2++) {
      var token = tokens[i2];
      if (typeof token === "string") {
        path += token;
        continue;
      }
      var value = data[token.name];
      var segment;
      if (value == null) {
        if (token.optional) {
          if (token.partial) {
            path += token.prefix;
          }
          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }
      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
        }
        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }
        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);
          if (!matches[i2].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + "`");
          }
          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }
        continue;
      }
      segment = token.asterisk ? encodeAsterisk(value) : encode(value);
      if (!matches[i2].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }
      path += token.prefix + segment;
    }
    return path;
  };
}
function escapeString(str2) {
  return str2.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
}
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, "\\$1");
}
function attachKeys(re2, keys) {
  re2.keys = keys;
  return re2;
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys) {
  var groups = path.source.match(/\((?!\?)/g);
  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }
  return attachKeys(path, keys);
}
function arrayToRegexp(path, keys, options) {
  var parts = [];
  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }
  var regexp = new RegExp("(?:" + parts.join("|") + ")", flags(options));
  return attachKeys(regexp, keys);
}
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = keys || options;
    keys = [];
  }
  options = options || {};
  var strict = options.strict;
  var end = options.end !== false;
  var route = "";
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (typeof token === "string") {
      route += escapeString(token);
    } else {
      var prefix2 = escapeString(token.prefix);
      var capture = "(?:" + token.pattern + ")";
      keys.push(token);
      if (token.repeat) {
        capture += "(?:" + prefix2 + capture + ")*";
      }
      if (token.optional) {
        if (!token.partial) {
          capture = "(?:" + prefix2 + "(" + capture + "))?";
        } else {
          capture = prefix2 + "(" + capture + ")?";
        }
      } else {
        capture = prefix2 + "(" + capture + ")";
      }
      route += capture;
    }
  }
  var delimiter = escapeString(options.delimiter || "/");
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?";
  }
  if (end) {
    route += "$";
  } else {
    route += strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)";
  }
  return attachKeys(new RegExp("^" + route, flags(options)), keys);
}
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = keys || options;
    keys = [];
  }
  options = options || {};
  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys);
  }
  if (isarray(path)) {
    return arrayToRegexp(path, keys, options);
  }
  return stringToRegexp(path, keys, options);
}
pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = typeof Symbol === "function" && Symbol.for;
var c = b ? Symbol.for("react.element") : 60103;
var d = b ? Symbol.for("react.portal") : 60106;
var e = b ? Symbol.for("react.fragment") : 60107;
var f = b ? Symbol.for("react.strict_mode") : 60108;
var g = b ? Symbol.for("react.profiler") : 60114;
var h = b ? Symbol.for("react.provider") : 60109;
var k = b ? Symbol.for("react.context") : 60110;
var l = b ? Symbol.for("react.async_mode") : 60111;
var m = b ? Symbol.for("react.concurrent_mode") : 60111;
var n = b ? Symbol.for("react.forward_ref") : 60112;
var p = b ? Symbol.for("react.suspense") : 60113;
var q = b ? Symbol.for("react.suspense_list") : 60120;
var r = b ? Symbol.for("react.memo") : 60115;
var t = b ? Symbol.for("react.lazy") : 60116;
var v = b ? Symbol.for("react.block") : 60121;
var w = b ? Symbol.for("react.fundamental") : 60117;
var x = b ? Symbol.for("react.responder") : 60118;
var y2 = b ? Symbol.for("react.scope") : 60119;
function z(a) {
  if (typeof a === "object" && a !== null) {
    var u = a.$$typeof;
    switch (u) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a;
              default:
                return u;
            }
        }
      case d:
        return u;
    }
  }
}
function A(a) {
  return z(a) === m;
}
var AsyncMode = l;
var ConcurrentMode = m;
var ContextConsumer = k;
var ContextProvider = h;
var Element2 = c;
var ForwardRef = n;
var Fragment2 = e;
var Lazy = t;
var Memo = r;
var Portal = d;
var Profiler = g;
var StrictMode = f;
var Suspense = p;
var isAsyncMode = function(a) {
  return A(a) || z(a) === l;
};
var isConcurrentMode = A;
var isContextConsumer = function(a) {
  return z(a) === k;
};
var isContextProvider = function(a) {
  return z(a) === h;
};
var isElement = function(a) {
  return typeof a === "object" && a !== null && a.$$typeof === c;
};
var isForwardRef = function(a) {
  return z(a) === n;
};
var isFragment = function(a) {
  return z(a) === e;
};
var isLazy = function(a) {
  return z(a) === t;
};
var isMemo = function(a) {
  return z(a) === r;
};
var isPortal = function(a) {
  return z(a) === d;
};
var isProfiler = function(a) {
  return z(a) === g;
};
var isStrictMode = function(a) {
  return z(a) === f;
};
var isSuspense = function(a) {
  return z(a) === p;
};
var isValidElementType = function(a) {
  return typeof a === "string" || typeof a === "function" || a === e || a === m || a === g || a === f || a === p || a === q || typeof a === "object" && a !== null && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y2 || a.$$typeof === v);
};
var typeOf = z;
var reactIs_production_min = {
  AsyncMode,
  ConcurrentMode,
  ContextConsumer,
  ContextProvider,
  Element: Element2,
  ForwardRef,
  Fragment: Fragment2,
  Lazy,
  Memo,
  Portal,
  Profiler,
  StrictMode,
  Suspense,
  isAsyncMode,
  isConcurrentMode,
  isContextConsumer,
  isContextProvider,
  isElement,
  isForwardRef,
  isFragment,
  isLazy,
  isMemo,
  isPortal,
  isProfiler,
  isStrictMode,
  isSuspense,
  isValidElementType,
  typeOf
};
var reactIs = createCommonjsModule(function(module) {
  {
    module.exports = reactIs_production_min;
  }
});
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var FORWARD_REF_STATICS = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var createNamedContext = function createNamedContext2(name) {
  var context2 = index();
  context2.displayName = name;
  return context2;
};
var historyContext = /* @__PURE__ */ createNamedContext("Router-History");
var createNamedContext$1 = function createNamedContext3(name) {
  var context2 = index();
  context2.displayName = name;
  return context2;
};
var context = /* @__PURE__ */ createNamedContext$1("Router");
var Router = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Router2, _React$Component);
  Router2.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };
  function Router2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    };
    _this._isMounted = false;
    _this._pendingLocation = null;
    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function(location) {
        if (_this._isMounted) {
          _this.setState({
            location
          });
        } else {
          _this._pendingLocation = location;
        }
      });
    }
    return _this;
  }
  var _proto = Router2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this._isMounted = true;
    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten)
      this.unlisten();
  };
  _proto.render = function render2() {
    return react.createElement(context.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router2.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, react.createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };
  return Router2;
}(react.Component);
var MemoryRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(MemoryRouter2, _React$Component);
  function MemoryRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }
  var _proto = MemoryRouter2.prototype;
  _proto.render = function render2() {
    return react.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return MemoryRouter2;
}(react.Component);
var Lifecycle = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Lifecycle2, _React$Component);
  function Lifecycle2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Lifecycle2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount)
      this.props.onMount.call(this, this);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate)
      this.props.onUpdate.call(this, this, prevProps);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount)
      this.props.onUnmount.call(this, this);
  };
  _proto.render = function render2() {
    return null;
  };
  return Lifecycle2;
}(react.Component);
var cache$1 = {};
var cacheLimit$1 = 1e4;
var cacheCount$1 = 0;
function compilePath$1(path, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path])
    return pathCache[path];
  var keys = [];
  var regexp = pathToRegexp_1(path, keys, options);
  var result = {
    regexp,
    keys
  };
  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }
  return result;
}
function matchPath(pathname, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }
  var _options = options, path = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path);
  return paths.reduce(function(matched, path2) {
    if (!path2 && path2 !== "")
      return null;
    if (matched)
      return matched;
    var _compilePath = compilePath$1(path2, {
      end: exact,
      strict,
      sensitive
    }), regexp = _compilePath.regexp, keys = _compilePath.keys;
    var match = regexp.exec(pathname);
    if (!match)
      return null;
    var url = match[0], values = match.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact)
      return null;
    return {
      path: path2,
      url: path2 === "/" && url === "" ? "/" : url,
      isExact,
      params: keys.reduce(function(memo, key, index2) {
        memo[key.name] = values[index2];
        return memo;
      }, {})
    };
  }, null);
}
var Route = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Route2, _React$Component);
  function Route2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Route2.prototype;
  _proto.render = function render2() {
    var _this = this;
    return react.createElement(context.Consumer, null, function(context$1) {
      !context$1 ? invariant(false) : void 0;
      var location = _this.props.location || context$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;
      var props = _extends({}, context$1, {
        location,
        match
      });
      var _this$props = _this.props, children = _this$props.children, component = _this$props.component, render3 = _this$props.render;
      if (Array.isArray(children) && children.length === 0) {
        children = null;
      }
      return react.createElement(context.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ? children(props) : children : component ? react.createElement(component, props) : render3 ? render3(props) : null : typeof children === "function" ? children(props) : null);
    });
  };
  return Route2;
}(react.Component);
function addLeadingSlash$1(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}
function addBasename(basename, location) {
  if (!basename)
    return location;
  return _extends({}, location, {
    pathname: addLeadingSlash$1(basename) + location.pathname
  });
}
function stripBasename$1(basename, location) {
  if (!basename)
    return location;
  var base = addLeadingSlash$1(basename);
  if (location.pathname.indexOf(base) !== 0)
    return location;
  return _extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
}
function createURL(location) {
  return typeof location === "string" ? location : createPath(location);
}
function staticHandler(methodName) {
  return function() {
    invariant(false);
  };
}
function noop() {
}
var StaticRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(StaticRouter2, _React$Component);
  function StaticRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handlePush = function(location) {
      return _this.navigateTo(location, "PUSH");
    };
    _this.handleReplace = function(location) {
      return _this.navigateTo(location, "REPLACE");
    };
    _this.handleListen = function() {
      return noop;
    };
    _this.handleBlock = function() {
      return noop;
    };
    return _this;
  }
  var _proto = StaticRouter2.prototype;
  _proto.navigateTo = function navigateTo(location, action) {
    var _this$props = this.props, _this$props$basename = _this$props.basename, basename = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
    context2.action = action;
    context2.location = addBasename(basename, createLocation(location));
    context2.url = createURL(context2.location);
  };
  _proto.render = function render2() {
    var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location = _this$props2$location === void 0 ? "/" : _this$props2$location, rest = _objectWithoutPropertiesLoose(_this$props2, ["basename", "context", "location"]);
    var history = {
      createHref: function createHref(path) {
        return addLeadingSlash$1(basename + createURL(path));
      },
      action: "POP",
      location: stripBasename$1(basename, createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler(),
      goBack: staticHandler(),
      goForward: staticHandler(),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return react.createElement(Router, _extends({}, rest, {
      history,
      staticContext: context2
    }));
  };
  return StaticRouter2;
}(react.Component);
var Switch = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Switch2, _React$Component);
  function Switch2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Switch2.prototype;
  _proto.render = function render2() {
    var _this = this;
    return react.createElement(context.Consumer, null, function(context2) {
      !context2 ? invariant(false) : void 0;
      var location = _this.props.location || context2.location;
      var element, match;
      react.Children.forEach(_this.props.children, function(child) {
        if (match == null && react.isValidElement(child)) {
          element = child;
          var path = child.props.path || child.props.from;
          match = path ? matchPath(location.pathname, _extends({}, child.props, {
            path
          })) : context2.match;
        }
      });
      return match ? react.cloneElement(element, {
        location,
        computedMatch: match
      }) : null;
    });
  };
  return Switch2;
}(react.Component);
var useContext = react.useContext;
var BrowserRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(BrowserRouter2, _React$Component);
  function BrowserRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createBrowserHistory(_this.props);
    return _this;
  }
  var _proto = BrowserRouter2.prototype;
  _proto.render = function render2() {
    return react.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return BrowserRouter2;
}(react.Component);
var HashRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(HashRouter2, _React$Component);
  function HashRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createHashHistory(_this.props);
    return _this;
  }
  var _proto = HashRouter2.prototype;
  _proto.render = function render2() {
    return react.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return HashRouter2;
}(react.Component);
var resolveToLocation = function resolveToLocation2(to, currentLocation) {
  return typeof to === "function" ? to(currentLocation) : to;
};
var normalizeToLocation = function normalizeToLocation2(to, currentLocation) {
  return typeof to === "string" ? createLocation(to, null, null, currentLocation) : to;
};
var forwardRefShim = function forwardRefShim2(C) {
  return C;
};
var forwardRef = react.forwardRef;
if (typeof forwardRef === "undefined") {
  forwardRef = forwardRefShim;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
var LinkAnchor = forwardRef(function(_ref, forwardedRef) {
  var innerRef = _ref.innerRef, navigate = _ref.navigate, _onClick = _ref.onClick, rest = _objectWithoutPropertiesLoose(_ref, ["innerRef", "navigate", "onClick"]);
  var target = rest.target;
  var props = _extends({}, rest, {
    onClick: function onClick(event) {
      try {
        if (_onClick)
          _onClick(event);
      } catch (ex) {
        event.preventDefault();
        throw ex;
      }
      if (!event.defaultPrevented && event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
        event.preventDefault();
        navigate();
      }
    }
  });
  if (forwardRefShim !== forwardRef) {
    props.ref = forwardedRef || innerRef;
  } else {
    props.ref = innerRef;
  }
  return react.createElement("a", props);
});
var Link = forwardRef(function(_ref2, forwardedRef) {
  var _ref2$component = _ref2.component, component = _ref2$component === void 0 ? LinkAnchor : _ref2$component, replace = _ref2.replace, to = _ref2.to, innerRef = _ref2.innerRef, rest = _objectWithoutPropertiesLoose(_ref2, ["component", "replace", "to", "innerRef"]);
  return react.createElement(context.Consumer, null, function(context2) {
    !context2 ? invariant(false) : void 0;
    var history = context2.history;
    var location = normalizeToLocation(resolveToLocation(to, context2.location), context2.location);
    var href = location ? history.createHref(location) : "";
    var props = _extends({}, rest, {
      href,
      navigate: function navigate() {
        var location2 = resolveToLocation(to, context2.location);
        var method = replace ? history.replace : history.push;
        method(location2);
      }
    });
    if (forwardRefShim !== forwardRef) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }
    return react.createElement(component, props);
  });
});
var forwardRefShim$1 = function forwardRefShim3(C) {
  return C;
};
var forwardRef$1 = react.forwardRef;
if (typeof forwardRef$1 === "undefined") {
  forwardRef$1 = forwardRefShim$1;
}
function joinClassnames() {
  for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {
    classnames[_key] = arguments[_key];
  }
  return classnames.filter(function(i) {
    return i;
  }).join(" ");
}
var NavLink = forwardRef$1(function(_ref, forwardedRef) {
  var _ref$ariaCurrent = _ref["aria-current"], ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent, _ref$activeClassName = _ref.activeClassName, activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName, activeStyle = _ref.activeStyle, classNameProp = _ref.className, exact = _ref.exact, isActiveProp = _ref.isActive, locationProp = _ref.location, sensitive = _ref.sensitive, strict = _ref.strict, styleProp = _ref.style, to = _ref.to, innerRef = _ref.innerRef, rest = _objectWithoutPropertiesLoose(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);
  return react.createElement(context.Consumer, null, function(context2) {
    !context2 ? invariant(false) : void 0;
    var currentLocation = locationProp || context2.location;
    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
    var path = toLocation.pathname;
    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    var match = escapedPath ? matchPath(currentLocation.pathname, {
      path: escapedPath,
      exact,
      sensitive,
      strict
    }) : null;
    var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);
    var className = isActive ? joinClassnames(classNameProp, activeClassName) : classNameProp;
    var style = isActive ? _extends({}, styleProp, {}, activeStyle) : styleProp;
    var props = _extends({
      "aria-current": isActive && ariaCurrent || null,
      className,
      style,
      to: toLocation
    }, rest);
    if (forwardRefShim$1 !== forwardRef$1) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }
    return react.createElement(Link, props);
  });
});

// build/dist/pages/Home/Home.js
var Home = () => {
  return /* @__PURE__ */ react.createElement(Fragment, null, /* @__PURE__ */ react.createElement("h1", null, "Welcome to Mule's Tools!"), /* @__PURE__ */ react.createElement("p", null, "This page contains a small collection of little tools and utilities I think are useful enough to share with the world."), /* @__PURE__ */ react.createElement("p", null, "For now, it's just the ", /* @__PURE__ */ react.createElement(Link, {
    to: "/wave-analyzer"
  }, "wave analyzer"), "."), /* @__PURE__ */ react.createElement("p", null, "Happy hacking!"));
};
var Home_default = Home;

// build/dist/pkg/js-yaml.js
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index2, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
      key = sourceKeys[index2];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "") + tail,
    pos: position - lineStart + head.length
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re2 = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re2.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index2, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
    arguments[index2].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c2) {
  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
}
function isOctCode(c2) {
  return 48 <= c2 && c2 <= 55;
}
function isDecCode(c2) {
  return 48 <= c2 && c2 <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index2 = 0, hasDigits = false, ch2;
  if (!max)
    return false;
  ch2 = data[index2];
  if (ch2 === "-" || ch2 === "+") {
    ch2 = data[++index2];
  }
  if (ch2 === "0") {
    if (index2 + 1 === max)
      return true;
    ch2 = data[++index2];
    if (ch2 === "b") {
      index2++;
      for (; index2 < max; index2++) {
        ch2 = data[index2];
        if (ch2 === "_")
          continue;
        if (ch2 !== "0" && ch2 !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch2 !== "_";
    }
    if (ch2 === "x") {
      index2++;
      for (; index2 < max; index2++) {
        ch2 = data[index2];
        if (ch2 === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch2 !== "_";
    }
    if (ch2 === "o") {
      index2++;
      for (; index2 < max; index2++) {
        ch2 = data[index2];
        if (ch2 === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch2 !== "_";
    }
  }
  if (ch2 === "_")
    return false;
  for (; index2 < max; index2++) {
    ch2 = data[index2];
    if (ch2 === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index2))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch2 === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch2;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch2 = value[0];
  if (ch2 === "-" || ch2 === "+") {
    if (ch2 === "-")
      sign = -1;
    value = value.slice(1);
    ch2 = value[0];
  }
  if (value === "0")
    return 0;
  if (ch2 === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index2, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index2] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index2, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    keys = Object.keys(pair);
    result[index2] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c2) {
  return c2 === 10 || c2 === 13;
}
function is_WHITE_SPACE(c2) {
  return c2 === 9 || c2 === 32;
}
function is_WS_OR_EOL(c2) {
  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
}
function is_FLOW_INDICATOR(c2) {
  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
}
function fromHexCode(c2) {
  var lc2;
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  lc2 = c2 | 32;
  if (97 <= lc2 && lc2 <= 102) {
    return lc2 - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c2) {
  if (c2 === 120) {
    return 2;
  }
  if (c2 === 117) {
    return 4;
  }
  if (c2 === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c2) {
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  return -1;
}
function simpleEscapeSequence(c2) {
  return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "" : c2 === 95 ? "" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c2) {
  if (c2 <= 65535) {
    return String.fromCharCode(c2);
  }
  return String.fromCharCode((c2 - 65536 >> 10) + 55296, (c2 - 65536 & 1023) + 56320);
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix2;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix2 = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix2)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix2 = decodeURIComponent(prefix2);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix2);
    }
    state.tagMap[handle] = prefix2;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index2, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
    key = sourceKeys[index2];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index2, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
      if (Array.isArray(keyNode[index2])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
        keyNode[index2] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
        mergeMappings(state, _result, valueNode[index2], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 === 10) {
    state.position++;
  } else if (ch2 === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch2 = state.input.charCodeAt(state.position);
  while (ch2 !== 0) {
    while (is_WHITE_SPACE(ch2)) {
      if (ch2 === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch2 = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch2 === 35) {
      do {
        ch2 = state.input.charCodeAt(++state.position);
      } while (ch2 !== 10 && ch2 !== 13 && ch2 !== 0);
    }
    if (is_EOL(ch2)) {
      readLineBreak(state);
      ch2 = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch2 === 32) {
        state.lineIndent++;
        ch2 = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch2;
  ch2 = state.input.charCodeAt(_position);
  if ((ch2 === 45 || ch2 === 46) && ch2 === state.input.charCodeAt(_position + 1) && ch2 === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch2 = state.input.charCodeAt(_position);
    if (ch2 === 0 || is_WS_OR_EOL(ch2)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch2) || is_FLOW_INDICATOR(ch2) || ch2 === 35 || ch2 === 38 || ch2 === 42 || ch2 === 33 || ch2 === 124 || ch2 === 62 || ch2 === 39 || ch2 === 34 || ch2 === 37 || ch2 === 64 || ch2 === 96) {
    return false;
  }
  if (ch2 === 63 || ch2 === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch2 !== 0) {
    if (ch2 === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch2 === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch2)) {
      break;
    } else if (is_EOL(ch2)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch2 = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch2)) {
      captureEnd = state.position + 1;
    }
    ch2 = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch2, captureStart, captureEnd;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch2 = state.input.charCodeAt(state.position)) !== 0) {
    if (ch2 === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch2 = state.input.charCodeAt(++state.position);
      if (ch2 === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch2)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch2 = state.input.charCodeAt(state.position)) !== 0) {
    if (ch2 === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch2 === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch2 = state.input.charCodeAt(++state.position);
      if (is_EOL(ch2)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch2 < 256 && simpleEscapeCheck[ch2]) {
        state.result += simpleEscapeMap[ch2];
        state.position++;
      } else if ((tmp = escapedHexLen(ch2)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch2 = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch2)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch2)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = Object.create(null), keyNode, keyTag, valueNode, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch2 === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch2 = state.input.charCodeAt(++state.position);
  while (ch2 !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch2 === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch2 === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch2 = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch2 === 58) {
      isPair = true;
      ch2 = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 === 44) {
      readNext = true;
      ch2 = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 === 124) {
    folding = false;
  } else if (ch2 === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch2 !== 0) {
    ch2 = state.input.charCodeAt(++state.position);
    if (ch2 === 43 || ch2 === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch2 === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch2)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch2)) {
    do {
      ch2 = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch2));
    if (ch2 === 35) {
      do {
        ch2 = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch2) && ch2 !== 0);
    }
  }
  while (ch2 !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch2 = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch2 === 32) {
      state.lineIndent++;
      ch2 = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch2)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch2)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch2) && ch2 !== 0) {
      ch2 = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch2;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch2 = state.input.charCodeAt(state.position);
  while (ch2 !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch2 !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch2 = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch2 = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch2 !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch2;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch2 = state.input.charCodeAt(state.position);
  while (ch2 !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch2 === 63 || ch2 === 58) && is_WS_OR_EOL(following)) {
      if (ch2 === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch2 = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch2 = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch2)) {
          ch2 = state.input.charCodeAt(++state.position);
        }
        if (ch2 === 58) {
          ch2 = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch2)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch2 = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch2 !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch2 = state.input.charCodeAt(++state.position);
  if (ch2 === 60) {
    isVerbatim = true;
    ch2 = state.input.charCodeAt(++state.position);
  } else if (ch2 === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch2 = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch2 = state.input.charCodeAt(++state.position);
    } while (ch2 !== 0 && ch2 !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch2 = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
      if (ch2 === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch2 = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch2 = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch2 !== 0 && !is_WS_OR_EOL(ch2) && !is_FLOW_INDICATOR(ch2)) {
    ch2 = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 !== 42)
    return false;
  ch2 = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch2 !== 0 && !is_WS_OR_EOL(ch2) && !is_FLOW_INDICATOR(ch2)) {
    ch2 = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch2;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = Object.create(null);
  state.anchorMap = Object.create(null);
  while ((ch2 = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch2 = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch2 !== 37) {
      break;
    }
    hasDirectives = true;
    ch2 = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
      ch2 = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch2 !== 0) {
      while (is_WHITE_SPACE(ch2)) {
        ch2 = state.input.charCodeAt(++state.position);
      }
      if (ch2 === 35) {
        do {
          ch2 = state.input.charCodeAt(++state.position);
        } while (ch2 !== 0 && !is_EOL(ch2));
        break;
      }
      if (is_EOL(ch2))
        break;
      _position = state.position;
      while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
        ch2 = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch2 !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
    iterator(documents[index2]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index2, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index2 = 0, length = keys.length; index2 < length; index2 += 1) {
    tag = keys[index2];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index2, length, type2;
  for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
    type2 = state.implicitTypes[index2];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c2) {
  return c2 === CHAR_SPACE || c2 === CHAR_TAB;
}
function isPrintable(c2) {
  return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== CHAR_BOM || 65536 <= c2 && c2 <= 1114111;
}
function isNsCharOrWhitespace(c2) {
  return isPrintable(c2) && c2 !== CHAR_BOM && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
}
function isPlainSafe(c2, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c2);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c2);
  return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET) && c2 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c2 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
}
function isPlainSafeFirst(c2) {
  return isPrintable(c2) && c2 !== CHAR_BOM && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c2) {
  return !isWhitespace(c2) && c2 !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString2(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix2 = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix2 + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString2(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index2, length, value;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    value = object[index2];
    if (state.replacer) {
      value = state.replacer.call(object, String(index2), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index2, length, value;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    value = object[index2];
    if (state.replacer) {
      value = state.replacer.call(object, String(index2), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index2];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index2];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index2, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
    type2 = typeList[index2];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index2, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index2]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index2, length;
  if (object !== null && typeof object === "object") {
    index2 = objects.indexOf(object);
    if (index2 !== -1) {
      if (duplicatesIndexes.indexOf(index2) === -1) {
        duplicatesIndexes.push(index2);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
          inspectNode(object[index2], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
          inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({"": value}, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
var types = {
  binary,
  float,
  map,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load,
  loadAll,
  dump,
  YAMLException,
  types,
  safeLoad,
  safeLoadAll,
  safeDump
};
var js_yaml_default = jsYaml;

// build/dist/components/SplitPane/SplitPane.js
var SplitPane = ({children}) => {
  const [percent, setPercent] = useState(0.5);
  const onDividerChange = (e2) => {
    setPercent(e2.target.value / 100);
  };
  switch (children.length) {
    case 0: {
      return null;
    }
    case 1: {
      return children[0];
    }
    case 2: {
      const [left, right] = children;
      return /* @__PURE__ */ react.createElement("div", {
        className: "split-pane-container"
      }, /* @__PURE__ */ react.createElement("div", {
        className: "split-pane-content"
      }, /* @__PURE__ */ react.createElement("div", {
        className: "pane",
        style: {flex: `calc(${Math.round(percent * 100)}%) 0 0`}
      }, left), /* @__PURE__ */ react.createElement("div", {
        className: "pane",
        style: {flex: `calc(${Math.round((1 - percent) * 100)}%) 0 0`}
      }, right)), /* @__PURE__ */ react.createElement("div", {
        className: "split-pane-divider"
      }, /* @__PURE__ */ react.createElement("input", {
        className: "slider",
        type: "range",
        min: "0",
        max: "100",
        value: Math.round(percent * 100),
        onChange: onDividerChange
      })));
    }
    default: {
      throw new Error(`unsupported child count: ${children.length}`);
    }
  }
};
var SplitPane_default = SplitPane;

// build/dist/components/SplitPane/index.js
var SplitPane_default2 = SplitPane_default;

// build/dist/pkg/react-ace.js
var ace_1 = createCommonjsModule(function(module, exports) {
  (function() {
    var ACE_NAMESPACE = "ace";
    var global2 = function() {
      return this;
    }();
    if (!global2 && typeof window != "undefined")
      global2 = window;
    var define = function(module2, deps, payload) {
      if (typeof module2 !== "string") {
        if (define.original)
          define.original.apply(this, arguments);
        else {
          console.error("dropping module because define wasn't a string.");
          console.trace();
        }
        return;
      }
      if (arguments.length == 2)
        payload = deps;
      if (!define.modules[module2]) {
        define.payloads[module2] = payload;
        define.modules[module2] = null;
      }
    };
    define.modules = {};
    define.payloads = {};
    var _require = function(parentId, module2, callback) {
      if (typeof module2 === "string") {
        var payload = lookup(parentId, module2);
        if (payload != void 0) {
          callback && callback();
          return payload;
        }
      } else if (Object.prototype.toString.call(module2) === "[object Array]") {
        var params = [];
        for (var i = 0, l2 = module2.length; i < l2; ++i) {
          var dep = lookup(parentId, module2[i]);
          if (dep == void 0 && require2.original)
            return;
          params.push(dep);
        }
        return callback && callback.apply(null, params) || true;
      }
    };
    var require2 = function(module2, callback) {
      var packagedModule = _require("", module2, callback);
      if (packagedModule == void 0 && require2.original)
        return require2.original.apply(this, arguments);
      return packagedModule;
    };
    var normalizeModule = function(parentId, moduleName) {
      if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
      }
      if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        moduleName = base + "/" + moduleName;
        while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
          var previous = moduleName;
          moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
      }
      return moduleName;
    };
    var lookup = function(parentId, moduleName) {
      moduleName = normalizeModule(parentId, moduleName);
      var module2 = define.modules[moduleName];
      if (!module2) {
        module2 = define.payloads[moduleName];
        if (typeof module2 === "function") {
          var exports2 = {};
          var mod = {
            id: moduleName,
            uri: "",
            exports: exports2,
            packaged: true
          };
          var req = function(module3, callback) {
            return _require(moduleName, module3, callback);
          };
          var returnValue = module2(req, exports2, mod);
          exports2 = returnValue || mod.exports;
          define.modules[moduleName] = exports2;
          delete define.payloads[moduleName];
        }
        module2 = define.modules[moduleName] = exports2 || module2;
      }
      return module2;
    };
    function exportAce(ns) {
      var root2 = global2;
      if (ns) {
        if (!global2[ns])
          global2[ns] = {};
        root2 = global2[ns];
      }
      if (!root2.define || !root2.define.packaged) {
        define.original = root2.define;
        root2.define = define;
        root2.define.packaged = true;
      }
      if (!root2.require || !root2.require.packaged) {
        require2.original = root2.require;
        root2.require = require2;
        root2.require.packaged = true;
      }
    }
    exportAce(ACE_NAMESPACE);
  })();
  ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module"], function(require2, exports2, module2) {
    if (typeof Element != "undefined" && !Element.prototype.remove) {
      Object.defineProperty(Element.prototype, "remove", {
        enumerable: false,
        writable: true,
        configurable: true,
        value: function() {
          this.parentNode && this.parentNode.removeChild(this);
        }
      });
    }
  });
  ace.define("ace/lib/useragent", ["require", "exports", "module"], function(require2, exports2, module2) {
    exports2.OS = {
      LINUX: "LINUX",
      MAC: "MAC",
      WINDOWS: "WINDOWS"
    };
    exports2.getOS = function() {
      if (exports2.isMac) {
        return exports2.OS.MAC;
      } else if (exports2.isLinux) {
        return exports2.OS.LINUX;
      } else {
        return exports2.OS.WINDOWS;
      }
    };
    var _navigator = typeof navigator == "object" ? navigator : {};
    var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
    var ua2 = _navigator.userAgent || "";
    var appName = _navigator.appName || "";
    exports2.isWin = os == "win";
    exports2.isMac = os == "mac";
    exports2.isLinux = os == "linux";
    exports2.isIE = appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua2.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua2.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
    exports2.isOldIE = exports2.isIE && exports2.isIE < 9;
    exports2.isGecko = exports2.isMozilla = ua2.match(/ Gecko\/\d+/);
    exports2.isOpera = typeof opera == "object" && Object.prototype.toString.call(window.opera) == "[object Opera]";
    exports2.isWebKit = parseFloat(ua2.split("WebKit/")[1]) || void 0;
    exports2.isChrome = parseFloat(ua2.split(" Chrome/")[1]) || void 0;
    exports2.isEdge = parseFloat(ua2.split(" Edge/")[1]) || void 0;
    exports2.isAIR = ua2.indexOf("AdobeAIR") >= 0;
    exports2.isAndroid = ua2.indexOf("Android") >= 0;
    exports2.isChromeOS = ua2.indexOf(" CrOS ") >= 0;
    exports2.isIOS = /iPad|iPhone|iPod/.test(ua2) && !window.MSStream;
    if (exports2.isIOS)
      exports2.isMac = true;
    exports2.isMobile = exports2.isIOS || exports2.isAndroid;
  });
  ace.define("ace/lib/dom", ["require", "exports", "module", "ace/lib/useragent"], function(require2, exports2, module2) {
    var useragent = require2("./useragent");
    var XHTML_NS = "http://www.w3.org/1999/xhtml";
    exports2.buildDom = function buildDom(arr, parent, refs) {
      if (typeof arr == "string" && arr) {
        var txt = document.createTextNode(arr);
        if (parent)
          parent.appendChild(txt);
        return txt;
      }
      if (!Array.isArray(arr)) {
        if (arr && arr.appendChild && parent)
          parent.appendChild(arr);
        return arr;
      }
      if (typeof arr[0] != "string" || !arr[0]) {
        var els = [];
        for (var i = 0; i < arr.length; i++) {
          var ch2 = buildDom(arr[i], parent, refs);
          ch2 && els.push(ch2);
        }
        return els;
      }
      var el = document.createElement(arr[0]);
      var options = arr[1];
      var childIndex = 1;
      if (options && typeof options == "object" && !Array.isArray(options))
        childIndex = 2;
      for (var i = childIndex; i < arr.length; i++)
        buildDom(arr[i], el, refs);
      if (childIndex == 2) {
        Object.keys(options).forEach(function(n2) {
          var val = options[n2];
          if (n2 === "class") {
            el.className = Array.isArray(val) ? val.join(" ") : val;
          } else if (typeof val == "function" || n2 == "value" || n2[0] == "$") {
            el[n2] = val;
          } else if (n2 === "ref") {
            if (refs)
              refs[val] = el;
          } else if (val != null) {
            el.setAttribute(n2, val);
          }
        });
      }
      if (parent)
        parent.appendChild(el);
      return el;
    };
    exports2.getDocumentHead = function(doc) {
      if (!doc)
        doc = document;
      return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
    };
    exports2.createElement = function(tag, ns) {
      return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
    };
    exports2.removeChildren = function(element) {
      element.innerHTML = "";
    };
    exports2.createTextNode = function(textContent, element) {
      var doc = element ? element.ownerDocument : document;
      return doc.createTextNode(textContent);
    };
    exports2.createFragment = function(element) {
      var doc = element ? element.ownerDocument : document;
      return doc.createDocumentFragment();
    };
    exports2.hasCssClass = function(el, name) {
      var classes = (el.className + "").split(/\s+/g);
      return classes.indexOf(name) !== -1;
    };
    exports2.addCssClass = function(el, name) {
      if (!exports2.hasCssClass(el, name)) {
        el.className += " " + name;
      }
    };
    exports2.removeCssClass = function(el, name) {
      var classes = el.className.split(/\s+/g);
      while (true) {
        var index2 = classes.indexOf(name);
        if (index2 == -1) {
          break;
        }
        classes.splice(index2, 1);
      }
      el.className = classes.join(" ");
    };
    exports2.toggleCssClass = function(el, name) {
      var classes = el.className.split(/\s+/g), add = true;
      while (true) {
        var index2 = classes.indexOf(name);
        if (index2 == -1) {
          break;
        }
        add = false;
        classes.splice(index2, 1);
      }
      if (add)
        classes.push(name);
      el.className = classes.join(" ");
      return add;
    };
    exports2.setCssClass = function(node, className, include) {
      if (include) {
        exports2.addCssClass(node, className);
      } else {
        exports2.removeCssClass(node, className);
      }
    };
    exports2.hasCssString = function(id2, doc) {
      var index2 = 0, sheets;
      doc = doc || document;
      if (sheets = doc.querySelectorAll("style")) {
        while (index2 < sheets.length)
          if (sheets[index2++].id === id2)
            return true;
      }
    };
    exports2.importCssString = function importCssString(cssText2, id2, target) {
      var container = target;
      if (!target || !target.getRootNode) {
        container = document;
      } else {
        container = target.getRootNode();
        if (!container || container == target)
          container = document;
      }
      var doc = container.ownerDocument || container;
      if (id2 && exports2.hasCssString(id2, container))
        return null;
      if (id2)
        cssText2 += "\n/*# sourceURL=ace/css/" + id2 + " */";
      var style = exports2.createElement("style");
      style.appendChild(doc.createTextNode(cssText2));
      if (id2)
        style.id = id2;
      if (container == doc)
        container = exports2.getDocumentHead(doc);
      container.insertBefore(style, container.firstChild);
    };
    exports2.importCssStylsheet = function(uri, doc) {
      exports2.buildDom(["link", {rel: "stylesheet", href: uri}], exports2.getDocumentHead(doc));
    };
    exports2.scrollbarWidth = function(document2) {
      var inner = exports2.createElement("ace_inner");
      inner.style.width = "100%";
      inner.style.minWidth = "0px";
      inner.style.height = "200px";
      inner.style.display = "block";
      var outer = exports2.createElement("ace_outer");
      var style = outer.style;
      style.position = "absolute";
      style.left = "-10000px";
      style.overflow = "hidden";
      style.width = "200px";
      style.minWidth = "0px";
      style.height = "150px";
      style.display = "block";
      outer.appendChild(inner);
      var body = document2.documentElement;
      body.appendChild(outer);
      var noScrollbar = inner.offsetWidth;
      style.overflow = "scroll";
      var withScrollbar = inner.offsetWidth;
      if (noScrollbar == withScrollbar) {
        withScrollbar = outer.clientWidth;
      }
      body.removeChild(outer);
      return noScrollbar - withScrollbar;
    };
    if (typeof document == "undefined") {
      exports2.importCssString = function() {
      };
    }
    exports2.computedStyle = function(element, style) {
      return window.getComputedStyle(element, "") || {};
    };
    exports2.setStyle = function(styles, property, value) {
      if (styles[property] !== value) {
        styles[property] = value;
      }
    };
    exports2.HAS_CSS_ANIMATION = false;
    exports2.HAS_CSS_TRANSFORMS = false;
    exports2.HI_DPI = useragent.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
    if (typeof document !== "undefined") {
      var div = document.createElement("div");
      if (exports2.HI_DPI && div.style.transform !== void 0)
        exports2.HAS_CSS_TRANSFORMS = true;
      if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
        exports2.HAS_CSS_ANIMATION = true;
      div = null;
    }
    if (exports2.HAS_CSS_TRANSFORMS) {
      exports2.translate = function(element, tx, ty) {
        element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
      };
    } else {
      exports2.translate = function(element, tx, ty) {
        element.style.top = Math.round(ty) + "px";
        element.style.left = Math.round(tx) + "px";
      };
    }
  });
  ace.define("ace/lib/oop", ["require", "exports", "module"], function(require2, exports2, module2) {
    exports2.inherits = function(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
    exports2.mixin = function(obj, mixin) {
      for (var key in mixin) {
        obj[key] = mixin[key];
      }
      return obj;
    };
    exports2.implement = function(proto, mixin) {
      exports2.mixin(proto, mixin);
    };
  });
  ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/oop"], function(require2, exports2, module2) {
    var oop = require2("./oop");
    var Keys = function() {
      var ret = {
        MODIFIER_KEYS: {
          16: "Shift",
          17: "Ctrl",
          18: "Alt",
          224: "Meta",
          91: "MetaLeft",
          92: "MetaRight",
          93: "ContextMenu"
        },
        KEY_MODS: {
          ctrl: 1,
          alt: 2,
          option: 2,
          shift: 4,
          super: 8,
          meta: 8,
          command: 8,
          cmd: 8,
          control: 1
        },
        FUNCTION_KEYS: {
          8: "Backspace",
          9: "Tab",
          13: "Return",
          19: "Pause",
          27: "Esc",
          32: "Space",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "Left",
          38: "Up",
          39: "Right",
          40: "Down",
          44: "Print",
          45: "Insert",
          46: "Delete",
          96: "Numpad0",
          97: "Numpad1",
          98: "Numpad2",
          99: "Numpad3",
          100: "Numpad4",
          101: "Numpad5",
          102: "Numpad6",
          103: "Numpad7",
          104: "Numpad8",
          105: "Numpad9",
          "-13": "NumpadEnter",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "Numlock",
          145: "Scrolllock"
        },
        PRINTABLE_KEYS: {
          32: " ",
          48: "0",
          49: "1",
          50: "2",
          51: "3",
          52: "4",
          53: "5",
          54: "6",
          55: "7",
          56: "8",
          57: "9",
          59: ";",
          61: "=",
          65: "a",
          66: "b",
          67: "c",
          68: "d",
          69: "e",
          70: "f",
          71: "g",
          72: "h",
          73: "i",
          74: "j",
          75: "k",
          76: "l",
          77: "m",
          78: "n",
          79: "o",
          80: "p",
          81: "q",
          82: "r",
          83: "s",
          84: "t",
          85: "u",
          86: "v",
          87: "w",
          88: "x",
          89: "y",
          90: "z",
          107: "+",
          109: "-",
          110: ".",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'",
          111: "/",
          106: "*"
        }
      };
      var name, i;
      for (i in ret.FUNCTION_KEYS) {
        name = ret.FUNCTION_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
      }
      for (i in ret.PRINTABLE_KEYS) {
        name = ret.PRINTABLE_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
      }
      oop.mixin(ret, ret.MODIFIER_KEYS);
      oop.mixin(ret, ret.PRINTABLE_KEYS);
      oop.mixin(ret, ret.FUNCTION_KEYS);
      ret.enter = ret["return"];
      ret.escape = ret.esc;
      ret.del = ret["delete"];
      ret[173] = "-";
      (function() {
        var mods = ["cmd", "ctrl", "alt", "shift"];
        for (var i2 = Math.pow(2, mods.length); i2--; ) {
          ret.KEY_MODS[i2] = mods.filter(function(x2) {
            return i2 & ret.KEY_MODS[x2];
          }).join("-") + "-";
        }
      })();
      ret.KEY_MODS[0] = "";
      ret.KEY_MODS[-1] = "input-";
      return ret;
    }();
    oop.mixin(exports2, Keys);
    exports2.keyCodeToString = function(keyCode) {
      var keyString = Keys[keyCode];
      if (typeof keyString != "string")
        keyString = String.fromCharCode(keyCode);
      return keyString.toLowerCase();
    };
  });
  ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require2, exports2, module2) {
    var keys = require2("./keys");
    var useragent = require2("./useragent");
    var pressedKeys = null;
    var ts = 0;
    var activeListenerOptions;
    function detectListenerOptionsSupport() {
      activeListenerOptions = false;
      try {
        document.createComment("").addEventListener("test", function() {
        }, {
          get passive() {
            activeListenerOptions = {passive: false};
          }
        });
      } catch (e2) {
      }
    }
    function getListenerOptions() {
      if (activeListenerOptions == void 0)
        detectListenerOptionsSupport();
      return activeListenerOptions;
    }
    function EventListener(elem, type2, callback) {
      this.elem = elem;
      this.type = type2;
      this.callback = callback;
    }
    EventListener.prototype.destroy = function() {
      removeListener(this.elem, this.type, this.callback);
      this.elem = this.type = this.callback = void 0;
    };
    var addListener = exports2.addListener = function(elem, type2, callback, destroyer) {
      elem.addEventListener(type2, callback, getListenerOptions());
      if (destroyer)
        destroyer.$toDestroy.push(new EventListener(elem, type2, callback));
    };
    var removeListener = exports2.removeListener = function(elem, type2, callback) {
      elem.removeEventListener(type2, callback, getListenerOptions());
    };
    exports2.stopEvent = function(e2) {
      exports2.stopPropagation(e2);
      exports2.preventDefault(e2);
      return false;
    };
    exports2.stopPropagation = function(e2) {
      if (e2.stopPropagation)
        e2.stopPropagation();
    };
    exports2.preventDefault = function(e2) {
      if (e2.preventDefault)
        e2.preventDefault();
    };
    exports2.getButton = function(e2) {
      if (e2.type == "dblclick")
        return 0;
      if (e2.type == "contextmenu" || useragent.isMac && (e2.ctrlKey && !e2.altKey && !e2.shiftKey))
        return 2;
      return e2.button;
    };
    exports2.capture = function(el, eventHandler, releaseCaptureHandler) {
      var ownerDocument = el && el.ownerDocument || document;
      function onMouseUp(e2) {
        eventHandler && eventHandler(e2);
        releaseCaptureHandler && releaseCaptureHandler(e2);
        removeListener(ownerDocument, "mousemove", eventHandler);
        removeListener(ownerDocument, "mouseup", onMouseUp);
        removeListener(ownerDocument, "dragstart", onMouseUp);
      }
      addListener(ownerDocument, "mousemove", eventHandler);
      addListener(ownerDocument, "mouseup", onMouseUp);
      addListener(ownerDocument, "dragstart", onMouseUp);
      return onMouseUp;
    };
    exports2.addMouseWheelListener = function(el, callback, destroyer) {
      if ("onmousewheel" in el) {
        addListener(el, "mousewheel", function(e2) {
          var factor = 8;
          if (e2.wheelDeltaX !== void 0) {
            e2.wheelX = -e2.wheelDeltaX / factor;
            e2.wheelY = -e2.wheelDeltaY / factor;
          } else {
            e2.wheelX = 0;
            e2.wheelY = -e2.wheelDelta / factor;
          }
          callback(e2);
        }, destroyer);
      } else if ("onwheel" in el) {
        addListener(el, "wheel", function(e2) {
          var factor = 0.35;
          switch (e2.deltaMode) {
            case e2.DOM_DELTA_PIXEL:
              e2.wheelX = e2.deltaX * factor || 0;
              e2.wheelY = e2.deltaY * factor || 0;
              break;
            case e2.DOM_DELTA_LINE:
            case e2.DOM_DELTA_PAGE:
              e2.wheelX = (e2.deltaX || 0) * 5;
              e2.wheelY = (e2.deltaY || 0) * 5;
              break;
          }
          callback(e2);
        }, destroyer);
      } else {
        addListener(el, "DOMMouseScroll", function(e2) {
          if (e2.axis && e2.axis == e2.HORIZONTAL_AXIS) {
            e2.wheelX = (e2.detail || 0) * 5;
            e2.wheelY = 0;
          } else {
            e2.wheelX = 0;
            e2.wheelY = (e2.detail || 0) * 5;
          }
          callback(e2);
        }, destroyer);
      }
    };
    exports2.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
      var clicks = 0;
      var startX, startY, timer;
      var eventNames = {
        2: "dblclick",
        3: "tripleclick",
        4: "quadclick"
      };
      function onMousedown(e2) {
        if (exports2.getButton(e2) !== 0) {
          clicks = 0;
        } else if (e2.detail > 1) {
          clicks++;
          if (clicks > 4)
            clicks = 1;
        } else {
          clicks = 1;
        }
        if (useragent.isIE) {
          var isNewClick = Math.abs(e2.clientX - startX) > 5 || Math.abs(e2.clientY - startY) > 5;
          if (!timer || isNewClick)
            clicks = 1;
          if (timer)
            clearTimeout(timer);
          timer = setTimeout(function() {
            timer = null;
          }, timeouts[clicks - 1] || 600);
          if (clicks == 1) {
            startX = e2.clientX;
            startY = e2.clientY;
          }
        }
        e2._clicks = clicks;
        eventHandler[callbackName]("mousedown", e2);
        if (clicks > 4)
          clicks = 0;
        else if (clicks > 1)
          return eventHandler[callbackName](eventNames[clicks], e2);
      }
      if (!Array.isArray(elements))
        elements = [elements];
      elements.forEach(function(el) {
        addListener(el, "mousedown", onMousedown, destroyer);
      });
    };
    var getModifierHash = function(e2) {
      return 0 | (e2.ctrlKey ? 1 : 0) | (e2.altKey ? 2 : 0) | (e2.shiftKey ? 4 : 0) | (e2.metaKey ? 8 : 0);
    };
    exports2.getModifierString = function(e2) {
      return keys.KEY_MODS[getModifierHash(e2)];
    };
    function normalizeCommandKeys(callback, e2, keyCode) {
      var hashId = getModifierHash(e2);
      if (!useragent.isMac && pressedKeys) {
        if (e2.getModifierState && (e2.getModifierState("OS") || e2.getModifierState("Win")))
          hashId |= 8;
        if (pressedKeys.altGr) {
          if ((3 & hashId) != 3)
            pressedKeys.altGr = 0;
          else
            return;
        }
        if (keyCode === 18 || keyCode === 17) {
          var location = "location" in e2 ? e2.location : e2.keyLocation;
          if (keyCode === 17 && location === 1) {
            if (pressedKeys[keyCode] == 1)
              ts = e2.timeStamp;
          } else if (keyCode === 18 && hashId === 3 && location === 2) {
            var dt = e2.timeStamp - ts;
            if (dt < 50)
              pressedKeys.altGr = true;
          }
        }
      }
      if (keyCode in keys.MODIFIER_KEYS) {
        keyCode = -1;
      }
      if (!hashId && keyCode === 13) {
        var location = "location" in e2 ? e2.location : e2.keyLocation;
        if (location === 3) {
          callback(e2, hashId, -keyCode);
          if (e2.defaultPrevented)
            return;
        }
      }
      if (useragent.isChromeOS && hashId & 8) {
        callback(e2, hashId, keyCode);
        if (e2.defaultPrevented)
          return;
        else
          hashId &= ~8;
      }
      if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
        return false;
      }
      return callback(e2, hashId, keyCode);
    }
    exports2.addCommandKeyListener = function(el, callback, destroyer) {
      if (useragent.isOldGecko || useragent.isOpera && !("KeyboardEvent" in window)) {
        var lastKeyDownKeyCode = null;
        addListener(el, "keydown", function(e2) {
          lastKeyDownKeyCode = e2.keyCode;
        }, destroyer);
        addListener(el, "keypress", function(e2) {
          return normalizeCommandKeys(callback, e2, lastKeyDownKeyCode);
        }, destroyer);
      } else {
        var lastDefaultPrevented = null;
        addListener(el, "keydown", function(e2) {
          pressedKeys[e2.keyCode] = (pressedKeys[e2.keyCode] || 0) + 1;
          var result = normalizeCommandKeys(callback, e2, e2.keyCode);
          lastDefaultPrevented = e2.defaultPrevented;
          return result;
        }, destroyer);
        addListener(el, "keypress", function(e2) {
          if (lastDefaultPrevented && (e2.ctrlKey || e2.altKey || e2.shiftKey || e2.metaKey)) {
            exports2.stopEvent(e2);
            lastDefaultPrevented = null;
          }
        }, destroyer);
        addListener(el, "keyup", function(e2) {
          pressedKeys[e2.keyCode] = null;
        }, destroyer);
        if (!pressedKeys) {
          resetPressedKeys();
          addListener(window, "focus", resetPressedKeys);
        }
      }
    };
    function resetPressedKeys() {
      pressedKeys = Object.create(null);
    }
    if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
      var postMessageId = 1;
      exports2.nextTick = function(callback, win) {
        win = win || window;
        var messageName = "zero-timeout-message-" + postMessageId++;
        var listener = function(e2) {
          if (e2.data == messageName) {
            exports2.stopPropagation(e2);
            removeListener(win, "message", listener);
            callback();
          }
        };
        addListener(win, "message", listener);
        win.postMessage(messageName, "*");
      };
    }
    exports2.$idleBlocked = false;
    exports2.onIdle = function(cb2, timeout) {
      return setTimeout(function handler() {
        if (!exports2.$idleBlocked) {
          cb2();
        } else {
          setTimeout(handler, 100);
        }
      }, timeout);
    };
    exports2.$idleBlockId = null;
    exports2.blockIdle = function(delay) {
      if (exports2.$idleBlockId)
        clearTimeout(exports2.$idleBlockId);
      exports2.$idleBlocked = true;
      exports2.$idleBlockId = setTimeout(function() {
        exports2.$idleBlocked = false;
      }, delay || 100);
    };
    exports2.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame);
    if (exports2.nextFrame)
      exports2.nextFrame = exports2.nextFrame.bind(window);
    else
      exports2.nextFrame = function(callback) {
        setTimeout(callback, 17);
      };
  });
  ace.define("ace/range", ["require", "exports", "module"], function(require2, exports2, module2) {
    var comparePoints = function(p1, p2) {
      return p1.row - p2.row || p1.column - p2.column;
    };
    var Range = function(startRow, startColumn, endRow, endColumn) {
      this.start = {
        row: startRow,
        column: startColumn
      };
      this.end = {
        row: endRow,
        column: endColumn
      };
    };
    (function() {
      this.isEqual = function(range) {
        return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
      };
      this.toString = function() {
        return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
      };
      this.contains = function(row, column) {
        return this.compare(row, column) == 0;
      };
      this.compareRange = function(range) {
        var cmp, end = range.end, start = range.start;
        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
          cmp = this.compare(start.row, start.column);
          if (cmp == 1) {
            return 2;
          } else if (cmp == 0) {
            return 1;
          } else {
            return 0;
          }
        } else if (cmp == -1) {
          return -2;
        } else {
          cmp = this.compare(start.row, start.column);
          if (cmp == -1) {
            return -1;
          } else if (cmp == 1) {
            return 42;
          } else {
            return 0;
          }
        }
      };
      this.comparePoint = function(p2) {
        return this.compare(p2.row, p2.column);
      };
      this.containsRange = function(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
      };
      this.intersects = function(range) {
        var cmp = this.compareRange(range);
        return cmp == -1 || cmp == 0 || cmp == 1;
      };
      this.isEnd = function(row, column) {
        return this.end.row == row && this.end.column == column;
      };
      this.isStart = function(row, column) {
        return this.start.row == row && this.start.column == column;
      };
      this.setStart = function(row, column) {
        if (typeof row == "object") {
          this.start.column = row.column;
          this.start.row = row.row;
        } else {
          this.start.row = row;
          this.start.column = column;
        }
      };
      this.setEnd = function(row, column) {
        if (typeof row == "object") {
          this.end.column = row.column;
          this.end.row = row.row;
        } else {
          this.end.row = row;
          this.end.column = column;
        }
      };
      this.inside = function(row, column) {
        if (this.compare(row, column) == 0) {
          if (this.isEnd(row, column) || this.isStart(row, column)) {
            return false;
          } else {
            return true;
          }
        }
        return false;
      };
      this.insideStart = function(row, column) {
        if (this.compare(row, column) == 0) {
          if (this.isEnd(row, column)) {
            return false;
          } else {
            return true;
          }
        }
        return false;
      };
      this.insideEnd = function(row, column) {
        if (this.compare(row, column) == 0) {
          if (this.isStart(row, column)) {
            return false;
          } else {
            return true;
          }
        }
        return false;
      };
      this.compare = function(row, column) {
        if (!this.isMultiLine()) {
          if (row === this.start.row) {
            return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
          }
        }
        if (row < this.start.row)
          return -1;
        if (row > this.end.row)
          return 1;
        if (this.start.row === row)
          return column >= this.start.column ? 0 : -1;
        if (this.end.row === row)
          return column <= this.end.column ? 0 : 1;
        return 0;
      };
      this.compareStart = function(row, column) {
        if (this.start.row == row && this.start.column == column) {
          return -1;
        } else {
          return this.compare(row, column);
        }
      };
      this.compareEnd = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
          return 1;
        } else {
          return this.compare(row, column);
        }
      };
      this.compareInside = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
          return 1;
        } else if (this.start.row == row && this.start.column == column) {
          return -1;
        } else {
          return this.compare(row, column);
        }
      };
      this.clipRows = function(firstRow, lastRow) {
        if (this.end.row > lastRow)
          var end = {row: lastRow + 1, column: 0};
        else if (this.end.row < firstRow)
          var end = {row: firstRow, column: 0};
        if (this.start.row > lastRow)
          var start = {row: lastRow + 1, column: 0};
        else if (this.start.row < firstRow)
          var start = {row: firstRow, column: 0};
        return Range.fromPoints(start || this.start, end || this.end);
      };
      this.extend = function(row, column) {
        var cmp = this.compare(row, column);
        if (cmp == 0)
          return this;
        else if (cmp == -1)
          var start = {row, column};
        else
          var end = {row, column};
        return Range.fromPoints(start || this.start, end || this.end);
      };
      this.isEmpty = function() {
        return this.start.row === this.end.row && this.start.column === this.end.column;
      };
      this.isMultiLine = function() {
        return this.start.row !== this.end.row;
      };
      this.clone = function() {
        return Range.fromPoints(this.start, this.end);
      };
      this.collapseRows = function() {
        if (this.end.column == 0)
          return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
        else
          return new Range(this.start.row, 0, this.end.row, 0);
      };
      this.toScreenRange = function(session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);
        return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
      };
      this.moveBy = function(row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
      };
    }).call(Range.prototype);
    Range.fromPoints = function(start, end) {
      return new Range(start.row, start.column, end.row, end.column);
    };
    Range.comparePoints = comparePoints;
    Range.comparePoints = function(p1, p2) {
      return p1.row - p2.row || p1.column - p2.column;
    };
    exports2.Range = Range;
  });
  ace.define("ace/lib/lang", ["require", "exports", "module"], function(require2, exports2, module2) {
    exports2.last = function(a) {
      return a[a.length - 1];
    };
    exports2.stringReverse = function(string) {
      return string.split("").reverse().join("");
    };
    exports2.stringRepeat = function(string, count) {
      var result = "";
      while (count > 0) {
        if (count & 1)
          result += string;
        if (count >>= 1)
          string += string;
      }
      return result;
    };
    var trimBeginRegexp = /^\s\s*/;
    var trimEndRegexp = /\s\s*$/;
    exports2.stringTrimLeft = function(string) {
      return string.replace(trimBeginRegexp, "");
    };
    exports2.stringTrimRight = function(string) {
      return string.replace(trimEndRegexp, "");
    };
    exports2.copyObject = function(obj) {
      var copy = {};
      for (var key in obj) {
        copy[key] = obj[key];
      }
      return copy;
    };
    exports2.copyArray = function(array) {
      var copy = [];
      for (var i = 0, l2 = array.length; i < l2; i++) {
        if (array[i] && typeof array[i] == "object")
          copy[i] = this.copyObject(array[i]);
        else
          copy[i] = array[i];
      }
      return copy;
    };
    exports2.deepCopy = function deepCopy(obj) {
      if (typeof obj !== "object" || !obj)
        return obj;
      var copy;
      if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key < obj.length; key++) {
          copy[key] = deepCopy(obj[key]);
        }
        return copy;
      }
      if (Object.prototype.toString.call(obj) !== "[object Object]")
        return obj;
      copy = {};
      for (var key in obj)
        copy[key] = deepCopy(obj[key]);
      return copy;
    };
    exports2.arrayToMap = function(arr) {
      var map2 = {};
      for (var i = 0; i < arr.length; i++) {
        map2[arr[i]] = 1;
      }
      return map2;
    };
    exports2.createMap = function(props) {
      var map2 = Object.create(null);
      for (var i in props) {
        map2[i] = props[i];
      }
      return map2;
    };
    exports2.arrayRemove = function(array, value) {
      for (var i = 0; i <= array.length; i++) {
        if (value === array[i]) {
          array.splice(i, 1);
        }
      }
    };
    exports2.escapeRegExp = function(str2) {
      return str2.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
    };
    exports2.escapeHTML = function(str2) {
      return ("" + str2).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
    };
    exports2.getMatchOffsets = function(string, regExp) {
      var matches = [];
      string.replace(regExp, function(str2) {
        matches.push({
          offset: arguments[arguments.length - 2],
          length: str2.length
        });
      });
      return matches;
    };
    exports2.deferredCall = function(fcn) {
      var timer = null;
      var callback = function() {
        timer = null;
        fcn();
      };
      var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
      };
      deferred.schedule = deferred;
      deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
      };
      deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
      };
      deferred.isPending = function() {
        return timer;
      };
      return deferred;
    };
    exports2.delayedCall = function(fcn, defaultTimeout) {
      var timer = null;
      var callback = function() {
        timer = null;
        fcn();
      };
      var _self = function(timeout) {
        if (timer == null)
          timer = setTimeout(callback, timeout || defaultTimeout);
      };
      _self.delay = function(timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
      };
      _self.schedule = _self;
      _self.call = function() {
        this.cancel();
        fcn();
      };
      _self.cancel = function() {
        timer && clearTimeout(timer);
        timer = null;
      };
      _self.isPending = function() {
        return timer;
      };
      return _self;
    };
  });
  ace.define("ace/clipboard", ["require", "exports", "module"], function(require2, exports2, module2) {
    var $cancelT;
    module2.exports = {
      lineMode: false,
      pasteCancelled: function() {
        if ($cancelT && $cancelT > Date.now() - 50)
          return true;
        return $cancelT = false;
      },
      cancel: function() {
        $cancelT = Date.now();
      }
    };
  });
  ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/clipboard", "ace/lib/keys"], function(require2, exports2, module2) {
    var event = require2("../lib/event");
    var useragent = require2("../lib/useragent");
    var dom = require2("../lib/dom");
    var lang = require2("../lib/lang");
    var clipboard = require2("../clipboard");
    var BROKEN_SETDATA = useragent.isChrome < 18;
    var USE_IE_MIME_TYPE = useragent.isIE;
    var HAS_FOCUS_ARGS = useragent.isChrome > 63;
    var MAX_LINE_LENGTH = 400;
    var KEYS = require2("../lib/keys");
    var MODS = KEYS.KEY_MODS;
    var isIOS = useragent.isIOS;
    var valueResetRegex = isIOS ? /\s/ : /\n/;
    var isMobile = useragent.isMobile;
    var TextInput = function(parentNode, host) {
      var text = dom.createElement("textarea");
      text.className = "ace_text-input";
      text.setAttribute("wrap", "off");
      text.setAttribute("autocorrect", "off");
      text.setAttribute("autocapitalize", "off");
      text.setAttribute("spellcheck", false);
      text.style.opacity = "0";
      parentNode.insertBefore(text, parentNode.firstChild);
      var copied = false;
      var pasted = false;
      var inComposition = false;
      var sendingText = false;
      var tempStyle = "";
      if (!isMobile)
        text.style.fontSize = "1px";
      var commandMode = false;
      var ignoreFocusEvents = false;
      var lastValue = "";
      var lastSelectionStart = 0;
      var lastSelectionEnd = 0;
      var lastRestoreEnd = 0;
      try {
        var isFocused = document.activeElement === text;
      } catch (e2) {
      }
      event.addListener(text, "blur", function(e2) {
        if (ignoreFocusEvents)
          return;
        host.onBlur(e2);
        isFocused = false;
      }, host);
      event.addListener(text, "focus", function(e2) {
        if (ignoreFocusEvents)
          return;
        isFocused = true;
        if (useragent.isEdge) {
          try {
            if (!document.hasFocus())
              return;
          } catch (e3) {
          }
        }
        host.onFocus(e2);
        if (useragent.isEdge)
          setTimeout(resetSelection);
        else
          resetSelection();
      }, host);
      this.$focusScroll = false;
      this.focus = function() {
        if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
          return text.focus({preventScroll: true});
        var top = text.style.top;
        text.style.position = "fixed";
        text.style.top = "0px";
        try {
          var isTransformed = text.getBoundingClientRect().top != 0;
        } catch (e2) {
          return;
        }
        var ancestors = [];
        if (isTransformed) {
          var t2 = text.parentElement;
          while (t2 && t2.nodeType == 1) {
            ancestors.push(t2);
            t2.setAttribute("ace_nocontext", true);
            if (!t2.parentElement && t2.getRootNode)
              t2 = t2.getRootNode().host;
            else
              t2 = t2.parentElement;
          }
        }
        text.focus({preventScroll: true});
        if (isTransformed) {
          ancestors.forEach(function(p2) {
            p2.removeAttribute("ace_nocontext");
          });
        }
        setTimeout(function() {
          text.style.position = "";
          if (text.style.top == "0px")
            text.style.top = top;
        }, 0);
      };
      this.blur = function() {
        text.blur();
      };
      this.isFocused = function() {
        return isFocused;
      };
      host.on("beforeEndOperation", function() {
        var curOp = host.curOp;
        var commandName = curOp && curOp.command && curOp.command.name;
        if (commandName == "insertstring")
          return;
        var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
        if (inComposition && isUserAction) {
          lastValue = text.value = "";
          onCompositionEnd();
        }
        resetSelection();
      });
      var resetSelection = isIOS ? function(value) {
        if (!isFocused || copied && !value || sendingText)
          return;
        if (!value)
          value = "";
        var newValue = "\n ab" + value + "cde fg\n";
        if (newValue != text.value)
          text.value = lastValue = newValue;
        var selectionStart = 4;
        var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));
        if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
          text.setSelectionRange(selectionStart, selectionEnd);
        }
        lastSelectionStart = selectionStart;
        lastSelectionEnd = selectionEnd;
      } : function() {
        if (inComposition || sendingText)
          return;
        if (!isFocused && !afterContextMenu)
          return;
        inComposition = true;
        var selectionStart = 0;
        var selectionEnd = 0;
        var line = "";
        if (host.session) {
          var selection = host.selection;
          var range = selection.getRange();
          var row = selection.cursor.row;
          selectionStart = range.start.column;
          selectionEnd = range.end.column;
          line = host.session.getLine(row);
          if (range.start.row != row) {
            var prevLine = host.session.getLine(row - 1);
            selectionStart = range.start.row < row - 1 ? 0 : selectionStart;
            selectionEnd += prevLine.length + 1;
            line = prevLine + "\n" + line;
          } else if (range.end.row != row) {
            var nextLine = host.session.getLine(row + 1);
            selectionEnd = range.end.row > row + 1 ? nextLine.length : selectionEnd;
            selectionEnd += line.length + 1;
            line = line + "\n" + nextLine;
          } else if (isMobile && row > 0) {
            line = "\n" + line;
            selectionEnd += 1;
            selectionStart += 1;
          }
          if (line.length > MAX_LINE_LENGTH) {
            if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
              line = line.slice(0, MAX_LINE_LENGTH);
            } else {
              line = "\n";
              if (selectionStart == selectionEnd) {
                selectionStart = selectionEnd = 0;
              } else {
                selectionStart = 0;
                selectionEnd = 1;
              }
            }
          }
        }
        var newValue = line + "\n\n";
        if (newValue != lastValue) {
          text.value = lastValue = newValue;
          lastSelectionStart = lastSelectionEnd = newValue.length;
        }
        if (afterContextMenu) {
          lastSelectionStart = text.selectionStart;
          lastSelectionEnd = text.selectionEnd;
        }
        if (lastSelectionEnd != selectionEnd || lastSelectionStart != selectionStart || text.selectionEnd != lastSelectionEnd) {
          try {
            text.setSelectionRange(selectionStart, selectionEnd);
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
          } catch (e2) {
          }
        }
        inComposition = false;
      };
      this.resetSelection = resetSelection;
      if (isFocused)
        host.onFocus();
      var isAllSelected = function(text2) {
        return text2.selectionStart === 0 && text2.selectionEnd >= lastValue.length && text2.value === lastValue && lastValue && text2.selectionEnd !== lastSelectionEnd;
      };
      var onSelect = function(e2) {
        if (inComposition)
          return;
        if (copied) {
          copied = false;
        } else if (isAllSelected(text)) {
          host.selectAll();
          resetSelection();
        } else if (isMobile && text.selectionStart != lastSelectionStart) {
          resetSelection();
        }
      };
      var inputHandler = null;
      this.setInputHandler = function(cb2) {
        inputHandler = cb2;
      };
      this.getInputHandler = function() {
        return inputHandler;
      };
      var afterContextMenu = false;
      var sendText = function(value, fromInput) {
        if (afterContextMenu)
          afterContextMenu = false;
        if (pasted) {
          resetSelection();
          if (value)
            host.onPaste(value);
          pasted = false;
          return "";
        } else {
          var selectionStart = text.selectionStart;
          var selectionEnd = text.selectionEnd;
          var extendLeft = lastSelectionStart;
          var extendRight = lastValue.length - lastSelectionEnd;
          var inserted = value;
          var restoreStart = value.length - selectionStart;
          var restoreEnd = value.length - selectionEnd;
          var i = 0;
          while (extendLeft > 0 && lastValue[i] == value[i]) {
            i++;
            extendLeft--;
          }
          inserted = inserted.slice(i);
          i = 1;
          while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1 && lastValue[lastValue.length - i] == value[value.length - i]) {
            i++;
            extendRight--;
          }
          restoreStart -= i - 1;
          restoreEnd -= i - 1;
          var endIndex = inserted.length - i + 1;
          if (endIndex < 0) {
            extendLeft = -endIndex;
            endIndex = 0;
          }
          inserted = inserted.slice(0, endIndex);
          if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
            return "";
          sendingText = true;
          var shouldReset = false;
          if (useragent.isAndroid && inserted == ". ") {
            inserted = "  ";
            shouldReset = true;
          }
          if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
            host.onTextInput(inserted);
          } else {
            host.onTextInput(inserted, {
              extendLeft,
              extendRight,
              restoreStart,
              restoreEnd
            });
          }
          sendingText = false;
          lastValue = value;
          lastSelectionStart = selectionStart;
          lastSelectionEnd = selectionEnd;
          lastRestoreEnd = restoreEnd;
          return shouldReset ? "\n" : inserted;
        }
      };
      var onInput = function(e2) {
        if (inComposition)
          return onCompositionUpdate();
        if (e2 && e2.inputType) {
          if (e2.inputType == "historyUndo")
            return host.execCommand("undo");
          if (e2.inputType == "historyRedo")
            return host.execCommand("redo");
        }
        var data = text.value;
        var inserted = sendText(data, true);
        if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd) {
          resetSelection();
        }
      };
      var handleClipboardData = function(e2, data, forceIEMime) {
        var clipboardData = e2.clipboardData || window.clipboardData;
        if (!clipboardData || BROKEN_SETDATA)
          return;
        var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
        try {
          if (data) {
            return clipboardData.setData(mime, data) !== false;
          } else {
            return clipboardData.getData(mime);
          }
        } catch (e3) {
          if (!forceIEMime)
            return handleClipboardData(e3, data, true);
        }
      };
      var doCopy = function(e2, isCut) {
        var data = host.getCopyText();
        if (!data)
          return event.preventDefault(e2);
        if (handleClipboardData(e2, data)) {
          if (isIOS) {
            resetSelection(data);
            copied = data;
            setTimeout(function() {
              copied = false;
            }, 10);
          }
          isCut ? host.onCut() : host.onCopy();
          event.preventDefault(e2);
        } else {
          copied = true;
          text.value = data;
          text.select();
          setTimeout(function() {
            copied = false;
            resetSelection();
            isCut ? host.onCut() : host.onCopy();
          });
        }
      };
      var onCut = function(e2) {
        doCopy(e2, true);
      };
      var onCopy = function(e2) {
        doCopy(e2, false);
      };
      var onPaste = function(e2) {
        var data = handleClipboardData(e2);
        if (clipboard.pasteCancelled())
          return;
        if (typeof data == "string") {
          if (data)
            host.onPaste(data, e2);
          if (useragent.isIE)
            setTimeout(resetSelection);
          event.preventDefault(e2);
        } else {
          text.value = "";
          pasted = true;
        }
      };
      event.addCommandKeyListener(text, host.onCommandKey.bind(host), host);
      event.addListener(text, "select", onSelect, host);
      event.addListener(text, "input", onInput, host);
      event.addListener(text, "cut", onCut, host);
      event.addListener(text, "copy", onCopy, host);
      event.addListener(text, "paste", onPaste, host);
      if (!("oncut" in text) || !("oncopy" in text) || !("onpaste" in text)) {
        event.addListener(parentNode, "keydown", function(e2) {
          if (useragent.isMac && !e2.metaKey || !e2.ctrlKey)
            return;
          switch (e2.keyCode) {
            case 67:
              onCopy(e2);
              break;
            case 86:
              onPaste(e2);
              break;
            case 88:
              onCut(e2);
              break;
          }
        }, host);
      }
      var onCompositionStart = function(e2) {
        if (inComposition || !host.onCompositionStart || host.$readOnly)
          return;
        inComposition = {};
        if (commandMode)
          return;
        if (e2.data)
          inComposition.useTextareaForIME = false;
        setTimeout(onCompositionUpdate, 0);
        host._signal("compositionStart");
        host.on("mousedown", cancelComposition);
        var range = host.getSelectionRange();
        range.end.row = range.start.row;
        range.end.column = range.start.column;
        inComposition.markerRange = range;
        inComposition.selectionStart = lastSelectionStart;
        host.onCompositionStart(inComposition);
        if (inComposition.useTextareaForIME) {
          lastValue = text.value = "";
          lastSelectionStart = 0;
          lastSelectionEnd = 0;
        } else {
          if (text.msGetInputContext)
            inComposition.context = text.msGetInputContext();
          if (text.getInputContext)
            inComposition.context = text.getInputContext();
        }
      };
      var onCompositionUpdate = function() {
        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
          return;
        if (commandMode)
          return cancelComposition();
        if (inComposition.useTextareaForIME) {
          host.onCompositionUpdate(text.value);
        } else {
          var data = text.value;
          sendText(data);
          if (inComposition.markerRange) {
            if (inComposition.context) {
              inComposition.markerRange.start.column = inComposition.selectionStart = inComposition.context.compositionStartOffset;
            }
            inComposition.markerRange.end.column = inComposition.markerRange.start.column + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
          }
        }
      };
      var onCompositionEnd = function(e2) {
        if (!host.onCompositionEnd || host.$readOnly)
          return;
        inComposition = false;
        host.onCompositionEnd();
        host.off("mousedown", cancelComposition);
        if (e2)
          onInput();
      };
      function cancelComposition() {
        ignoreFocusEvents = true;
        text.blur();
        text.focus();
        ignoreFocusEvents = false;
      }
      var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
      function onKeyup(e2) {
        if (e2.keyCode == 27 && text.value.length < text.selectionStart) {
          if (!inComposition)
            lastValue = text.value;
          lastSelectionStart = lastSelectionEnd = -1;
          resetSelection();
        }
        syncComposition();
      }
      event.addListener(text, "compositionstart", onCompositionStart, host);
      event.addListener(text, "compositionupdate", onCompositionUpdate, host);
      event.addListener(text, "keyup", onKeyup, host);
      event.addListener(text, "keydown", syncComposition, host);
      event.addListener(text, "compositionend", onCompositionEnd, host);
      this.getElement = function() {
        return text;
      };
      this.setCommandMode = function(value) {
        commandMode = value;
        text.readOnly = false;
      };
      this.setReadOnly = function(readOnly) {
        if (!commandMode)
          text.readOnly = readOnly;
      };
      this.setCopyWithEmptySelection = function(value) {
      };
      this.onContextMenu = function(e2) {
        afterContextMenu = true;
        resetSelection();
        host._emit("nativecontextmenu", {target: host, domEvent: e2});
        this.moveToMouse(e2, true);
      };
      this.moveToMouse = function(e2, bringToFront) {
        if (!tempStyle)
          tempStyle = text.style.cssText;
        text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";
        var rect = host.container.getBoundingClientRect();
        var style = dom.computedStyle(host.container);
        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
        var maxTop = rect.bottom - top - text.clientHeight - 2;
        var move = function(e3) {
          dom.translate(text, e3.clientX - left - 2, Math.min(e3.clientY - top - 2, maxTop));
        };
        move(e2);
        if (e2.type != "mousedown")
          return;
        host.renderer.$isMousePressed = true;
        clearTimeout(closeTimeout);
        if (useragent.isWin)
          event.capture(host.container, move, onContextMenuClose);
      };
      this.onContextMenuClose = onContextMenuClose;
      var closeTimeout;
      function onContextMenuClose() {
        clearTimeout(closeTimeout);
        closeTimeout = setTimeout(function() {
          if (tempStyle) {
            text.style.cssText = tempStyle;
            tempStyle = "";
          }
          host.renderer.$isMousePressed = false;
          if (host.renderer.$keepTextAreaAtCursor)
            host.renderer.$moveTextAreaToCursor();
        }, 0);
      }
      var onContextMenu = function(e2) {
        host.textInput.onContextMenu(e2);
        onContextMenuClose();
      };
      event.addListener(text, "mouseup", onContextMenu, host);
      event.addListener(text, "mousedown", function(e2) {
        e2.preventDefault();
        onContextMenuClose();
      }, host);
      event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
      event.addListener(text, "contextmenu", onContextMenu, host);
      if (isIOS)
        addIosSelectionHandler(parentNode, host, text);
      function addIosSelectionHandler(parentNode2, host2, text2) {
        var typingResetTimeout = null;
        var typing = false;
        text2.addEventListener("keydown", function(e2) {
          if (typingResetTimeout)
            clearTimeout(typingResetTimeout);
          typing = true;
        }, true);
        text2.addEventListener("keyup", function(e2) {
          typingResetTimeout = setTimeout(function() {
            typing = false;
          }, 100);
        }, true);
        var detectArrowKeys = function(e2) {
          if (document.activeElement !== text2)
            return;
          if (typing || inComposition || host2.$mouseHandler.isMousePressed)
            return;
          if (copied) {
            return;
          }
          var selectionStart = text2.selectionStart;
          var selectionEnd = text2.selectionEnd;
          var key = null;
          var modifier = 0;
          if (selectionStart == 0) {
            key = KEYS.up;
          } else if (selectionStart == 1) {
            key = KEYS.home;
          } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
            key = KEYS.end;
          } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
            key = KEYS.left;
            modifier = MODS.option;
          } else if (selectionStart < lastSelectionStart || selectionStart == lastSelectionStart && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
            key = KEYS.left;
          } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
            key = KEYS.down;
          } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
            key = KEYS.right;
            modifier = MODS.option;
          } else if (selectionEnd > lastSelectionEnd || selectionEnd == lastSelectionEnd && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
            key = KEYS.right;
          }
          if (selectionStart !== selectionEnd)
            modifier |= MODS.shift;
          if (key) {
            var result = host2.onCommandKey({}, modifier, key);
            if (!result && host2.commands) {
              key = KEYS.keyCodeToString(key);
              var command = host2.commands.findKeyCommand(modifier, key);
              if (command)
                host2.execCommand(command);
            }
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
            resetSelection("");
          }
        };
        document.addEventListener("selectionchange", detectArrowKeys);
        host2.on("destroy", function() {
          document.removeEventListener("selectionchange", detectArrowKeys);
        });
      }
    };
    exports2.TextInput = TextInput;
    exports2.$setUserAgentForTests = function(_isMobile, _isIOS) {
      isMobile = _isMobile;
      isIOS = _isIOS;
    };
  });
  ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/useragent"], function(require2, exports2, module2) {
    var useragent = require2("../lib/useragent");
    var DRAG_OFFSET = 0;
    var SCROLL_COOLDOWN_T = 550;
    function DefaultHandlers(mouseHandler) {
      mouseHandler.$clickSelection = null;
      var editor = mouseHandler.editor;
      editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
      editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
      editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
      editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
      editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
      var exports3 = [
        "select",
        "startSelect",
        "selectEnd",
        "selectAllEnd",
        "selectByWordsEnd",
        "selectByLinesEnd",
        "dragWait",
        "dragWaitEnd",
        "focusWait"
      ];
      exports3.forEach(function(x2) {
        mouseHandler[x2] = this[x2];
      }, this);
      mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
      mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
    }
    (function() {
      this.onMouseDown = function(ev) {
        var inSelection = ev.inSelection();
        var pos = ev.getDocumentPosition();
        this.mousedownEvent = ev;
        var editor = this.editor;
        var button = ev.getButton();
        if (button !== 0) {
          var selectionRange = editor.getSelectionRange();
          var selectionEmpty = selectionRange.isEmpty();
          if (selectionEmpty || button == 1)
            editor.selection.moveToPosition(pos);
          if (button == 2) {
            editor.textInput.onContextMenu(ev.domEvent);
            if (!useragent.isMozilla)
              ev.preventDefault();
          }
          return;
        }
        this.mousedownEvent.time = Date.now();
        if (inSelection && !editor.isFocused()) {
          editor.focus();
          if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
            this.setState("focusWait");
            this.captureMouse(ev);
            return;
          }
        }
        this.captureMouse(ev);
        this.startSelect(pos, ev.domEvent._clicks > 1);
        return ev.preventDefault();
      };
      this.startSelect = function(pos, waitForClickSelection) {
        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
        var editor = this.editor;
        if (!this.mousedownEvent)
          return;
        if (this.mousedownEvent.getShiftKey())
          editor.selection.selectToPosition(pos);
        else if (!waitForClickSelection)
          editor.selection.moveToPosition(pos);
        if (!waitForClickSelection)
          this.select();
        if (editor.renderer.scroller.setCapture) {
          editor.renderer.scroller.setCapture();
        }
        editor.setStyle("ace_selecting");
        this.setState("select");
      };
      this.select = function() {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        if (this.$clickSelection) {
          var cmp = this.$clickSelection.comparePoint(cursor);
          if (cmp == -1) {
            anchor = this.$clickSelection.end;
          } else if (cmp == 1) {
            anchor = this.$clickSelection.start;
          } else {
            var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
            cursor = orientedRange.cursor;
            anchor = orientedRange.anchor;
          }
          editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.renderer.scrollCursorIntoView();
      };
      this.extendSelectionBy = function(unitName) {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        var range = editor.selection[unitName](cursor.row, cursor.column);
        if (this.$clickSelection) {
          var cmpStart = this.$clickSelection.comparePoint(range.start);
          var cmpEnd = this.$clickSelection.comparePoint(range.end);
          if (cmpStart == -1 && cmpEnd <= 0) {
            anchor = this.$clickSelection.end;
            if (range.end.row != cursor.row || range.end.column != cursor.column)
              cursor = range.start;
          } else if (cmpEnd == 1 && cmpStart >= 0) {
            anchor = this.$clickSelection.start;
            if (range.start.row != cursor.row || range.start.column != cursor.column)
              cursor = range.end;
          } else if (cmpStart == -1 && cmpEnd == 1) {
            cursor = range.end;
            anchor = range.start;
          } else {
            var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
            cursor = orientedRange.cursor;
            anchor = orientedRange.anchor;
          }
          editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.renderer.scrollCursorIntoView();
      };
      this.selectEnd = this.selectAllEnd = this.selectByWordsEnd = this.selectByLinesEnd = function() {
        this.$clickSelection = null;
        this.editor.unsetStyle("ace_selecting");
        if (this.editor.renderer.scroller.releaseCapture) {
          this.editor.renderer.scroller.releaseCapture();
        }
      };
      this.focusWait = function() {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        var time = Date.now();
        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
          this.startSelect(this.mousedownEvent.getDocumentPosition());
      };
      this.onDoubleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        var session = editor.session;
        var range = session.getBracketRange(pos);
        if (range) {
          if (range.isEmpty()) {
            range.start.column--;
            range.end.column++;
          }
          this.setState("select");
        } else {
          range = editor.selection.getWordRange(pos.row, pos.column);
          this.setState("selectByWords");
        }
        this.$clickSelection = range;
        this.select();
      };
      this.onTripleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        this.setState("selectByLines");
        var range = editor.getSelectionRange();
        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
          this.$clickSelection = editor.selection.getLineRange(range.start.row);
          this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
        } else {
          this.$clickSelection = editor.selection.getLineRange(pos.row);
        }
        this.select();
      };
      this.onQuadClick = function(ev) {
        var editor = this.editor;
        editor.selectAll();
        this.$clickSelection = editor.getSelectionRange();
        this.setState("selectAll");
      };
      this.onMouseWheel = function(ev) {
        if (ev.getAccelKey())
          return;
        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
          ev.wheelX = ev.wheelY;
          ev.wheelY = 0;
        }
        var editor = this.editor;
        if (!this.$lastScroll)
          this.$lastScroll = {t: 0, vx: 0, vy: 0, allowed: 0};
        var prevScroll = this.$lastScroll;
        var t2 = ev.domEvent.timeStamp;
        var dt = t2 - prevScroll.t;
        var vx = dt ? ev.wheelX / dt : prevScroll.vx;
        var vy = dt ? ev.wheelY / dt : prevScroll.vy;
        if (dt < SCROLL_COOLDOWN_T) {
          vx = (vx + prevScroll.vx) / 2;
          vy = (vy + prevScroll.vy) / 2;
        }
        var direction = Math.abs(vx / vy);
        var canScroll = false;
        if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
          canScroll = true;
        if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
          canScroll = true;
        if (canScroll) {
          prevScroll.allowed = t2;
        } else if (t2 - prevScroll.allowed < SCROLL_COOLDOWN_T) {
          var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx) && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
          if (isSlower) {
            canScroll = true;
            prevScroll.allowed = t2;
          } else {
            prevScroll.allowed = 0;
          }
        }
        prevScroll.t = t2;
        prevScroll.vx = vx;
        prevScroll.vy = vy;
        if (canScroll) {
          editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
          return ev.stop();
        }
      };
    }).call(DefaultHandlers.prototype);
    exports2.DefaultHandlers = DefaultHandlers;
    function calcDistance(ax, ay, bx, by) {
      return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
    }
    function calcRangeOrientation(range, cursor) {
      if (range.start.row == range.end.row)
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
      else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
        var cmp = cursor.column - 4;
      else
        var cmp = 2 * cursor.row - range.start.row - range.end.row;
      if (cmp < 0)
        return {cursor: range.start, anchor: range.end};
      else
        return {cursor: range.end, anchor: range.start};
    }
  });
  ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var dom = require2("./lib/dom");
    function Tooltip(parentNode) {
      this.isOpen = false;
      this.$element = null;
      this.$parentNode = parentNode;
    }
    (function() {
      this.$init = function() {
        this.$element = dom.createElement("div");
        this.$element.className = "ace_tooltip";
        this.$element.style.display = "none";
        this.$parentNode.appendChild(this.$element);
        return this.$element;
      };
      this.getElement = function() {
        return this.$element || this.$init();
      };
      this.setText = function(text) {
        this.getElement().textContent = text;
      };
      this.setHtml = function(html) {
        this.getElement().innerHTML = html;
      };
      this.setPosition = function(x2, y3) {
        this.getElement().style.left = x2 + "px";
        this.getElement().style.top = y3 + "px";
      };
      this.setClassName = function(className) {
        dom.addCssClass(this.getElement(), className);
      };
      this.show = function(text, x2, y3) {
        if (text != null)
          this.setText(text);
        if (x2 != null && y3 != null)
          this.setPosition(x2, y3);
        if (!this.isOpen) {
          this.getElement().style.display = "block";
          this.isOpen = true;
        }
      };
      this.hide = function() {
        if (this.isOpen) {
          this.getElement().style.display = "none";
          this.isOpen = false;
        }
      };
      this.getHeight = function() {
        return this.getElement().offsetHeight;
      };
      this.getWidth = function() {
        return this.getElement().offsetWidth;
      };
      this.destroy = function() {
        this.isOpen = false;
        if (this.$element && this.$element.parentNode) {
          this.$element.parentNode.removeChild(this.$element);
        }
      };
    }).call(Tooltip.prototype);
    exports2.Tooltip = Tooltip;
  });
  ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event", "ace/tooltip"], function(require2, exports2, module2) {
    var dom = require2("../lib/dom");
    var oop = require2("../lib/oop");
    var event = require2("../lib/event");
    var Tooltip = require2("../tooltip").Tooltip;
    function GutterHandler(mouseHandler) {
      var editor = mouseHandler.editor;
      var gutter = editor.renderer.$gutterLayer;
      var tooltip = new GutterTooltip(editor.container);
      mouseHandler.editor.setDefaultHandler("guttermousedown", function(e2) {
        if (!editor.isFocused() || e2.getButton() != 0)
          return;
        var gutterRegion = gutter.getRegion(e2);
        if (gutterRegion == "foldWidgets")
          return;
        var row = e2.getDocumentPosition().row;
        var selection = editor.session.selection;
        if (e2.getShiftKey())
          selection.selectTo(row, 0);
        else {
          if (e2.domEvent.detail == 2) {
            editor.selectAll();
            return e2.preventDefault();
          }
          mouseHandler.$clickSelection = editor.selection.getLineRange(row);
        }
        mouseHandler.setState("selectByLines");
        mouseHandler.captureMouse(e2);
        return e2.preventDefault();
      });
      var tooltipTimeout, mouseEvent, tooltipAnnotation;
      function showTooltip() {
        var row = mouseEvent.getDocumentPosition().row;
        var annotation = gutter.$annotations[row];
        if (!annotation)
          return hideTooltip();
        var maxRow = editor.session.getLength();
        if (row == maxRow) {
          var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
          var pos = mouseEvent.$pos;
          if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
            return hideTooltip();
        }
        if (tooltipAnnotation == annotation)
          return;
        tooltipAnnotation = annotation.text.join("<br/>");
        tooltip.setHtml(tooltipAnnotation);
        tooltip.show();
        editor._signal("showGutterTooltip", tooltip);
        editor.on("mousewheel", hideTooltip);
        if (mouseHandler.$tooltipFollowsMouse) {
          moveTooltip(mouseEvent);
        } else {
          var gutterElement = mouseEvent.domEvent.target;
          var rect = gutterElement.getBoundingClientRect();
          var style = tooltip.getElement().style;
          style.left = rect.right + "px";
          style.top = rect.bottom + "px";
        }
      }
      function hideTooltip() {
        if (tooltipTimeout)
          tooltipTimeout = clearTimeout(tooltipTimeout);
        if (tooltipAnnotation) {
          tooltip.hide();
          tooltipAnnotation = null;
          editor._signal("hideGutterTooltip", tooltip);
          editor.off("mousewheel", hideTooltip);
        }
      }
      function moveTooltip(e2) {
        tooltip.setPosition(e2.x, e2.y);
      }
      mouseHandler.editor.setDefaultHandler("guttermousemove", function(e2) {
        var target = e2.domEvent.target || e2.domEvent.srcElement;
        if (dom.hasCssClass(target, "ace_fold-widget"))
          return hideTooltip();
        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
          moveTooltip(e2);
        mouseEvent = e2;
        if (tooltipTimeout)
          return;
        tooltipTimeout = setTimeout(function() {
          tooltipTimeout = null;
          if (mouseEvent && !mouseHandler.isMousePressed)
            showTooltip();
          else
            hideTooltip();
        }, 50);
      });
      event.addListener(editor.renderer.$gutter, "mouseout", function(e2) {
        mouseEvent = null;
        if (!tooltipAnnotation || tooltipTimeout)
          return;
        tooltipTimeout = setTimeout(function() {
          tooltipTimeout = null;
          hideTooltip();
        }, 50);
      }, editor);
      editor.on("changeSession", hideTooltip);
    }
    function GutterTooltip(parentNode) {
      Tooltip.call(this, parentNode);
    }
    oop.inherits(GutterTooltip, Tooltip);
    (function() {
      this.setPosition = function(x2, y3) {
        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
        var width = this.getWidth();
        var height = this.getHeight();
        x2 += 15;
        y3 += 15;
        if (x2 + width > windowWidth) {
          x2 -= x2 + width - windowWidth;
        }
        if (y3 + height > windowHeight) {
          y3 -= 20 + height;
        }
        Tooltip.prototype.setPosition.call(this, x2, y3);
      };
    }).call(GutterTooltip.prototype);
    exports2.GutterHandler = GutterHandler;
  });
  ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require2, exports2, module2) {
    var event = require2("../lib/event");
    var useragent = require2("../lib/useragent");
    var MouseEvent = exports2.MouseEvent = function(domEvent, editor) {
      this.domEvent = domEvent;
      this.editor = editor;
      this.x = this.clientX = domEvent.clientX;
      this.y = this.clientY = domEvent.clientY;
      this.$pos = null;
      this.$inSelection = null;
      this.propagationStopped = false;
      this.defaultPrevented = false;
    };
    (function() {
      this.stopPropagation = function() {
        event.stopPropagation(this.domEvent);
        this.propagationStopped = true;
      };
      this.preventDefault = function() {
        event.preventDefault(this.domEvent);
        this.defaultPrevented = true;
      };
      this.stop = function() {
        this.stopPropagation();
        this.preventDefault();
      };
      this.getDocumentPosition = function() {
        if (this.$pos)
          return this.$pos;
        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        return this.$pos;
      };
      this.inSelection = function() {
        if (this.$inSelection !== null)
          return this.$inSelection;
        var editor = this.editor;
        var selectionRange = editor.getSelectionRange();
        if (selectionRange.isEmpty())
          this.$inSelection = false;
        else {
          var pos = this.getDocumentPosition();
          this.$inSelection = selectionRange.contains(pos.row, pos.column);
        }
        return this.$inSelection;
      };
      this.getButton = function() {
        return event.getButton(this.domEvent);
      };
      this.getShiftKey = function() {
        return this.domEvent.shiftKey;
      };
      this.getAccelKey = useragent.isMac ? function() {
        return this.domEvent.metaKey;
      } : function() {
        return this.domEvent.ctrlKey;
      };
    }).call(MouseEvent.prototype);
  });
  ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(require2, exports2, module2) {
    var dom = require2("../lib/dom");
    var event = require2("../lib/event");
    var useragent = require2("../lib/useragent");
    var AUTOSCROLL_DELAY = 200;
    var SCROLL_CURSOR_DELAY = 200;
    var SCROLL_CURSOR_HYSTERESIS = 5;
    function DragdropHandler(mouseHandler) {
      var editor = mouseHandler.editor;
      var blankImage = dom.createElement("img");
      blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (useragent.isOpera)
        blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";
      var exports3 = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
      exports3.forEach(function(x3) {
        mouseHandler[x3] = this[x3];
      }, this);
      editor.on("mousedown", this.onMouseDown.bind(mouseHandler));
      var mouseTarget = editor.container;
      var dragSelectionMarker, x2, y3;
      var timerId, range;
      var dragCursor, counter = 0;
      var dragOperation;
      var isInternal;
      var autoScrollStartTime;
      var cursorMovedTime;
      var cursorPointOnCaretMoved;
      this.onDragStart = function(e2) {
        if (this.cancelDrag || !mouseTarget.draggable) {
          var self2 = this;
          setTimeout(function() {
            self2.startSelect();
            self2.captureMouse(e2);
          }, 0);
          return e2.preventDefault();
        }
        range = editor.getSelectionRange();
        var dataTransfer = e2.dataTransfer;
        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
        if (useragent.isOpera) {
          editor.container.appendChild(blankImage);
          blankImage.scrollTop = 0;
        }
        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
        if (useragent.isOpera) {
          editor.container.removeChild(blankImage);
        }
        dataTransfer.clearData();
        dataTransfer.setData("Text", editor.session.getTextRange());
        isInternal = true;
        this.setState("drag");
      };
      this.onDragEnd = function(e2) {
        mouseTarget.draggable = false;
        isInternal = false;
        this.setState(null);
        if (!editor.getReadOnly()) {
          var dropEffect = e2.dataTransfer.dropEffect;
          if (!dragOperation && dropEffect == "move")
            editor.session.remove(editor.getSelectionRange());
          editor.$resetCursorStyle();
        }
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
      };
      this.onDragEnter = function(e2) {
        if (editor.getReadOnly() || !canAccept(e2.dataTransfer))
          return;
        x2 = e2.clientX;
        y3 = e2.clientY;
        if (!dragSelectionMarker)
          addDragMarker();
        counter++;
        e2.dataTransfer.dropEffect = dragOperation = getDropEffect(e2);
        return event.preventDefault(e2);
      };
      this.onDragOver = function(e2) {
        if (editor.getReadOnly() || !canAccept(e2.dataTransfer))
          return;
        x2 = e2.clientX;
        y3 = e2.clientY;
        if (!dragSelectionMarker) {
          addDragMarker();
          counter++;
        }
        if (onMouseMoveTimer !== null)
          onMouseMoveTimer = null;
        e2.dataTransfer.dropEffect = dragOperation = getDropEffect(e2);
        return event.preventDefault(e2);
      };
      this.onDragLeave = function(e2) {
        counter--;
        if (counter <= 0 && dragSelectionMarker) {
          clearDragMarker();
          dragOperation = null;
          return event.preventDefault(e2);
        }
      };
      this.onDrop = function(e2) {
        if (!dragCursor)
          return;
        var dataTransfer = e2.dataTransfer;
        if (isInternal) {
          switch (dragOperation) {
            case "move":
              if (range.contains(dragCursor.row, dragCursor.column)) {
                range = {
                  start: dragCursor,
                  end: dragCursor
                };
              } else {
                range = editor.moveText(range, dragCursor);
              }
              break;
            case "copy":
              range = editor.moveText(range, dragCursor, true);
              break;
          }
        } else {
          var dropData = dataTransfer.getData("Text");
          range = {
            start: dragCursor,
            end: editor.session.insert(dragCursor, dropData)
          };
          editor.focus();
          dragOperation = null;
        }
        clearDragMarker();
        return event.preventDefault(e2);
      };
      event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor);
      event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor);
      event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor);
      event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor);
      event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor);
      event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor);
      function scrollCursorIntoView(cursor, prevCursor) {
        var now = Date.now();
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        var hMovement = !prevCursor || cursor.column != prevCursor.column;
        if (!cursorMovedTime || vMovement || hMovement) {
          editor.moveCursorToPosition(cursor);
          cursorMovedTime = now;
          cursorPointOnCaretMoved = {x: x2, y: y3};
        } else {
          var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x2, y3);
          if (distance > SCROLL_CURSOR_HYSTERESIS) {
            cursorMovedTime = null;
          } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
            editor.renderer.scrollCursorIntoView();
            cursorMovedTime = null;
          }
        }
      }
      function autoScroll(cursor, prevCursor) {
        var now = Date.now();
        var lineHeight = editor.renderer.layerConfig.lineHeight;
        var characterWidth = editor.renderer.layerConfig.characterWidth;
        var editorRect = editor.renderer.scroller.getBoundingClientRect();
        var offsets = {
          x: {
            left: x2 - editorRect.left,
            right: editorRect.right - x2
          },
          y: {
            top: y3 - editorRect.top,
            bottom: editorRect.bottom - y3
          }
        };
        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
        var scrollCursor = {row: cursor.row, column: cursor.column};
        if (nearestXOffset / characterWidth <= 2) {
          scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : 2;
        }
        if (nearestYOffset / lineHeight <= 1) {
          scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : 1;
        }
        var vScroll = cursor.row != scrollCursor.row;
        var hScroll = cursor.column != scrollCursor.column;
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        if (vScroll || hScroll && !vMovement) {
          if (!autoScrollStartTime)
            autoScrollStartTime = now;
          else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
            editor.renderer.scrollCursorIntoView(scrollCursor);
        } else {
          autoScrollStartTime = null;
        }
      }
      function onDragInterval() {
        var prevCursor = dragCursor;
        dragCursor = editor.renderer.screenToTextCoordinates(x2, y3);
        scrollCursorIntoView(dragCursor, prevCursor);
        autoScroll(dragCursor, prevCursor);
      }
      function addDragMarker() {
        range = editor.selection.toOrientedRange();
        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
        editor.clearSelection();
        if (editor.isFocused())
          editor.renderer.$cursorLayer.setBlinking(false);
        clearInterval(timerId);
        onDragInterval();
        timerId = setInterval(onDragInterval, 20);
        counter = 0;
        event.addListener(document, "mousemove", onMouseMove);
      }
      function clearDragMarker() {
        clearInterval(timerId);
        editor.session.removeMarker(dragSelectionMarker);
        dragSelectionMarker = null;
        editor.selection.fromOrientedRange(range);
        if (editor.isFocused() && !isInternal)
          editor.$resetCursorStyle();
        range = null;
        dragCursor = null;
        counter = 0;
        autoScrollStartTime = null;
        cursorMovedTime = null;
        event.removeListener(document, "mousemove", onMouseMove);
      }
      var onMouseMoveTimer = null;
      function onMouseMove() {
        if (onMouseMoveTimer == null) {
          onMouseMoveTimer = setTimeout(function() {
            if (onMouseMoveTimer != null && dragSelectionMarker)
              clearDragMarker();
          }, 20);
        }
      }
      function canAccept(dataTransfer) {
        var types2 = dataTransfer.types;
        return !types2 || Array.prototype.some.call(types2, function(type2) {
          return type2 == "text/plain" || type2 == "Text";
        });
      }
      function getDropEffect(e2) {
        var copyAllowed = ["copy", "copymove", "all", "uninitialized"];
        var moveAllowed = ["move", "copymove", "linkmove", "all", "uninitialized"];
        var copyModifierState = useragent.isMac ? e2.altKey : e2.ctrlKey;
        var effectAllowed = "uninitialized";
        try {
          effectAllowed = e2.dataTransfer.effectAllowed.toLowerCase();
        } catch (e3) {
        }
        var dropEffect = "none";
        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
          dropEffect = "copy";
        else if (moveAllowed.indexOf(effectAllowed) >= 0)
          dropEffect = "move";
        else if (copyAllowed.indexOf(effectAllowed) >= 0)
          dropEffect = "copy";
        return dropEffect;
      }
    }
    (function() {
      this.dragWait = function() {
        var interval = Date.now() - this.mousedownEvent.time;
        if (interval > this.editor.getDragDelay())
          this.startDrag();
      };
      this.dragWaitEnd = function() {
        var target = this.editor.container;
        target.draggable = false;
        this.startSelect(this.mousedownEvent.getDocumentPosition());
        this.selectEnd();
      };
      this.dragReadyEnd = function(e2) {
        this.editor.$resetCursorStyle();
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
        this.dragWaitEnd();
      };
      this.startDrag = function() {
        this.cancelDrag = false;
        var editor = this.editor;
        var target = editor.container;
        target.draggable = true;
        editor.renderer.$cursorLayer.setBlinking(false);
        editor.setStyle("ace_dragging");
        var cursorStyle = useragent.isWin ? "default" : "move";
        editor.renderer.setCursorStyle(cursorStyle);
        this.setState("dragReady");
      };
      this.onMouseDrag = function(e2) {
        var target = this.editor.container;
        if (useragent.isIE && this.state == "dragReady") {
          var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
          if (distance > 3)
            target.dragDrop();
        }
        if (this.state === "dragWait") {
          var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
          if (distance > 0) {
            target.draggable = false;
            this.startSelect(this.mousedownEvent.getDocumentPosition());
          }
        }
      };
      this.onMouseDown = function(e2) {
        if (!this.$dragEnabled)
          return;
        this.mousedownEvent = e2;
        var editor = this.editor;
        var inSelection = e2.inSelection();
        var button = e2.getButton();
        var clickCount = e2.domEvent.detail || 1;
        if (clickCount === 1 && button === 0 && inSelection) {
          if (e2.editor.inMultiSelectMode && (e2.getAccelKey() || e2.getShiftKey()))
            return;
          this.mousedownEvent.time = Date.now();
          var eventTarget = e2.domEvent.target || e2.domEvent.srcElement;
          if ("unselectable" in eventTarget)
            eventTarget.unselectable = "on";
          if (editor.getDragDelay()) {
            if (useragent.isWebKit) {
              this.cancelDrag = true;
              var mouseTarget = editor.container;
              mouseTarget.draggable = true;
            }
            this.setState("dragWait");
          } else {
            this.startDrag();
          }
          this.captureMouse(e2, this.onMouseDrag.bind(this));
          e2.defaultPrevented = true;
        }
      };
    }).call(DragdropHandler.prototype);
    function calcDistance(ax, ay, bx, by) {
      return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
    }
    exports2.DragdropHandler = DragdropHandler;
  });
  ace.define("ace/mouse/touch_handler", ["require", "exports", "module", "ace/mouse/mouse_event", "ace/lib/event", "ace/lib/dom"], function(require2, exports2, module2) {
    var MouseEvent = require2("./mouse_event").MouseEvent;
    var event = require2("../lib/event");
    var dom = require2("../lib/dom");
    exports2.addTouchListeners = function(el, editor) {
      var mode = "scroll";
      var startX;
      var startY;
      var touchStartT;
      var lastT;
      var longTouchTimer;
      var animationTimer;
      var animationSteps = 0;
      var pos;
      var clickCount = 0;
      var vX = 0;
      var vY = 0;
      var pressed;
      var contextMenu;
      function createContextMenu() {
        var clipboard = window.navigator && window.navigator.clipboard;
        var isOpen = false;
        var updateMenu = function() {
          var selected = editor.getCopyText();
          var hasUndo = editor.session.getUndoManager().hasUndo();
          contextMenu.replaceChild(dom.buildDom(isOpen ? [
            "span",
            !selected && ["span", {class: "ace_mobile-button", action: "selectall"}, "Select All"],
            selected && ["span", {class: "ace_mobile-button", action: "copy"}, "Copy"],
            selected && ["span", {class: "ace_mobile-button", action: "cut"}, "Cut"],
            clipboard && ["span", {class: "ace_mobile-button", action: "paste"}, "Paste"],
            hasUndo && ["span", {class: "ace_mobile-button", action: "undo"}, "Undo"],
            ["span", {class: "ace_mobile-button", action: "find"}, "Find"],
            ["span", {class: "ace_mobile-button", action: "openCommandPallete"}, "Pallete"]
          ] : ["span"]), contextMenu.firstChild);
        };
        var handleClick = function(e2) {
          var action = e2.target.getAttribute("action");
          if (action == "more" || !isOpen) {
            isOpen = !isOpen;
            return updateMenu();
          }
          if (action == "paste") {
            clipboard.readText().then(function(text) {
              editor.execCommand(action, text);
            });
          } else if (action) {
            if (action == "cut" || action == "copy") {
              if (clipboard)
                clipboard.writeText(editor.getCopyText());
              else
                document.execCommand("copy");
            }
            editor.execCommand(action);
          }
          contextMenu.firstChild.style.display = "none";
          isOpen = false;
          if (action != "openCommandPallete")
            editor.focus();
        };
        contextMenu = dom.buildDom([
          "div",
          {
            class: "ace_mobile-menu",
            ontouchstart: function(e2) {
              mode = "menu";
              e2.stopPropagation();
              e2.preventDefault();
              editor.textInput.focus();
            },
            ontouchend: function(e2) {
              e2.stopPropagation();
              e2.preventDefault();
              handleClick(e2);
            },
            onclick: handleClick
          },
          ["span"],
          ["span", {class: "ace_mobile-button", action: "more"}, "..."]
        ], editor.container);
      }
      function showContextMenu() {
        if (!contextMenu)
          createContextMenu();
        var cursor = editor.selection.cursor;
        var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
        var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;
        var scrollLeft = editor.renderer.scrollLeft;
        var rect = editor.container.getBoundingClientRect();
        contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
        if (pagePos.pageX - rect.left < rect.width - 70) {
          contextMenu.style.left = "";
          contextMenu.style.right = "10px";
        } else {
          contextMenu.style.right = "";
          contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
        }
        contextMenu.style.display = "";
        contextMenu.firstChild.style.display = "none";
        editor.on("input", hideContextMenu);
      }
      function hideContextMenu(e2) {
        if (contextMenu)
          contextMenu.style.display = "none";
        editor.off("input", hideContextMenu);
      }
      function handleLongTap() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        var range = editor.selection.getRange();
        var inSelection = range.contains(pos.row, pos.column);
        if (range.isEmpty() || !inSelection) {
          editor.selection.moveToPosition(pos);
          editor.selection.selectWord();
        }
        mode = "wait";
        showContextMenu();
      }
      function switchToSelectionMode() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        editor.selection.moveToPosition(pos);
        var range = clickCount >= 2 ? editor.selection.getLineRange(pos.row) : editor.session.getBracketRange(pos);
        if (range && !range.isEmpty()) {
          editor.selection.setRange(range);
        } else {
          editor.selection.selectWord();
        }
        mode = "wait";
      }
      event.addListener(el, "contextmenu", function(e2) {
        if (!pressed)
          return;
        var textarea = editor.textInput.getElement();
        textarea.focus();
      }, editor);
      event.addListener(el, "touchstart", function(e2) {
        var touches = e2.touches;
        if (longTouchTimer || touches.length > 1) {
          clearTimeout(longTouchTimer);
          longTouchTimer = null;
          touchStartT = -1;
          mode = "zoom";
          return;
        }
        pressed = editor.$mouseHandler.isMousePressed = true;
        var h2 = editor.renderer.layerConfig.lineHeight;
        var w2 = editor.renderer.layerConfig.lineHeight;
        var t2 = e2.timeStamp;
        lastT = t2;
        var touchObj = touches[0];
        var x2 = touchObj.clientX;
        var y3 = touchObj.clientY;
        if (Math.abs(startX - x2) + Math.abs(startY - y3) > h2)
          touchStartT = -1;
        startX = e2.clientX = x2;
        startY = e2.clientY = y3;
        vX = vY = 0;
        var ev = new MouseEvent(e2, editor);
        pos = ev.getDocumentPosition();
        if (t2 - touchStartT < 500 && touches.length == 1 && !animationSteps) {
          clickCount++;
          e2.preventDefault();
          e2.button = 0;
          switchToSelectionMode();
        } else {
          clickCount = 0;
          var cursor = editor.selection.cursor;
          var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
          var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
          var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
          var rect = editor.renderer.scroller.getBoundingClientRect();
          var offsetTop = editor.renderer.layerConfig.offset;
          var offsetLeft = editor.renderer.scrollLeft;
          var weightedDistance = function(x3, y4) {
            x3 = x3 / w2;
            y4 = y4 / h2 - 0.75;
            return x3 * x3 + y4 * y4;
          };
          if (e2.clientX < rect.left) {
            mode = "zoom";
            return;
          }
          var diff1 = weightedDistance(e2.clientX - rect.left - cursorPos.left + offsetLeft, e2.clientY - rect.top - cursorPos.top + offsetTop);
          var diff2 = weightedDistance(e2.clientX - rect.left - anchorPos.left + offsetLeft, e2.clientY - rect.top - anchorPos.top + offsetTop);
          if (diff1 < 3.5 && diff2 < 3.5)
            mode = diff1 > diff2 ? "cursor" : "anchor";
          if (diff2 < 3.5)
            mode = "anchor";
          else if (diff1 < 3.5)
            mode = "cursor";
          else
            mode = "scroll";
          longTouchTimer = setTimeout(handleLongTap, 450);
        }
        touchStartT = t2;
      }, editor);
      event.addListener(el, "touchend", function(e2) {
        pressed = editor.$mouseHandler.isMousePressed = false;
        if (animationTimer)
          clearInterval(animationTimer);
        if (mode == "zoom") {
          mode = "";
          animationSteps = 0;
        } else if (longTouchTimer) {
          editor.selection.moveToPosition(pos);
          animationSteps = 0;
          showContextMenu();
        } else if (mode == "scroll") {
          animate();
          hideContextMenu();
        } else {
          showContextMenu();
        }
        clearTimeout(longTouchTimer);
        longTouchTimer = null;
      }, editor);
      event.addListener(el, "touchmove", function(e2) {
        if (longTouchTimer) {
          clearTimeout(longTouchTimer);
          longTouchTimer = null;
        }
        var touches = e2.touches;
        if (touches.length > 1 || mode == "zoom")
          return;
        var touchObj = touches[0];
        var wheelX = startX - touchObj.clientX;
        var wheelY = startY - touchObj.clientY;
        if (mode == "wait") {
          if (wheelX * wheelX + wheelY * wheelY > 4)
            mode = "cursor";
          else
            return e2.preventDefault();
        }
        startX = touchObj.clientX;
        startY = touchObj.clientY;
        e2.clientX = touchObj.clientX;
        e2.clientY = touchObj.clientY;
        var t2 = e2.timeStamp;
        var dt = t2 - lastT;
        lastT = t2;
        if (mode == "scroll") {
          var mouseEvent = new MouseEvent(e2, editor);
          mouseEvent.speed = 1;
          mouseEvent.wheelX = wheelX;
          mouseEvent.wheelY = wheelY;
          if (10 * Math.abs(wheelX) < Math.abs(wheelY))
            wheelX = 0;
          if (10 * Math.abs(wheelY) < Math.abs(wheelX))
            wheelY = 0;
          if (dt != 0) {
            vX = wheelX / dt;
            vY = wheelY / dt;
          }
          editor._emit("mousewheel", mouseEvent);
          if (!mouseEvent.propagationStopped) {
            vX = vY = 0;
          }
        } else {
          var ev = new MouseEvent(e2, editor);
          var pos2 = ev.getDocumentPosition();
          if (mode == "cursor")
            editor.selection.moveCursorToPosition(pos2);
          else if (mode == "anchor")
            editor.selection.setSelectionAnchor(pos2.row, pos2.column);
          editor.renderer.scrollCursorIntoView(pos2);
          e2.preventDefault();
        }
      }, editor);
      function animate() {
        animationSteps += 60;
        animationTimer = setInterval(function() {
          if (animationSteps-- <= 0) {
            clearInterval(animationTimer);
            animationTimer = null;
          }
          if (Math.abs(vX) < 0.01)
            vX = 0;
          if (Math.abs(vY) < 0.01)
            vY = 0;
          if (animationSteps < 20)
            vX = 0.9 * vX;
          if (animationSteps < 20)
            vY = 0.9 * vY;
          var oldScrollTop = editor.session.getScrollTop();
          editor.renderer.scrollBy(10 * vX, 10 * vY);
          if (oldScrollTop == editor.session.getScrollTop())
            animationSteps = 0;
        }, 10);
      }
    };
  });
  ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
    var dom = require2("./dom");
    exports2.get = function(url, callback) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          callback(xhr.responseText);
        }
      };
      xhr.send(null);
    };
    exports2.loadScript = function(path, callback) {
      var head = dom.getDocumentHead();
      var s = document.createElement("script");
      s.src = path;
      head.appendChild(s);
      s.onload = s.onreadystatechange = function(_, isAbort) {
        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
          s = s.onload = s.onreadystatechange = null;
          if (!isAbort)
            callback();
        }
      };
    };
    exports2.qualifyURL = function(url) {
      var a = document.createElement("a");
      a.href = url;
      return a.href;
    };
  });
  ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function(require2, exports2, module2) {
    var EventEmitter = {};
    var stopPropagation = function() {
      this.propagationStopped = true;
    };
    var preventDefault = function() {
      this.defaultPrevented = true;
    };
    EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e2) {
      this._eventRegistry || (this._eventRegistry = {});
      this._defaultHandlers || (this._defaultHandlers = {});
      var listeners = this._eventRegistry[eventName] || [];
      var defaultHandler = this._defaultHandlers[eventName];
      if (!listeners.length && !defaultHandler)
        return;
      if (typeof e2 != "object" || !e2)
        e2 = {};
      if (!e2.type)
        e2.type = eventName;
      if (!e2.stopPropagation)
        e2.stopPropagation = stopPropagation;
      if (!e2.preventDefault)
        e2.preventDefault = preventDefault;
      listeners = listeners.slice();
      for (var i = 0; i < listeners.length; i++) {
        listeners[i](e2, this);
        if (e2.propagationStopped)
          break;
      }
      if (defaultHandler && !e2.defaultPrevented)
        return defaultHandler(e2, this);
    };
    EventEmitter._signal = function(eventName, e2) {
      var listeners = (this._eventRegistry || {})[eventName];
      if (!listeners)
        return;
      listeners = listeners.slice();
      for (var i = 0; i < listeners.length; i++)
        listeners[i](e2, this);
    };
    EventEmitter.once = function(eventName, callback) {
      var _self = this;
      this.on(eventName, function newCallback() {
        _self.off(eventName, newCallback);
        callback.apply(null, arguments);
      });
      if (!callback) {
        return new Promise(function(resolve) {
          callback = resolve;
        });
      }
    };
    EventEmitter.setDefaultHandler = function(eventName, callback) {
      var handlers = this._defaultHandlers;
      if (!handlers)
        handlers = this._defaultHandlers = {_disabled_: {}};
      if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
          handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1)
          disabled.splice(i, 1);
      }
      handlers[eventName] = callback;
    };
    EventEmitter.removeDefaultHandler = function(eventName, callback) {
      var handlers = this._defaultHandlers;
      if (!handlers)
        return;
      var disabled = handlers._disabled_[eventName];
      if (handlers[eventName] == callback) {
        if (disabled)
          this.setDefaultHandler(eventName, disabled.pop());
      } else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
          disabled.splice(i, 1);
      }
    };
    EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
      this._eventRegistry = this._eventRegistry || {};
      var listeners = this._eventRegistry[eventName];
      if (!listeners)
        listeners = this._eventRegistry[eventName] = [];
      if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
      return callback;
    };
    EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
      this._eventRegistry = this._eventRegistry || {};
      var listeners = this._eventRegistry[eventName];
      if (!listeners)
        return;
      var index2 = listeners.indexOf(callback);
      if (index2 !== -1)
        listeners.splice(index2, 1);
    };
    EventEmitter.removeAllListeners = function(eventName) {
      if (!eventName)
        this._eventRegistry = this._defaultHandlers = void 0;
      if (this._eventRegistry)
        this._eventRegistry[eventName] = void 0;
      if (this._defaultHandlers)
        this._defaultHandlers[eventName] = void 0;
    };
    exports2.EventEmitter = EventEmitter;
  });
  ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    "no use strict";
    var oop = require2("./oop");
    var EventEmitter = require2("./event_emitter").EventEmitter;
    var optionsProvider = {
      setOptions: function(optList) {
        Object.keys(optList).forEach(function(key) {
          this.setOption(key, optList[key]);
        }, this);
      },
      getOptions: function(optionNames) {
        var result = {};
        if (!optionNames) {
          var options = this.$options;
          optionNames = Object.keys(options).filter(function(key) {
            return !options[key].hidden;
          });
        } else if (!Array.isArray(optionNames)) {
          result = optionNames;
          optionNames = Object.keys(result);
        }
        optionNames.forEach(function(key) {
          result[key] = this.getOption(key);
        }, this);
        return result;
      },
      setOption: function(name, value) {
        if (this["$" + name] === value)
          return;
        var opt = this.$options[name];
        if (!opt) {
          return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
          return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
        if (!opt.handlesSet)
          this["$" + name] = value;
        if (opt && opt.set)
          opt.set.call(this, value);
      },
      getOption: function(name) {
        var opt = this.$options[name];
        if (!opt) {
          return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
          return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
        return opt && opt.get ? opt.get.call(this) : this["$" + name];
      }
    };
    function warn(message) {
      if (typeof console != "undefined" && console.warn)
        console.warn.apply(console, arguments);
    }
    function reportError(msg, data) {
      var e2 = new Error(msg);
      e2.data = data;
      if (typeof console == "object" && console.error)
        console.error(e2);
      setTimeout(function() {
        throw e2;
      });
    }
    var AppConfig = function() {
      this.$defaultOptions = {};
    };
    (function() {
      oop.implement(this, EventEmitter);
      this.defineOptions = function(obj, path, options) {
        if (!obj.$options)
          this.$defaultOptions[path] = obj.$options = {};
        Object.keys(options).forEach(function(key) {
          var opt = options[key];
          if (typeof opt == "string")
            opt = {forwardTo: opt};
          opt.name || (opt.name = key);
          obj.$options[opt.name] = opt;
          if ("initialValue" in opt)
            obj["$" + opt.name] = opt.initialValue;
        });
        oop.implement(obj, optionsProvider);
        return this;
      };
      this.resetOptions = function(obj) {
        Object.keys(obj.$options).forEach(function(key) {
          var opt = obj.$options[key];
          if ("value" in opt)
            obj.setOption(key, opt.value);
        });
      };
      this.setDefaultValue = function(path, name, value) {
        if (!path) {
          for (path in this.$defaultOptions)
            if (this.$defaultOptions[path][name])
              break;
          if (!this.$defaultOptions[path][name])
            return false;
        }
        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
        if (opts[name]) {
          if (opts.forwardTo)
            this.setDefaultValue(opts.forwardTo, name, value);
          else
            opts[name].value = value;
        }
      };
      this.setDefaultValues = function(path, optionHash) {
        Object.keys(optionHash).forEach(function(key) {
          this.setDefaultValue(path, key, optionHash[key]);
        }, this);
      };
      this.warn = warn;
      this.reportError = reportError;
    }).call(AppConfig.prototype);
    exports2.AppConfig = AppConfig;
  });
  ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/lib/net", "ace/lib/app_config"], function(require2, exports2, module2) {
    "no use strict";
    var lang = require2("./lib/lang");
    var oop = require2("./lib/oop");
    var net = require2("./lib/net");
    var AppConfig = require2("./lib/app_config").AppConfig;
    module2.exports = exports2 = new AppConfig();
    var global2 = function() {
      return this || typeof window != "undefined" && window;
    }();
    var options = {
      packaged: false,
      workerPath: null,
      modePath: null,
      themePath: null,
      basePath: "",
      suffix: ".js",
      $moduleUrls: {},
      loadWorkerFromBlob: true,
      sharedPopups: false
    };
    exports2.get = function(key) {
      if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);
      return options[key];
    };
    exports2.set = function(key, value) {
      if (options.hasOwnProperty(key))
        options[key] = value;
      else if (this.setDefaultValue("", key, value) == false)
        throw new Error("Unknown config key: " + key);
    };
    exports2.all = function() {
      return lang.copyObject(options);
    };
    exports2.$modes = {};
    exports2.moduleUrl = function(name, component) {
      if (options.$moduleUrls[name])
        return options.$moduleUrls[name];
      var parts = name.split("/");
      component = component || parts[parts.length - 2] || "";
      var sep = component == "snippets" ? "/" : "-";
      var base = parts[parts.length - 1];
      if (component == "worker" && sep == "-") {
        var re2 = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
        base = base.replace(re2, "");
      }
      if ((!base || base == component) && parts.length > 1)
        base = parts[parts.length - 2];
      var path = options[component + "Path"];
      if (path == null) {
        path = options.basePath;
      } else if (sep == "/") {
        component = sep = "";
      }
      if (path && path.slice(-1) != "/")
        path += "/";
      return path + component + sep + base + this.get("suffix");
    };
    exports2.setModuleUrl = function(name, subst) {
      return options.$moduleUrls[name] = subst;
    };
    exports2.$loading = {};
    exports2.loadModule = function(moduleName, onLoad) {
      var module3, moduleType;
      if (Array.isArray(moduleName)) {
        moduleType = moduleName[0];
        moduleName = moduleName[1];
      }
      try {
        module3 = require2(moduleName);
      } catch (e2) {
      }
      if (module3 && !exports2.$loading[moduleName])
        return onLoad && onLoad(module3);
      if (!exports2.$loading[moduleName])
        exports2.$loading[moduleName] = [];
      exports2.$loading[moduleName].push(onLoad);
      if (exports2.$loading[moduleName].length > 1)
        return;
      var afterLoad = function() {
        require2([moduleName], function(module4) {
          exports2._emit("load.module", {name: moduleName, module: module4});
          var listeners = exports2.$loading[moduleName];
          exports2.$loading[moduleName] = null;
          listeners.forEach(function(onLoad2) {
            onLoad2 && onLoad2(module4);
          });
        });
      };
      if (!exports2.get("packaged"))
        return afterLoad();
      net.loadScript(exports2.moduleUrl(moduleName, moduleType), afterLoad);
      reportErrorIfPathIsNotConfigured();
    };
    var reportErrorIfPathIsNotConfigured = function() {
      if (!options.basePath && !options.workerPath && !options.modePath && !options.themePath && !Object.keys(options.$moduleUrls).length) {
        console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver");
        reportErrorIfPathIsNotConfigured = function() {
        };
      }
    };
    init(true);
    function init(packaged) {
      if (!global2 || !global2.document)
        return;
      options.packaged = packaged || require2.packaged || module2.packaged || global2.define && (void 0).packaged;
      var scriptOptions = {};
      var scriptUrl = "";
      var currentScript = document.currentScript || document._currentScript;
      var currentDocument = currentScript && currentScript.ownerDocument || document;
      var scripts = currentDocument.getElementsByTagName("script");
      for (var i = 0; i < scripts.length; i++) {
        var script = scripts[i];
        var src = script.src || script.getAttribute("src");
        if (!src)
          continue;
        var attributes = script.attributes;
        for (var j = 0, l2 = attributes.length; j < l2; j++) {
          var attr = attributes[j];
          if (attr.name.indexOf("data-ace-") === 0) {
            scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
          }
        }
        var m2 = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
        if (m2)
          scriptUrl = m2[1];
      }
      if (scriptUrl) {
        scriptOptions.base = scriptOptions.base || scriptUrl;
        scriptOptions.packaged = true;
      }
      scriptOptions.basePath = scriptOptions.base;
      scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
      scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
      scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
      delete scriptOptions.base;
      for (var key in scriptOptions)
        if (typeof scriptOptions[key] !== "undefined")
          exports2.set(key, scriptOptions[key]);
    }
    exports2.init = init;
    function deHyphenate(str2) {
      return str2.replace(/-(.)/g, function(m2, m1) {
        return m1.toUpperCase();
      });
    }
    exports2.version = "1.4.12";
  });
  ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/mouse/touch_handler", "ace/config"], function(require2, exports2, module2) {
    var event = require2("../lib/event");
    var useragent = require2("../lib/useragent");
    var DefaultHandlers = require2("./default_handlers").DefaultHandlers;
    var DefaultGutterHandler = require2("./default_gutter_handler").GutterHandler;
    var MouseEvent = require2("./mouse_event").MouseEvent;
    var DragdropHandler = require2("./dragdrop_handler").DragdropHandler;
    var addTouchListeners = require2("./touch_handler").addTouchListeners;
    var config = require2("../config");
    var MouseHandler = function(editor) {
      var _self = this;
      this.editor = editor;
      new DefaultHandlers(this);
      new DefaultGutterHandler(this);
      new DragdropHandler(this);
      var focusEditor = function(e2) {
        var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
        if (windowBlurred)
          window.focus();
        editor.focus();
      };
      var mouseTarget = editor.renderer.getMouseEventTarget();
      event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor);
      event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor);
      event.addMultiMouseDownListener([
        mouseTarget,
        editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
        editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
        editor.textInput && editor.textInput.getElement()
      ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", editor);
      event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"), editor);
      addTouchListeners(editor.container, editor);
      var gutterEl = editor.renderer.$gutter;
      event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor);
      event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor);
      event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor);
      event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor);
      event.addListener(mouseTarget, "mousedown", focusEditor, editor);
      event.addListener(gutterEl, "mousedown", focusEditor, editor);
      if (useragent.isIE && editor.renderer.scrollBarV) {
        event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor, editor);
        event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor, editor);
      }
      editor.on("mousemove", function(e2) {
        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
          return;
        var character = editor.renderer.screenToTextCoordinates(e2.x, e2.y);
        var range = editor.session.selection.getRange();
        var renderer = editor.renderer;
        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
          renderer.setCursorStyle("default");
        } else {
          renderer.setCursorStyle("");
        }
      }, editor);
    };
    (function() {
      this.onMouseEvent = function(name, e2) {
        this.editor._emit(name, new MouseEvent(e2, this.editor));
      };
      this.onMouseMove = function(name, e2) {
        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
        if (!listeners || !listeners.length)
          return;
        this.editor._emit(name, new MouseEvent(e2, this.editor));
      };
      this.onMouseWheel = function(name, e2) {
        var mouseEvent = new MouseEvent(e2, this.editor);
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e2.wheelX;
        mouseEvent.wheelY = e2.wheelY;
        this.editor._emit(name, mouseEvent);
      };
      this.setState = function(state) {
        this.state = state;
      };
      this.captureMouse = function(ev, mouseMoveHandler) {
        this.x = ev.x;
        this.y = ev.y;
        this.isMousePressed = true;
        var editor = this.editor;
        var renderer = this.editor.renderer;
        renderer.$isMousePressed = true;
        var self2 = this;
        var onMouseMove = function(e2) {
          if (!e2)
            return;
          if (useragent.isWebKit && !e2.which && self2.releaseMouse)
            return self2.releaseMouse();
          self2.x = e2.clientX;
          self2.y = e2.clientY;
          mouseMoveHandler && mouseMoveHandler(e2);
          self2.mouseEvent = new MouseEvent(e2, self2.editor);
          self2.$mouseMoved = true;
        };
        var onCaptureEnd = function(e2) {
          editor.off("beforeEndOperation", onOperationEnd);
          clearInterval(timerId);
          onCaptureInterval();
          self2[self2.state + "End"] && self2[self2.state + "End"](e2);
          self2.state = "";
          self2.isMousePressed = renderer.$isMousePressed = false;
          if (renderer.$keepTextAreaAtCursor)
            renderer.$moveTextAreaToCursor();
          self2.$onCaptureMouseMove = self2.releaseMouse = null;
          e2 && self2.onMouseEvent("mouseup", e2);
          editor.endOperation();
        };
        var onCaptureInterval = function() {
          self2[self2.state] && self2[self2.state]();
          self2.$mouseMoved = false;
        };
        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
          return setTimeout(function() {
            onCaptureEnd(ev);
          });
        }
        var onOperationEnd = function(e2) {
          if (!self2.releaseMouse)
            return;
          if (editor.curOp.command.name && editor.curOp.selectionChanged) {
            self2[self2.state + "End"] && self2[self2.state + "End"]();
            self2.state = "";
            self2.releaseMouse();
          }
        };
        editor.on("beforeEndOperation", onOperationEnd);
        editor.startOperation({command: {name: "mouse"}});
        self2.$onCaptureMouseMove = onMouseMove;
        self2.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
        var timerId = setInterval(onCaptureInterval, 20);
      };
      this.releaseMouse = null;
      this.cancelContextMenu = function() {
        var stop = function(e2) {
          if (e2 && e2.domEvent && e2.domEvent.type != "contextmenu")
            return;
          this.editor.off("nativecontextmenu", stop);
          if (e2 && e2.domEvent)
            event.stopEvent(e2.domEvent);
        }.bind(this);
        setTimeout(stop, 10);
        this.editor.on("nativecontextmenu", stop);
      };
      this.destroy = function() {
        if (this.releaseMouse)
          this.releaseMouse();
      };
    }).call(MouseHandler.prototype);
    config.defineOptions(MouseHandler.prototype, "mouseHandler", {
      scrollSpeed: {initialValue: 2},
      dragDelay: {initialValue: useragent.isMac ? 150 : 0},
      dragEnabled: {initialValue: true},
      focusTimeout: {initialValue: 0},
      tooltipFollowsMouse: {initialValue: true}
    });
    exports2.MouseHandler = MouseHandler;
  });
  ace.define("ace/mouse/fold_handler", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
    var dom = require2("../lib/dom");
    function FoldHandler(editor) {
      editor.on("click", function(e2) {
        var position = e2.getDocumentPosition();
        var session = editor.session;
        var fold = session.getFoldAt(position.row, position.column, 1);
        if (fold) {
          if (e2.getAccelKey())
            session.removeFold(fold);
          else
            session.expandFold(fold);
          e2.stop();
        }
        var target = e2.domEvent && e2.domEvent.target;
        if (target && dom.hasCssClass(target, "ace_inline_button")) {
          if (dom.hasCssClass(target, "ace_toggle_wrap")) {
            session.setOption("wrap", !session.getUseWrapMode());
            editor.renderer.scrollCursorIntoView();
          }
        }
      });
      editor.on("gutterclick", function(e2) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e2);
        if (gutterRegion == "foldWidgets") {
          var row = e2.getDocumentPosition().row;
          var session = editor.session;
          if (session.foldWidgets && session.foldWidgets[row])
            editor.session.onFoldWidgetClick(row, e2);
          if (!editor.isFocused())
            editor.focus();
          e2.stop();
        }
      });
      editor.on("gutterdblclick", function(e2) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e2);
        if (gutterRegion == "foldWidgets") {
          var row = e2.getDocumentPosition().row;
          var session = editor.session;
          var data = session.getParentFoldRangeData(row, true);
          var range = data.range || data.firstRange;
          if (range) {
            row = range.start.row;
            var fold = session.getFoldAt(row, session.getLine(row).length, 1);
            if (fold) {
              session.removeFold(fold);
            } else {
              session.addFold("...", range);
              editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
            }
          }
          e2.stop();
        }
      });
    }
    exports2.FoldHandler = FoldHandler;
  });
  ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function(require2, exports2, module2) {
    var keyUtil = require2("../lib/keys");
    var event = require2("../lib/event");
    var KeyBinding = function(editor) {
      this.$editor = editor;
      this.$data = {editor};
      this.$handlers = [];
      this.setDefaultHandler(editor.commands);
    };
    (function() {
      this.setDefaultHandler = function(kb2) {
        this.removeKeyboardHandler(this.$defaultHandler);
        this.$defaultHandler = kb2;
        this.addKeyboardHandler(kb2, 0);
      };
      this.setKeyboardHandler = function(kb2) {
        var h2 = this.$handlers;
        if (h2[h2.length - 1] == kb2)
          return;
        while (h2[h2.length - 1] && h2[h2.length - 1] != this.$defaultHandler)
          this.removeKeyboardHandler(h2[h2.length - 1]);
        this.addKeyboardHandler(kb2, 1);
      };
      this.addKeyboardHandler = function(kb2, pos) {
        if (!kb2)
          return;
        if (typeof kb2 == "function" && !kb2.handleKeyboard)
          kb2.handleKeyboard = kb2;
        var i = this.$handlers.indexOf(kb2);
        if (i != -1)
          this.$handlers.splice(i, 1);
        if (pos == void 0)
          this.$handlers.push(kb2);
        else
          this.$handlers.splice(pos, 0, kb2);
        if (i == -1 && kb2.attach)
          kb2.attach(this.$editor);
      };
      this.removeKeyboardHandler = function(kb2) {
        var i = this.$handlers.indexOf(kb2);
        if (i == -1)
          return false;
        this.$handlers.splice(i, 1);
        kb2.detach && kb2.detach(this.$editor);
        return true;
      };
      this.getKeyboardHandler = function() {
        return this.$handlers[this.$handlers.length - 1];
      };
      this.getStatusText = function() {
        var data = this.$data;
        var editor = data.editor;
        return this.$handlers.map(function(h2) {
          return h2.getStatusText && h2.getStatusText(editor, data) || "";
        }).filter(Boolean).join(" ");
      };
      this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e2) {
        var toExecute;
        var success = false;
        var commands = this.$editor.commands;
        for (var i = this.$handlers.length; i--; ) {
          toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e2);
          if (!toExecute || !toExecute.command)
            continue;
          if (toExecute.command == "null") {
            success = true;
          } else {
            success = commands.exec(toExecute.command, this.$editor, toExecute.args, e2);
          }
          if (success && e2 && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
            event.stopEvent(e2);
          }
          if (success)
            break;
        }
        if (!success && hashId == -1) {
          toExecute = {command: "insertstring"};
          success = commands.exec("insertstring", this.$editor, keyString);
        }
        if (success && this.$editor._signal)
          this.$editor._signal("keyboardActivity", toExecute);
        return success;
      };
      this.onCommandKey = function(e2, hashId, keyCode) {
        var keyString = keyUtil.keyCodeToString(keyCode);
        return this.$callKeyboardHandlers(hashId, keyString, keyCode, e2);
      };
      this.onTextInput = function(text) {
        return this.$callKeyboardHandlers(-1, text);
      };
    }).call(KeyBinding.prototype);
    exports2.KeyBinding = KeyBinding;
  });
  ace.define("ace/lib/bidiutil", ["require", "exports", "module"], function(require2, exports2, module2) {
    var dir = 0, hiLevel = 0;
    var lastArabic = false, hasUBAT_B = false, hasUBAT_S = false;
    var impTab_LTR = [
      [0, 3, 0, 1, 0, 0, 0],
      [0, 3, 0, 1, 2, 2, 0],
      [0, 3, 0, 17, 2, 0, 1],
      [0, 3, 5, 5, 4, 1, 0],
      [0, 3, 21, 21, 4, 0, 1],
      [0, 3, 5, 5, 4, 2, 0]
    ];
    var impTab_RTL = [
      [2, 0, 1, 1, 0, 1, 0],
      [2, 0, 1, 1, 0, 2, 0],
      [2, 0, 2, 1, 3, 2, 0],
      [2, 0, 2, 33, 3, 1, 1]
    ];
    var LTR = 0, RTL = 1;
    var L = 0;
    var R2 = 1;
    var EN = 2;
    var AN = 3;
    var ON = 4;
    var B2 = 5;
    var S2 = 6;
    var AL = 7;
    var WS = 8;
    var CS = 9;
    var ES = 10;
    var ET = 11;
    var NSM = 12;
    var LRE = 13;
    var RLE = 14;
    var PDF = 15;
    var LRO = 16;
    var RLO = 17;
    var BN = 18;
    var UnicodeTBL00 = [
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      S2,
      B2,
      S2,
      WS,
      B2,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      B2,
      B2,
      B2,
      S2,
      WS,
      ON,
      ON,
      ET,
      ET,
      ET,
      ON,
      ON,
      ON,
      ON,
      ON,
      ES,
      CS,
      ES,
      CS,
      CS,
      EN,
      EN,
      EN,
      EN,
      EN,
      EN,
      EN,
      EN,
      EN,
      EN,
      CS,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      ON,
      ON,
      ON,
      ON,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      B2,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      CS,
      ON,
      ET,
      ET,
      ET,
      ET,
      ON,
      ON,
      ON,
      ON,
      L,
      ON,
      ON,
      BN,
      ON,
      ON,
      ET,
      ET,
      EN,
      EN,
      ON,
      L,
      ON,
      ON,
      ON,
      EN,
      L,
      ON,
      ON,
      ON,
      ON,
      ON
    ];
    var UnicodeTBL20 = [
      WS,
      WS,
      WS,
      WS,
      WS,
      WS,
      WS,
      WS,
      WS,
      WS,
      WS,
      BN,
      BN,
      BN,
      L,
      R2,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      WS,
      B2,
      LRE,
      RLE,
      PDF,
      LRO,
      RLO,
      CS,
      ET,
      ET,
      ET,
      ET,
      ET,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      CS,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      WS
    ];
    function _computeLevels(chars, levels, len, charTypes) {
      var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];
      if (!charTypes) {
        for (i = 0, charTypes = []; i < len; i++) {
          charTypes[i] = _getCharacterType(chars[i]);
        }
      }
      hiLevel = dir;
      lastArabic = false;
      hasUBAT_B = false;
      hasUBAT_S = false;
      for (ix = 0; ix < len; ix++) {
        prevState = newState;
        classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
        newState = impTab[prevState][newClass];
        action = newState & 240;
        newState &= 15;
        levels[ix] = newLevel = impTab[newState][5];
        if (action > 0) {
          if (action == 16) {
            for (i = condPos; i < ix; i++) {
              levels[i] = 1;
            }
            condPos = -1;
          } else {
            condPos = -1;
          }
        }
        cond = impTab[newState][6];
        if (cond) {
          if (condPos == -1) {
            condPos = ix;
          }
        } else {
          if (condPos > -1) {
            for (i = condPos; i < ix; i++) {
              levels[i] = newLevel;
            }
            condPos = -1;
          }
        }
        if (charTypes[ix] == B2) {
          levels[ix] = 0;
        }
        hiLevel |= newLevel;
      }
      if (hasUBAT_S) {
        for (i = 0; i < len; i++) {
          if (charTypes[i] == S2) {
            levels[i] = dir;
            for (var j = i - 1; j >= 0; j--) {
              if (charTypes[j] == WS) {
                levels[j] = dir;
              } else {
                break;
              }
            }
          }
        }
      }
    }
    function _invertLevel(lev, levels, _array) {
      if (hiLevel < lev) {
        return;
      }
      if (lev == 1 && dir == RTL && !hasUBAT_B) {
        _array.reverse();
        return;
      }
      var len = _array.length, start = 0, end, lo, hi2, tmp;
      while (start < len) {
        if (levels[start] >= lev) {
          end = start + 1;
          while (end < len && levels[end] >= lev) {
            end++;
          }
          for (lo = start, hi2 = end - 1; lo < hi2; lo++, hi2--) {
            tmp = _array[lo];
            _array[lo] = _array[hi2];
            _array[hi2] = tmp;
          }
          start = end;
        }
        start++;
      }
    }
    function _getCharClass(chars, types2, classes, ix) {
      var cType = types2[ix], wType, nType, len, i;
      switch (cType) {
        case L:
        case R2:
          lastArabic = false;
        case ON:
        case AN:
          return cType;
        case EN:
          return lastArabic ? AN : EN;
        case AL:
          lastArabic = true;
          return R2;
        case WS:
          return ON;
        case CS:
          if (ix < 1 || ix + 1 >= types2.length || (wType = classes[ix - 1]) != EN && wType != AN || (nType = types2[ix + 1]) != EN && nType != AN) {
            return ON;
          }
          if (lastArabic) {
            nType = AN;
          }
          return nType == wType ? nType : ON;
        case ES:
          wType = ix > 0 ? classes[ix - 1] : B2;
          if (wType == EN && ix + 1 < types2.length && types2[ix + 1] == EN) {
            return EN;
          }
          return ON;
        case ET:
          if (ix > 0 && classes[ix - 1] == EN) {
            return EN;
          }
          if (lastArabic) {
            return ON;
          }
          i = ix + 1;
          len = types2.length;
          while (i < len && types2[i] == ET) {
            i++;
          }
          if (i < len && types2[i] == EN) {
            return EN;
          }
          return ON;
        case NSM:
          len = types2.length;
          i = ix + 1;
          while (i < len && types2[i] == NSM) {
            i++;
          }
          if (i < len) {
            var c2 = chars[ix], rtlCandidate = c2 >= 1425 && c2 <= 2303 || c2 == 64286;
            wType = types2[i];
            if (rtlCandidate && (wType == R2 || wType == AL)) {
              return R2;
            }
          }
          if (ix < 1 || (wType = types2[ix - 1]) == B2) {
            return ON;
          }
          return classes[ix - 1];
        case B2:
          lastArabic = false;
          hasUBAT_B = true;
          return dir;
        case S2:
          hasUBAT_S = true;
          return ON;
        case LRE:
        case RLE:
        case LRO:
        case RLO:
        case PDF:
          lastArabic = false;
        case BN:
          return ON;
      }
    }
    function _getCharacterType(ch2) {
      var uc2 = ch2.charCodeAt(0), hi2 = uc2 >> 8;
      if (hi2 == 0) {
        return uc2 > 191 ? L : UnicodeTBL00[uc2];
      } else if (hi2 == 5) {
        return /[\u0591-\u05f4]/.test(ch2) ? R2 : L;
      } else if (hi2 == 6) {
        if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch2))
          return NSM;
        else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch2))
          return AN;
        else if (uc2 == 1642)
          return ET;
        else if (/[\u06f0-\u06f9]/.test(ch2))
          return EN;
        else
          return AL;
      } else if (hi2 == 32 && uc2 <= 8287) {
        return UnicodeTBL20[uc2 & 255];
      } else if (hi2 == 254) {
        return uc2 >= 65136 ? AL : ON;
      }
      return ON;
    }
    exports2.L = L;
    exports2.R = R2;
    exports2.EN = EN;
    exports2.ON_R = 3;
    exports2.AN = 4;
    exports2.R_H = 5;
    exports2.B = 6;
    exports2.RLE = 7;
    exports2.DOT = "";
    exports2.doBidiReorder = function(text, textCharTypes, isRtl) {
      if (text.length < 2)
        return {};
      var chars = text.split(""), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
      dir = isRtl ? RTL : LTR;
      _computeLevels(chars, levels, chars.length, textCharTypes);
      for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++)
        ;
      _invertLevel(2, levels, logicalFromVisual);
      _invertLevel(1, levels, logicalFromVisual);
      for (var i = 0; i < logicalFromVisual.length - 1; i++) {
        if (textCharTypes[i] === AN) {
          levels[i] = exports2.AN;
        } else if (levels[i] === R2 && (textCharTypes[i] > AL && textCharTypes[i] < LRE || textCharTypes[i] === ON || textCharTypes[i] === BN)) {
          levels[i] = exports2.ON_R;
        } else if (i > 0 && chars[i - 1] === "" && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
          levels[i - 1] = levels[i] = exports2.R_H;
          i++;
        }
      }
      if (chars[chars.length - 1] === exports2.DOT)
        levels[chars.length - 1] = exports2.B;
      if (chars[0] === "")
        levels[0] = exports2.RLE;
      for (var i = 0; i < logicalFromVisual.length; i++) {
        bidiLevels[i] = levels[logicalFromVisual[i]];
      }
      return {logicalFromVisual, bidiLevels};
    };
    exports2.hasBidiCharacters = function(text, textCharTypes) {
      var ret = false;
      for (var i = 0; i < text.length; i++) {
        textCharTypes[i] = _getCharacterType(text.charAt(i));
        if (!ret && (textCharTypes[i] == R2 || textCharTypes[i] == AL || textCharTypes[i] == AN))
          ret = true;
      }
      return ret;
    };
    exports2.getVisualFromLogicalIdx = function(logIdx, rowMap) {
      for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
        if (rowMap.logicalFromVisual[i] == logIdx)
          return i;
      }
      return 0;
    };
  });
  ace.define("ace/bidihandler", ["require", "exports", "module", "ace/lib/bidiutil", "ace/lib/lang"], function(require2, exports2, module2) {
    var bidiUtil = require2("./lib/bidiutil");
    var lang = require2("./lib/lang");
    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
    var BidiHandler = function(session) {
      this.session = session;
      this.bidiMap = {};
      this.currentRow = null;
      this.bidiUtil = bidiUtil;
      this.charWidths = [];
      this.EOL = "";
      this.showInvisibles = true;
      this.isRtlDir = false;
      this.$isRtl = false;
      this.line = "";
      this.wrapIndent = 0;
      this.EOF = "";
      this.RLE = "";
      this.contentWidth = 0;
      this.fontMetrics = null;
      this.rtlLineOffset = 0;
      this.wrapOffset = 0;
      this.isMoveLeftOperation = false;
      this.seenBidi = bidiRE.test(session.getValue());
    };
    (function() {
      this.isBidiRow = function(screenRow, docRow, splitIndex) {
        if (!this.seenBidi)
          return false;
        if (screenRow !== this.currentRow) {
          this.currentRow = screenRow;
          this.updateRowLine(docRow, splitIndex);
          this.updateBidiMap();
        }
        return this.bidiMap.bidiLevels;
      };
      this.onChange = function(delta) {
        if (!this.seenBidi) {
          if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
            this.seenBidi = true;
            this.currentRow = null;
          }
        } else {
          this.currentRow = null;
        }
      };
      this.getDocumentRow = function() {
        var docRow = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
          var index2 = this.session.$getRowCacheIndex(rowCache, this.currentRow);
          if (index2 >= 0)
            docRow = this.session.$docRowCache[index2];
        }
        return docRow;
      };
      this.getSplitIndex = function() {
        var splitIndex = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
          var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
          while (this.currentRow - splitIndex > 0) {
            currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
            if (currentIndex !== prevIndex)
              break;
            prevIndex = currentIndex;
            splitIndex++;
          }
        } else {
          splitIndex = this.currentRow;
        }
        return splitIndex;
      };
      this.updateRowLine = function(docRow, splitIndex) {
        if (docRow === void 0)
          docRow = this.getDocumentRow();
        var isLastRow = docRow === this.session.getLength() - 1, endOfLine = isLastRow ? this.EOF : this.EOL;
        this.wrapIndent = 0;
        this.line = this.session.getLine(docRow);
        this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
        if (this.session.$useWrapMode) {
          var splits = this.session.$wrapData[docRow];
          if (splits) {
            if (splitIndex === void 0)
              splitIndex = this.getSplitIndex();
            if (splitIndex > 0 && splits.length) {
              this.wrapIndent = splits.indent;
              this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
              this.line = splitIndex < splits.length ? this.line.substring(splits[splitIndex - 1], splits[splitIndex]) : this.line.substring(splits[splits.length - 1]);
            } else {
              this.line = this.line.substring(0, splits[splitIndex]);
            }
          }
          if (splitIndex == splits.length)
            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
        } else {
          this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
        }
        var session = this.session, shift = 0, size;
        this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch2, i) {
          if (ch2 === "	" || session.isFullWidth(ch2.charCodeAt(0))) {
            size = ch2 === "	" ? session.getScreenTabSize(i + shift) : 2;
            shift += size - 1;
            return lang.stringRepeat(bidiUtil.DOT, size);
          }
          return ch2;
        });
        if (this.isRtlDir) {
          this.fontMetrics.$main.textContent = this.line.charAt(this.line.length - 1) == bidiUtil.DOT ? this.line.substr(0, this.line.length - 1) : this.line;
          this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
        }
      };
      this.updateBidiMap = function() {
        var textCharTypes = [];
        if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
          this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
        } else {
          this.bidiMap = {};
        }
      };
      this.markAsDirty = function() {
        this.currentRow = null;
      };
      this.updateCharacterWidths = function(fontMetrics) {
        if (this.characterWidth === fontMetrics.$characterSize.width)
          return;
        this.fontMetrics = fontMetrics;
        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
        var bidiCharWidth = fontMetrics.$measureCharWidth("");
        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
        this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
        this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;
        this.currentRow = null;
      };
      this.setShowInvisibles = function(showInvisibles) {
        this.showInvisibles = showInvisibles;
        this.currentRow = null;
      };
      this.setEolChar = function(eolChar) {
        this.EOL = eolChar;
      };
      this.setContentWidth = function(width) {
        this.contentWidth = width;
      };
      this.isRtlLine = function(row) {
        if (this.$isRtl)
          return true;
        if (row != void 0)
          return this.session.getLine(row).charAt(0) == this.RLE;
        else
          return this.isRtlDir;
      };
      this.setRtlDirection = function(editor, isRtlDir) {
        var cursor = editor.getCursorPosition();
        for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
          if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)
            editor.session.doc.removeInLine(row, 0, 1);
          else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)
            editor.session.doc.insert({column: 0, row}, editor.session.$bidiHandler.RLE);
        }
      };
      this.getPosLeft = function(col) {
        col -= this.wrapIndent;
        var leftBoundary = this.line.charAt(0) === this.RLE ? 1 : 0;
        var logicalIdx = col > leftBoundary ? this.session.getOverwrite() ? col : col - 1 : leftBoundary;
        var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
        if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
          visualIdx++;
        for (var i = 0; i < visualIdx; i++) {
          left += this.charWidths[levels[i]];
        }
        if (!this.session.getOverwrite() && col > leftBoundary && levels[visualIdx] % 2 === 0)
          left += this.charWidths[levels[visualIdx]];
        if (this.wrapIndent)
          left += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
        if (this.isRtlDir)
          left += this.rtlLineOffset;
        return left;
      };
      this.getSelections = function(startCol, endCol) {
        var map2 = this.bidiMap, levels = map2.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
        if (this.wrapIndent)
          offset += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
          logIdx = map2.logicalFromVisual[visIdx];
          level = levels[visIdx];
          isSelected = logIdx >= selColMin && logIdx < selColMax;
          if (isSelected && !isSelectedPrev) {
            selectionStart = offset;
          } else if (!isSelected && isSelectedPrev) {
            selections.push({left: selectionStart, width: offset - selectionStart});
          }
          offset += this.charWidths[level];
          isSelectedPrev = isSelected;
        }
        if (isSelected && visIdx === levels.length) {
          selections.push({left: selectionStart, width: offset - selectionStart});
        }
        if (this.isRtlDir) {
          for (var i = 0; i < selections.length; i++) {
            selections[i].left += this.rtlLineOffset;
          }
        }
        return selections;
      };
      this.offsetToCol = function(posX) {
        if (this.isRtlDir)
          posX -= this.rtlLineOffset;
        var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
        if (this.wrapIndent)
          posX -= this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
        while (posX > offset + charWidth / 2) {
          offset += charWidth;
          if (visualIdx === levels.length - 1) {
            charWidth = 0;
            break;
          }
          charWidth = this.charWidths[levels[++visualIdx]];
        }
        if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && levels[visualIdx] % 2 === 0) {
          if (posX < offset)
            visualIdx--;
          logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
        } else if (visualIdx > 0 && levels[visualIdx - 1] % 2 === 0 && levels[visualIdx] % 2 !== 0) {
          logicalIdx = 1 + (posX > offset ? this.bidiMap.logicalFromVisual[visualIdx] : this.bidiMap.logicalFromVisual[visualIdx - 1]);
        } else if (this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && levels[visualIdx - 1] % 2 === 0 || !this.isRtlDir && visualIdx === 0 && levels[visualIdx] % 2 !== 0) {
          logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
        } else {
          if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && charWidth !== 0)
            visualIdx--;
          logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
        }
        if (logicalIdx === 0 && this.isRtlDir)
          logicalIdx++;
        return logicalIdx + this.wrapIndent;
      };
    }).call(BidiHandler.prototype);
    exports2.BidiHandler = BidiHandler;
  });
  ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var lang = require2("./lib/lang");
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var Range = require2("./range").Range;
    var Selection = function(session) {
      this.session = session;
      this.doc = session.getDocument();
      this.clearSelection();
      this.cursor = this.lead = this.doc.createAnchor(0, 0);
      this.anchor = this.doc.createAnchor(0, 0);
      this.$silent = false;
      var self2 = this;
      this.cursor.on("change", function(e2) {
        self2.$cursorChanged = true;
        if (!self2.$silent)
          self2._emit("changeCursor");
        if (!self2.$isEmpty && !self2.$silent)
          self2._emit("changeSelection");
        if (!self2.$keepDesiredColumnOnChange && e2.old.column != e2.value.column)
          self2.$desiredColumn = null;
      });
      this.anchor.on("change", function() {
        self2.$anchorChanged = true;
        if (!self2.$isEmpty && !self2.$silent)
          self2._emit("changeSelection");
      });
    };
    (function() {
      oop.implement(this, EventEmitter);
      this.isEmpty = function() {
        return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
      };
      this.isMultiLine = function() {
        return !this.$isEmpty && this.anchor.row != this.cursor.row;
      };
      this.getCursor = function() {
        return this.lead.getPosition();
      };
      this.setSelectionAnchor = function(row, column) {
        this.$isEmpty = false;
        this.anchor.setPosition(row, column);
      };
      this.getAnchor = this.getSelectionAnchor = function() {
        if (this.$isEmpty)
          return this.getSelectionLead();
        return this.anchor.getPosition();
      };
      this.getSelectionLead = function() {
        return this.lead.getPosition();
      };
      this.isBackwards = function() {
        var anchor = this.anchor;
        var lead = this.lead;
        return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
      };
      this.getRange = function() {
        var anchor = this.anchor;
        var lead = this.lead;
        if (this.$isEmpty)
          return Range.fromPoints(lead, lead);
        return this.isBackwards() ? Range.fromPoints(lead, anchor) : Range.fromPoints(anchor, lead);
      };
      this.clearSelection = function() {
        if (!this.$isEmpty) {
          this.$isEmpty = true;
          this._emit("changeSelection");
        }
      };
      this.selectAll = function() {
        this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
      };
      this.setRange = this.setSelectionRange = function(range, reverse) {
        var start = reverse ? range.end : range.start;
        var end = reverse ? range.start : range.end;
        this.$setSelection(start.row, start.column, end.row, end.column);
      };
      this.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {
        if (this.$silent)
          return;
        var wasEmpty = this.$isEmpty;
        var wasMultiselect = this.inMultiSelectMode;
        this.$silent = true;
        this.$cursorChanged = this.$anchorChanged = false;
        this.anchor.setPosition(anchorRow, anchorColumn);
        this.cursor.setPosition(cursorRow, cursorColumn);
        this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
        this.$silent = false;
        if (this.$cursorChanged)
          this._emit("changeCursor");
        if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
          this._emit("changeSelection");
      };
      this.$moveSelection = function(mover) {
        var lead = this.lead;
        if (this.$isEmpty)
          this.setSelectionAnchor(lead.row, lead.column);
        mover.call(this);
      };
      this.selectTo = function(row, column) {
        this.$moveSelection(function() {
          this.moveCursorTo(row, column);
        });
      };
      this.selectToPosition = function(pos) {
        this.$moveSelection(function() {
          this.moveCursorToPosition(pos);
        });
      };
      this.moveTo = function(row, column) {
        this.clearSelection();
        this.moveCursorTo(row, column);
      };
      this.moveToPosition = function(pos) {
        this.clearSelection();
        this.moveCursorToPosition(pos);
      };
      this.selectUp = function() {
        this.$moveSelection(this.moveCursorUp);
      };
      this.selectDown = function() {
        this.$moveSelection(this.moveCursorDown);
      };
      this.selectRight = function() {
        this.$moveSelection(this.moveCursorRight);
      };
      this.selectLeft = function() {
        this.$moveSelection(this.moveCursorLeft);
      };
      this.selectLineStart = function() {
        this.$moveSelection(this.moveCursorLineStart);
      };
      this.selectLineEnd = function() {
        this.$moveSelection(this.moveCursorLineEnd);
      };
      this.selectFileEnd = function() {
        this.$moveSelection(this.moveCursorFileEnd);
      };
      this.selectFileStart = function() {
        this.$moveSelection(this.moveCursorFileStart);
      };
      this.selectWordRight = function() {
        this.$moveSelection(this.moveCursorWordRight);
      };
      this.selectWordLeft = function() {
        this.$moveSelection(this.moveCursorWordLeft);
      };
      this.getWordRange = function(row, column) {
        if (typeof column == "undefined") {
          var cursor = row || this.lead;
          row = cursor.row;
          column = cursor.column;
        }
        return this.session.getWordRange(row, column);
      };
      this.selectWord = function() {
        this.setSelectionRange(this.getWordRange());
      };
      this.selectAWord = function() {
        var cursor = this.getCursor();
        var range = this.session.getAWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
      };
      this.getLineRange = function(row, excludeLastChar) {
        var rowStart = typeof row == "number" ? row : this.lead.row;
        var rowEnd;
        var foldLine2 = this.session.getFoldLine(rowStart);
        if (foldLine2) {
          rowStart = foldLine2.start.row;
          rowEnd = foldLine2.end.row;
        } else {
          rowEnd = rowStart;
        }
        if (excludeLastChar === true)
          return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
        else
          return new Range(rowStart, 0, rowEnd + 1, 0);
      };
      this.selectLine = function() {
        this.setSelectionRange(this.getLineRange());
      };
      this.moveCursorUp = function() {
        this.moveCursorBy(-1, 0);
      };
      this.moveCursorDown = function() {
        this.moveCursorBy(1, 0);
      };
      this.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
        var start = cursor.column;
        var end = cursor.column + tabSize;
        if (direction < 0) {
          start = cursor.column - tabSize;
          end = cursor.column;
        }
        return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
      };
      this.moveCursorLeft = function() {
        var cursor = this.lead.getPosition(), fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
          this.moveCursorTo(fold.start.row, fold.start.column);
        } else if (cursor.column === 0) {
          if (cursor.row > 0) {
            this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
          }
        } else {
          var tabSize = this.session.getTabSize();
          if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
            this.moveCursorBy(0, -tabSize);
          } else {
            this.moveCursorBy(0, -1);
          }
        }
      };
      this.moveCursorRight = function() {
        var cursor = this.lead.getPosition(), fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
          this.moveCursorTo(fold.end.row, fold.end.column);
        } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
          if (this.lead.row < this.doc.getLength() - 1) {
            this.moveCursorTo(this.lead.row + 1, 0);
          }
        } else {
          var tabSize = this.session.getTabSize();
          var cursor = this.lead;
          if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
            this.moveCursorBy(0, tabSize);
          } else {
            this.moveCursorBy(0, 1);
          }
        }
      };
      this.moveCursorLineStart = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var screenRow = this.session.documentToScreenRow(row, column);
        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
        var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
        var leadingSpace = beforeCursor.match(/^\s*/);
        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
          firstColumnPosition.column += leadingSpace[0].length;
        this.moveCursorToPosition(firstColumnPosition);
      };
      this.moveCursorLineEnd = function() {
        var lead = this.lead;
        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
        if (this.lead.column == lineEnd.column) {
          var line = this.session.getLine(lineEnd.row);
          if (lineEnd.column == line.length) {
            var textEnd = line.search(/\s+$/);
            if (textEnd > 0)
              lineEnd.column = textEnd;
          }
        }
        this.moveCursorTo(lineEnd.row, lineEnd.column);
      };
      this.moveCursorFileEnd = function() {
        var row = this.doc.getLength() - 1;
        var column = this.doc.getLine(row).length;
        this.moveCursorTo(row, column);
      };
      this.moveCursorFileStart = function() {
        this.moveCursorTo(0, 0);
      };
      this.moveCursorLongWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
          this.moveCursorTo(fold.end.row, fold.end.column);
          return;
        }
        if (this.session.nonTokenRe.exec(rightOfCursor)) {
          column += this.session.nonTokenRe.lastIndex;
          this.session.nonTokenRe.lastIndex = 0;
          rightOfCursor = line.substring(column);
        }
        if (column >= line.length) {
          this.moveCursorTo(row, line.length);
          this.moveCursorRight();
          if (row < this.doc.getLength() - 1)
            this.moveCursorWordRight();
          return;
        }
        if (this.session.tokenRe.exec(rightOfCursor)) {
          column += this.session.tokenRe.lastIndex;
          this.session.tokenRe.lastIndex = 0;
        }
        this.moveCursorTo(row, column);
      };
      this.moveCursorLongWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1)) {
          this.moveCursorTo(fold.start.row, fold.start.column);
          return;
        }
        var str2 = this.session.getFoldStringAt(row, column, -1);
        if (str2 == null) {
          str2 = this.doc.getLine(row).substring(0, column);
        }
        var leftOfCursor = lang.stringReverse(str2);
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        if (this.session.nonTokenRe.exec(leftOfCursor)) {
          column -= this.session.nonTokenRe.lastIndex;
          leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
          this.session.nonTokenRe.lastIndex = 0;
        }
        if (column <= 0) {
          this.moveCursorTo(row, 0);
          this.moveCursorLeft();
          if (row > 0)
            this.moveCursorWordLeft();
          return;
        }
        if (this.session.tokenRe.exec(leftOfCursor)) {
          column -= this.session.tokenRe.lastIndex;
          this.session.tokenRe.lastIndex = 0;
        }
        this.moveCursorTo(row, column);
      };
      this.$shortWordEndIndex = function(rightOfCursor) {
        var index2 = 0, ch2;
        var whitespaceRe = /\s/;
        var tokenRe = this.session.tokenRe;
        tokenRe.lastIndex = 0;
        if (this.session.tokenRe.exec(rightOfCursor)) {
          index2 = this.session.tokenRe.lastIndex;
        } else {
          while ((ch2 = rightOfCursor[index2]) && whitespaceRe.test(ch2))
            index2++;
          if (index2 < 1) {
            tokenRe.lastIndex = 0;
            while ((ch2 = rightOfCursor[index2]) && !tokenRe.test(ch2)) {
              tokenRe.lastIndex = 0;
              index2++;
              if (whitespaceRe.test(ch2)) {
                if (index2 > 2) {
                  index2--;
                  break;
                } else {
                  while ((ch2 = rightOfCursor[index2]) && whitespaceRe.test(ch2))
                    index2++;
                  if (index2 > 2)
                    break;
                }
              }
            }
          }
        }
        tokenRe.lastIndex = 0;
        return index2;
      };
      this.moveCursorShortWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold)
          return this.moveCursorTo(fold.end.row, fold.end.column);
        if (column == line.length) {
          var l2 = this.doc.getLength();
          do {
            row++;
            rightOfCursor = this.doc.getLine(row);
          } while (row < l2 && /^\s*$/.test(rightOfCursor));
          if (!/^\s+/.test(rightOfCursor))
            rightOfCursor = "";
          column = 0;
        }
        var index2 = this.$shortWordEndIndex(rightOfCursor);
        this.moveCursorTo(row, column + index2);
      };
      this.moveCursorShortWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1))
          return this.moveCursorTo(fold.start.row, fold.start.column);
        var line = this.session.getLine(row).substring(0, column);
        if (column === 0) {
          do {
            row--;
            line = this.doc.getLine(row);
          } while (row > 0 && /^\s*$/.test(line));
          column = line.length;
          if (!/\s+$/.test(line))
            line = "";
        }
        var leftOfCursor = lang.stringReverse(line);
        var index2 = this.$shortWordEndIndex(leftOfCursor);
        return this.moveCursorTo(row, column - index2);
      };
      this.moveCursorWordRight = function() {
        if (this.session.$selectLongWords)
          this.moveCursorLongWordRight();
        else
          this.moveCursorShortWordRight();
      };
      this.moveCursorWordLeft = function() {
        if (this.session.$selectLongWords)
          this.moveCursorLongWordLeft();
        else
          this.moveCursorShortWordLeft();
      };
      this.moveCursorBy = function(rows, chars) {
        var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
        var offsetX;
        if (chars === 0) {
          if (rows !== 0) {
            if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
              offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
              screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
            } else {
              offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
            }
          }
          if (this.$desiredColumn)
            screenPos.column = this.$desiredColumn;
          else
            this.$desiredColumn = screenPos.column;
        }
        if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
          var widget = this.session.lineWidgets[this.lead.row];
          if (rows < 0)
            rows -= widget.rowsAbove || 0;
          else if (rows > 0)
            rows += widget.rowCount - (widget.rowsAbove || 0);
        }
        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column)
          ;
        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
      };
      this.moveCursorToPosition = function(position) {
        this.moveCursorTo(position.row, position.column);
      };
      this.moveCursorTo = function(row, column, keepDesiredColumn) {
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
          row = fold.start.row;
          column = fold.start.column;
        }
        this.$keepDesiredColumnOnChange = true;
        var line = this.session.getLine(row);
        if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
          if (this.lead.row == row && this.lead.column == column + 1)
            column = column - 1;
          else
            column = column + 1;
        }
        this.lead.setPosition(row, column);
        this.$keepDesiredColumnOnChange = false;
        if (!keepDesiredColumn)
          this.$desiredColumn = null;
      };
      this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
      };
      this.detach = function() {
        this.lead.detach();
        this.anchor.detach();
        this.session = this.doc = null;
      };
      this.fromOrientedRange = function(range) {
        this.setSelectionRange(range, range.cursor == range.start);
        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
      };
      this.toOrientedRange = function(range) {
        var r2 = this.getRange();
        if (range) {
          range.start.column = r2.start.column;
          range.start.row = r2.start.row;
          range.end.column = r2.end.column;
          range.end.row = r2.end.row;
        } else {
          range = r2;
        }
        range.cursor = this.isBackwards() ? range.start : range.end;
        range.desiredColumn = this.$desiredColumn;
        return range;
      };
      this.getRangeOfMovements = function(func) {
        var start = this.getCursor();
        try {
          func(this);
          var end = this.getCursor();
          return Range.fromPoints(start, end);
        } catch (e2) {
          return Range.fromPoints(start, start);
        } finally {
          this.moveCursorToPosition(start);
        }
      };
      this.toJSON = function() {
        if (this.rangeCount) {
          var data = this.ranges.map(function(r2) {
            var r1 = r2.clone();
            r1.isBackwards = r2.cursor == r2.start;
            return r1;
          });
        } else {
          var data = this.getRange();
          data.isBackwards = this.isBackwards();
        }
        return data;
      };
      this.fromJSON = function(data) {
        if (data.start == void 0) {
          if (this.rangeList && data.length > 1) {
            this.toSingleRange(data[0]);
            for (var i = data.length; i--; ) {
              var r2 = Range.fromPoints(data[i].start, data[i].end);
              if (data[i].isBackwards)
                r2.cursor = r2.start;
              this.addRange(r2, true);
            }
            return;
          } else {
            data = data[0];
          }
        }
        if (this.rangeList)
          this.toSingleRange(data);
        this.setSelectionRange(data, data.isBackwards);
      };
      this.isEqual = function(data) {
        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
          return false;
        if (!data.length || !this.ranges)
          return this.getRange().isEqual(data);
        for (var i = this.ranges.length; i--; ) {
          if (!this.ranges[i].isEqual(data[i]))
            return false;
        }
        return true;
      };
    }).call(Selection.prototype);
    exports2.Selection = Selection;
  });
  ace.define("ace/tokenizer", ["require", "exports", "module", "ace/config"], function(require2, exports2, module2) {
    var config = require2("./config");
    var MAX_TOKEN_COUNT = 2e3;
    var Tokenizer = function(rules) {
      this.states = rules;
      this.regExps = {};
      this.matchMappings = {};
      for (var key in this.states) {
        var state = this.states[key];
        var ruleRegExps = [];
        var matchTotal = 0;
        var mapping = this.matchMappings[key] = {defaultToken: "text"};
        var flag = "g";
        var splitterRurles = [];
        for (var i = 0; i < state.length; i++) {
          var rule = state[i];
          if (rule.defaultToken)
            mapping.defaultToken = rule.defaultToken;
          if (rule.caseInsensitive)
            flag = "gi";
          if (rule.regex == null)
            continue;
          if (rule.regex instanceof RegExp)
            rule.regex = rule.regex.toString().slice(1, -1);
          var adjustedregex = rule.regex;
          var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
          if (Array.isArray(rule.token)) {
            if (rule.token.length == 1 || matchcount == 1) {
              rule.token = rule.token[0];
            } else if (matchcount - 1 != rule.token.length) {
              this.reportError("number of classes and regexp groups doesn't match", {
                rule,
                groupCount: matchcount - 1
              });
              rule.token = rule.token[0];
            } else {
              rule.tokenArray = rule.token;
              rule.token = null;
              rule.onMatch = this.$arrayTokens;
            }
          } else if (typeof rule.token == "function" && !rule.onMatch) {
            if (matchcount > 1)
              rule.onMatch = this.$applyToken;
            else
              rule.onMatch = rule.token;
          }
          if (matchcount > 1) {
            if (/\\\d/.test(rule.regex)) {
              adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                return "\\" + (parseInt(digit, 10) + matchTotal + 1);
              });
            } else {
              matchcount = 1;
              adjustedregex = this.removeCapturingGroups(rule.regex);
            }
            if (!rule.splitRegex && typeof rule.token != "string")
              splitterRurles.push(rule);
          }
          mapping[matchTotal] = i;
          matchTotal += matchcount;
          ruleRegExps.push(adjustedregex);
          if (!rule.onMatch)
            rule.onMatch = null;
        }
        if (!ruleRegExps.length) {
          mapping[0] = 0;
          ruleRegExps.push("$");
        }
        splitterRurles.forEach(function(rule2) {
          rule2.splitRegex = this.createSplitterRegexp(rule2.regex, flag);
        }, this);
        this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
      }
    };
    (function() {
      this.$setMaxTokenCount = function(m2) {
        MAX_TOKEN_COUNT = m2 | 0;
      };
      this.$applyToken = function(str2) {
        var values = this.splitRegex.exec(str2).slice(1);
        var types2 = this.token.apply(this, values);
        if (typeof types2 === "string")
          return [{type: types2, value: str2}];
        var tokens = [];
        for (var i = 0, l2 = types2.length; i < l2; i++) {
          if (values[i])
            tokens[tokens.length] = {
              type: types2[i],
              value: values[i]
            };
        }
        return tokens;
      };
      this.$arrayTokens = function(str2) {
        if (!str2)
          return [];
        var values = this.splitRegex.exec(str2);
        if (!values)
          return "text";
        var tokens = [];
        var types2 = this.tokenArray;
        for (var i = 0, l2 = types2.length; i < l2; i++) {
          if (values[i + 1])
            tokens[tokens.length] = {
              type: types2[i],
              value: values[i + 1]
            };
        }
        return tokens;
      };
      this.removeCapturingGroups = function(src) {
        var r2 = src.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!]|(\()/g, function(x2, y3) {
          return y3 ? "(?:" : x2;
        });
        return r2;
      };
      this.createSplitterRegexp = function(src, flag) {
        if (src.indexOf("(?=") != -1) {
          var stack = 0;
          var inChClass = false;
          var lastCapture = {};
          src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m2, esc, parenOpen, parenClose, square, index2) {
            if (inChClass) {
              inChClass = square != "]";
            } else if (square) {
              inChClass = true;
            } else if (parenClose) {
              if (stack == lastCapture.stack) {
                lastCapture.end = index2 + 1;
                lastCapture.stack = -1;
              }
              stack--;
            } else if (parenOpen) {
              stack++;
              if (parenOpen.length != 1) {
                lastCapture.stack = stack;
                lastCapture.start = index2;
              }
            }
            return m2;
          });
          if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
            src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
        }
        if (src.charAt(0) != "^")
          src = "^" + src;
        if (src.charAt(src.length - 1) != "$")
          src += "$";
        return new RegExp(src, (flag || "").replace("g", ""));
      };
      this.getLineTokens = function(line, startState) {
        if (startState && typeof startState != "string") {
          var stack = startState.slice(0);
          startState = stack[0];
          if (startState === "#tmp") {
            stack.shift();
            startState = stack.shift();
          }
        } else
          var stack = [];
        var currentState = startState || "start";
        var state = this.states[currentState];
        if (!state) {
          currentState = "start";
          state = this.states[currentState];
        }
        var mapping = this.matchMappings[currentState];
        var re2 = this.regExps[currentState];
        re2.lastIndex = 0;
        var match, tokens = [];
        var lastIndex = 0;
        var matchAttempts = 0;
        var token = {type: null, value: ""};
        while (match = re2.exec(line)) {
          var type2 = mapping.defaultToken;
          var rule = null;
          var value = match[0];
          var index2 = re2.lastIndex;
          if (index2 - value.length > lastIndex) {
            var skipped = line.substring(lastIndex, index2 - value.length);
            if (token.type == type2) {
              token.value += skipped;
            } else {
              if (token.type)
                tokens.push(token);
              token = {type: type2, value: skipped};
            }
          }
          for (var i = 0; i < match.length - 2; i++) {
            if (match[i + 1] === void 0)
              continue;
            rule = state[mapping[i]];
            if (rule.onMatch)
              type2 = rule.onMatch(value, currentState, stack, line);
            else
              type2 = rule.token;
            if (rule.next) {
              if (typeof rule.next == "string") {
                currentState = rule.next;
              } else {
                currentState = rule.next(currentState, stack);
              }
              state = this.states[currentState];
              if (!state) {
                this.reportError("state doesn't exist", currentState);
                currentState = "start";
                state = this.states[currentState];
              }
              mapping = this.matchMappings[currentState];
              lastIndex = index2;
              re2 = this.regExps[currentState];
              re2.lastIndex = index2;
            }
            if (rule.consumeLineEnd)
              lastIndex = index2;
            break;
          }
          if (value) {
            if (typeof type2 === "string") {
              if ((!rule || rule.merge !== false) && token.type === type2) {
                token.value += value;
              } else {
                if (token.type)
                  tokens.push(token);
                token = {type: type2, value};
              }
            } else if (type2) {
              if (token.type)
                tokens.push(token);
              token = {type: null, value: ""};
              for (var i = 0; i < type2.length; i++)
                tokens.push(type2[i]);
            }
          }
          if (lastIndex == line.length)
            break;
          lastIndex = index2;
          if (matchAttempts++ > MAX_TOKEN_COUNT) {
            if (matchAttempts > 2 * line.length) {
              this.reportError("infinite loop with in ace tokenizer", {
                startState,
                line
              });
            }
            while (lastIndex < line.length) {
              if (token.type)
                tokens.push(token);
              token = {
                value: line.substring(lastIndex, lastIndex += 500),
                type: "overflow"
              };
            }
            currentState = "start";
            stack = [];
            break;
          }
        }
        if (token.type)
          tokens.push(token);
        if (stack.length > 1) {
          if (stack[0] !== currentState)
            stack.unshift("#tmp", currentState);
        }
        return {
          tokens,
          state: stack.length ? stack : currentState
        };
      };
      this.reportError = config.reportError;
    }).call(Tokenizer.prototype);
    exports2.Tokenizer = Tokenizer;
  });
  ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/lang"], function(require2, exports2, module2) {
    var lang = require2("../lib/lang");
    var TextHighlightRules = function() {
      this.$rules = {
        start: [{
          token: "empty_line",
          regex: "^$"
        }, {
          defaultToken: "text"
        }]
      };
    };
    (function() {
      this.addRules = function(rules, prefix2) {
        if (!prefix2) {
          for (var key in rules)
            this.$rules[key] = rules[key];
          return;
        }
        for (var key in rules) {
          var state = rules[key];
          for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.next || rule.onMatch) {
              if (typeof rule.next == "string") {
                if (rule.next.indexOf(prefix2) !== 0)
                  rule.next = prefix2 + rule.next;
              }
              if (rule.nextState && rule.nextState.indexOf(prefix2) !== 0)
                rule.nextState = prefix2 + rule.nextState;
            }
          }
          this.$rules[prefix2 + key] = state;
        }
      };
      this.getRules = function() {
        return this.$rules;
      };
      this.embedRules = function(HighlightRules, prefix2, escapeRules, states, append) {
        var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
        if (states) {
          for (var i = 0; i < states.length; i++)
            states[i] = prefix2 + states[i];
        } else {
          states = [];
          for (var key in embedRules)
            states.push(prefix2 + key);
        }
        this.addRules(embedRules, prefix2);
        if (escapeRules) {
          var addRules = Array.prototype[append ? "push" : "unshift"];
          for (var i = 0; i < states.length; i++)
            addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
        }
        if (!this.$embeds)
          this.$embeds = [];
        this.$embeds.push(prefix2);
      };
      this.getEmbeds = function() {
        return this.$embeds;
      };
      var pushState = function(currentState, stack) {
        if (currentState != "start" || stack.length)
          stack.unshift(this.nextState, currentState);
        return this.nextState;
      };
      var popState = function(currentState, stack) {
        stack.shift();
        return stack.shift() || "start";
      };
      this.normalizeRules = function() {
        var id2 = 0;
        var rules = this.$rules;
        function processState(key) {
          var state = rules[key];
          state.processed = true;
          for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            var toInsert = null;
            if (Array.isArray(rule)) {
              toInsert = rule;
              rule = {};
            }
            if (!rule.regex && rule.start) {
              rule.regex = rule.start;
              if (!rule.next)
                rule.next = [];
              rule.next.push({
                defaultToken: rule.token
              }, {
                token: rule.token + ".end",
                regex: rule.end || rule.start,
                next: "pop"
              });
              rule.token = rule.token + ".start";
              rule.push = true;
            }
            var next = rule.next || rule.push;
            if (next && Array.isArray(next)) {
              var stateName = rule.stateName;
              if (!stateName) {
                stateName = rule.token;
                if (typeof stateName != "string")
                  stateName = stateName[0] || "";
                if (rules[stateName])
                  stateName += id2++;
              }
              rules[stateName] = next;
              rule.next = stateName;
              processState(stateName);
            } else if (next == "pop") {
              rule.next = popState;
            }
            if (rule.push) {
              rule.nextState = rule.next || rule.push;
              rule.next = pushState;
              delete rule.push;
            }
            if (rule.rules) {
              for (var r2 in rule.rules) {
                if (rules[r2]) {
                  if (rules[r2].push)
                    rules[r2].push.apply(rules[r2], rule.rules[r2]);
                } else {
                  rules[r2] = rule.rules[r2];
                }
              }
            }
            var includeName = typeof rule == "string" ? rule : rule.include;
            if (includeName) {
              if (Array.isArray(includeName))
                toInsert = includeName.map(function(x2) {
                  return rules[x2];
                });
              else
                toInsert = rules[includeName];
            }
            if (toInsert) {
              var args = [i, 1].concat(toInsert);
              if (rule.noEscape)
                args = args.filter(function(x2) {
                  return !x2.next;
                });
              state.splice.apply(state, args);
              i--;
            }
            if (rule.keywordMap) {
              rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
              delete rule.defaultToken;
            }
          }
        }
        Object.keys(rules).forEach(processState, this);
      };
      this.createKeywordMapper = function(map2, defaultToken, ignoreCase, splitChar) {
        var keywords = Object.create(null);
        this.$keywordList = [];
        Object.keys(map2).forEach(function(className) {
          var a = map2[className];
          var list = a.split(splitChar || "|");
          for (var i = list.length; i--; ) {
            var word = list[i];
            this.$keywordList.push(word);
            if (ignoreCase)
              word = word.toLowerCase();
            keywords[word] = className;
          }
        }, this);
        map2 = null;
        return ignoreCase ? function(value) {
          return keywords[value.toLowerCase()] || defaultToken;
        } : function(value) {
          return keywords[value] || defaultToken;
        };
      };
      this.getKeywords = function() {
        return this.$keywords;
      };
    }).call(TextHighlightRules.prototype);
    exports2.TextHighlightRules = TextHighlightRules;
  });
  ace.define("ace/mode/behaviour", ["require", "exports", "module"], function(require2, exports2, module2) {
    var Behaviour = function() {
      this.$behaviours = {};
    };
    (function() {
      this.add = function(name, action, callback) {
        switch (void 0) {
          case this.$behaviours:
            this.$behaviours = {};
          case this.$behaviours[name]:
            this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
      };
      this.addBehaviours = function(behaviours) {
        for (var key in behaviours) {
          for (var action in behaviours[key]) {
            this.add(key, action, behaviours[key][action]);
          }
        }
      };
      this.remove = function(name) {
        if (this.$behaviours && this.$behaviours[name]) {
          delete this.$behaviours[name];
        }
      };
      this.inherit = function(mode, filter) {
        if (typeof mode === "function") {
          var behaviours = new mode().getBehaviours(filter);
        } else {
          var behaviours = mode.getBehaviours(filter);
        }
        this.addBehaviours(behaviours);
      };
      this.getBehaviours = function(filter) {
        if (!filter) {
          return this.$behaviours;
        } else {
          var ret = {};
          for (var i = 0; i < filter.length; i++) {
            if (this.$behaviours[filter[i]]) {
              ret[filter[i]] = this.$behaviours[filter[i]];
            }
          }
          return ret;
        }
      };
    }).call(Behaviour.prototype);
    exports2.Behaviour = Behaviour;
  });
  ace.define("ace/token_iterator", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var Range = require2("./range").Range;
    var TokenIterator = function(session, initialRow, initialColumn) {
      this.$session = session;
      this.$row = initialRow;
      this.$rowTokens = session.getTokens(initialRow);
      var token = session.getTokenAt(initialRow, initialColumn);
      this.$tokenIndex = token ? token.index : -1;
    };
    (function() {
      this.stepBackward = function() {
        this.$tokenIndex -= 1;
        while (this.$tokenIndex < 0) {
          this.$row -= 1;
          if (this.$row < 0) {
            this.$row = 0;
            return null;
          }
          this.$rowTokens = this.$session.getTokens(this.$row);
          this.$tokenIndex = this.$rowTokens.length - 1;
        }
        return this.$rowTokens[this.$tokenIndex];
      };
      this.stepForward = function() {
        this.$tokenIndex += 1;
        var rowCount;
        while (this.$tokenIndex >= this.$rowTokens.length) {
          this.$row += 1;
          if (!rowCount)
            rowCount = this.$session.getLength();
          if (this.$row >= rowCount) {
            this.$row = rowCount - 1;
            return null;
          }
          this.$rowTokens = this.$session.getTokens(this.$row);
          this.$tokenIndex = 0;
        }
        return this.$rowTokens[this.$tokenIndex];
      };
      this.getCurrentToken = function() {
        return this.$rowTokens[this.$tokenIndex];
      };
      this.getCurrentTokenRow = function() {
        return this.$row;
      };
      this.getCurrentTokenColumn = function() {
        var rowTokens = this.$rowTokens;
        var tokenIndex = this.$tokenIndex;
        var column = rowTokens[tokenIndex].start;
        if (column !== void 0)
          return column;
        column = 0;
        while (tokenIndex > 0) {
          tokenIndex -= 1;
          column += rowTokens[tokenIndex].value.length;
        }
        return column;
      };
      this.getCurrentTokenPosition = function() {
        return {row: this.$row, column: this.getCurrentTokenColumn()};
      };
      this.getCurrentTokenRange = function() {
        var token = this.$rowTokens[this.$tokenIndex];
        var column = this.getCurrentTokenColumn();
        return new Range(this.$row, column, this.$row, column + token.value.length);
      };
    }).call(TokenIterator.prototype);
    exports2.TokenIterator = TokenIterator;
  });
  ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var Behaviour = require2("../behaviour").Behaviour;
    var TokenIterator = require2("../../token_iterator").TokenIterator;
    var lang = require2("../../lib/lang");
    var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
    var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];
    var context2;
    var contextCache = {};
    var defaultQuotes = {'"': '"', "'": "'"};
    var initContext = function(editor) {
      var id2 = -1;
      if (editor.multiSelect) {
        id2 = editor.selection.index;
        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
          contextCache = {rangeCount: editor.multiSelect.rangeCount};
      }
      if (contextCache[id2])
        return context2 = contextCache[id2];
      context2 = contextCache[id2] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
      };
    };
    var getWrapped = function(selection, selected, opening, closing) {
      var rowDiff = selection.end.row - selection.start.row;
      return {
        text: opening + selected + closing,
        selection: [
          0,
          selection.start.column + 1,
          rowDiff,
          selection.end.column + (rowDiff ? 0 : 1)
        ]
      };
    };
    var CstyleBehaviour = function(options) {
      this.add("braces", "insertion", function(state, action, editor, session, text) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == "{") {
          initContext(editor);
          var selection = editor.getSelectionRange();
          var selected = session.doc.getTextRange(selection);
          if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
            return getWrapped(selection, selected, "{", "}");
          } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
            if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {
              CstyleBehaviour.recordAutoInsert(editor, session, "}");
              return {
                text: "{}",
                selection: [1, 1]
              };
            } else {
              CstyleBehaviour.recordMaybeInsert(editor, session, "{");
              return {
                text: "{",
                selection: [1, 1]
              };
            }
          }
        } else if (text == "}") {
          initContext(editor);
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          if (rightChar == "}") {
            var matching = session.$findOpeningBracket("}", {column: cursor.column + 1, row: cursor.row});
            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
              CstyleBehaviour.popAutoInsertedClosing();
              return {
                text: "",
                selection: [1, 1]
              };
            }
          }
        } else if (text == "\n" || text == "\r\n") {
          initContext(editor);
          var closing = "";
          if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
            closing = lang.stringRepeat("}", context2.maybeInsertedBrackets);
            CstyleBehaviour.clearMaybeInsertedClosing();
          }
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          if (rightChar === "}") {
            var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column + 1}, "}");
            if (!openBracePos)
              return null;
            var next_indent = this.$getIndent(session.getLine(openBracePos.row));
          } else if (closing) {
            var next_indent = this.$getIndent(line);
          } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
            return;
          }
          var indent = next_indent + session.getTabString();
          return {
            text: "\n" + indent + "\n" + next_indent + closing,
            selection: [1, indent.length, 1, indent.length]
          };
        } else {
          CstyleBehaviour.clearMaybeInsertedClosing();
        }
      });
      this.add("braces", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == "{") {
          initContext(editor);
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.end.column, range.end.column + 1);
          if (rightChar == "}") {
            range.end.column++;
            return range;
          } else {
            context2.maybeInsertedBrackets--;
          }
        }
      });
      this.add("parens", "insertion", function(state, action, editor, session, text) {
        if (text == "(") {
          initContext(editor);
          var selection = editor.getSelectionRange();
          var selected = session.doc.getTextRange(selection);
          if (selected !== "" && editor.getWrapBehavioursEnabled()) {
            return getWrapped(selection, selected, "(", ")");
          } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
            CstyleBehaviour.recordAutoInsert(editor, session, ")");
            return {
              text: "()",
              selection: [1, 1]
            };
          }
        } else if (text == ")") {
          initContext(editor);
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          if (rightChar == ")") {
            var matching = session.$findOpeningBracket(")", {column: cursor.column + 1, row: cursor.row});
            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
              CstyleBehaviour.popAutoInsertedClosing();
              return {
                text: "",
                selection: [1, 1]
              };
            }
          }
        }
      });
      this.add("parens", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == "(") {
          initContext(editor);
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
          if (rightChar == ")") {
            range.end.column++;
            return range;
          }
        }
      });
      this.add("brackets", "insertion", function(state, action, editor, session, text) {
        if (text == "[") {
          initContext(editor);
          var selection = editor.getSelectionRange();
          var selected = session.doc.getTextRange(selection);
          if (selected !== "" && editor.getWrapBehavioursEnabled()) {
            return getWrapped(selection, selected, "[", "]");
          } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
            CstyleBehaviour.recordAutoInsert(editor, session, "]");
            return {
              text: "[]",
              selection: [1, 1]
            };
          }
        } else if (text == "]") {
          initContext(editor);
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          if (rightChar == "]") {
            var matching = session.$findOpeningBracket("]", {column: cursor.column + 1, row: cursor.row});
            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
              CstyleBehaviour.popAutoInsertedClosing();
              return {
                text: "",
                selection: [1, 1]
              };
            }
          }
        }
      });
      this.add("brackets", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == "[") {
          initContext(editor);
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
          if (rightChar == "]") {
            range.end.column++;
            return range;
          }
        }
      });
      this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
        var quotes = session.$mode.$quotes || defaultQuotes;
        if (text.length == 1 && quotes[text]) {
          if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
            return;
          initContext(editor);
          var quote = text;
          var selection = editor.getSelectionRange();
          var selected = session.doc.getTextRange(selection);
          if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
            return getWrapped(selection, selected, quote, quote);
          } else if (!selected) {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var leftChar = line.substring(cursor.column - 1, cursor.column);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            var token = session.getTokenAt(cursor.row, cursor.column);
            var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
            if (leftChar == "\\" && token && /escape/.test(token.type))
              return null;
            var stringBefore = token && /string|escape/.test(token.type);
            var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
            var pair;
            if (rightChar == quote) {
              pair = stringBefore !== stringAfter;
              if (pair && /string\.end/.test(rightToken.type))
                pair = false;
            } else {
              if (stringBefore && !stringAfter)
                return null;
              if (stringBefore && stringAfter)
                return null;
              var wordRe = session.$mode.tokenRe;
              wordRe.lastIndex = 0;
              var isWordBefore = wordRe.test(leftChar);
              wordRe.lastIndex = 0;
              var isWordAfter = wordRe.test(leftChar);
              if (isWordBefore || isWordAfter)
                return null;
              if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                return null;
              var charBefore = line[cursor.column - 2];
              if (leftChar == quote && (charBefore == quote || wordRe.test(charBefore)))
                return null;
              pair = true;
            }
            return {
              text: pair ? quote + quote : "",
              selection: [1, 1]
            };
          }
        }
      });
      this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
        var quotes = session.$mode.$quotes || defaultQuotes;
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
          initContext(editor);
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
          if (rightChar == selected) {
            range.end.column++;
            return range;
          }
        }
      });
    };
    CstyleBehaviour.isSaneInsertion = function(editor, session) {
      var cursor = editor.getCursorPosition();
      var iterator = new TokenIterator(session, cursor.row, cursor.column);
      if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
        if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))
          return true;
        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
          return false;
      }
      iterator.stepForward();
      return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
    };
    CstyleBehaviour.$matchTokenType = function(token, types2) {
      return types2.indexOf(token.type || token) > -1;
    };
    CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
      var cursor = editor.getCursorPosition();
      var line = session.doc.getLine(cursor.row);
      if (!this.isAutoInsertedClosing(cursor, line, context2.autoInsertedLineEnd[0]))
        context2.autoInsertedBrackets = 0;
      context2.autoInsertedRow = cursor.row;
      context2.autoInsertedLineEnd = bracket + line.substr(cursor.column);
      context2.autoInsertedBrackets++;
    };
    CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
      var cursor = editor.getCursorPosition();
      var line = session.doc.getLine(cursor.row);
      if (!this.isMaybeInsertedClosing(cursor, line))
        context2.maybeInsertedBrackets = 0;
      context2.maybeInsertedRow = cursor.row;
      context2.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
      context2.maybeInsertedLineEnd = line.substr(cursor.column);
      context2.maybeInsertedBrackets++;
    };
    CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
      return context2.autoInsertedBrackets > 0 && cursor.row === context2.autoInsertedRow && bracket === context2.autoInsertedLineEnd[0] && line.substr(cursor.column) === context2.autoInsertedLineEnd;
    };
    CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
      return context2.maybeInsertedBrackets > 0 && cursor.row === context2.maybeInsertedRow && line.substr(cursor.column) === context2.maybeInsertedLineEnd && line.substr(0, cursor.column) == context2.maybeInsertedLineStart;
    };
    CstyleBehaviour.popAutoInsertedClosing = function() {
      context2.autoInsertedLineEnd = context2.autoInsertedLineEnd.substr(1);
      context2.autoInsertedBrackets--;
    };
    CstyleBehaviour.clearMaybeInsertedClosing = function() {
      if (context2) {
        context2.maybeInsertedBrackets = 0;
        context2.maybeInsertedRow = -1;
      }
    };
    oop.inherits(CstyleBehaviour, Behaviour);
    exports2.CstyleBehaviour = CstyleBehaviour;
  });
  ace.define("ace/unicode", ["require", "exports", "module"], function(require2, exports2, module2) {
    var wordChars = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2];
    var code = 0;
    var str2 = [];
    for (var i = 0; i < wordChars.length; i += 2) {
      str2.push(code += wordChars[i]);
      if (wordChars[i + 1])
        str2.push(45, code += wordChars[i + 1]);
    }
    exports2.wordChars = String.fromCharCode.apply(null, str2);
  });
  ace.define("ace/mode/text", ["require", "exports", "module", "ace/config", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function(require2, exports2, module2) {
    var config = require2("../config");
    var Tokenizer = require2("../tokenizer").Tokenizer;
    var TextHighlightRules = require2("./text_highlight_rules").TextHighlightRules;
    var CstyleBehaviour = require2("./behaviour/cstyle").CstyleBehaviour;
    var unicode = require2("../unicode");
    var lang = require2("../lib/lang");
    var TokenIterator = require2("../token_iterator").TokenIterator;
    var Range = require2("../range").Range;
    var Mode2 = function() {
      this.HighlightRules = TextHighlightRules;
    };
    (function() {
      this.$defaultBehaviour = new CstyleBehaviour();
      this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");
      this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");
      this.getTokenizer = function() {
        if (!this.$tokenizer) {
          this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
          this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
        }
        return this.$tokenizer;
      };
      this.lineCommentStart = "";
      this.blockComment = "";
      this.toggleCommentLines = function(state, session, startRow, endRow) {
        var doc = session.doc;
        var ignoreBlankLines = true;
        var shouldRemove = true;
        var minIndent = Infinity;
        var tabSize = session.getTabSize();
        var insertAtTabStop = false;
        if (!this.lineCommentStart) {
          if (!this.blockComment)
            return false;
          var lineCommentStart = this.blockComment.start;
          var lineCommentEnd = this.blockComment.end;
          var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
          var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
          var comment = function(line, i) {
            if (testRemove(line, i))
              return;
            if (!ignoreBlankLines || /\S/.test(line)) {
              doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
              doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
            }
          };
          var uncomment = function(line, i) {
            var m2;
            if (m2 = line.match(regexpEnd))
              doc.removeInLine(i, line.length - m2[0].length, line.length);
            if (m2 = line.match(regexpStart))
              doc.removeInLine(i, m2[1].length, m2[0].length);
          };
          var testRemove = function(line, row) {
            if (regexpStart.test(line))
              return true;
            var tokens = session.getTokens(row);
            for (var i = 0; i < tokens.length; i++) {
              if (tokens[i].type === "comment")
                return true;
            }
          };
        } else {
          if (Array.isArray(this.lineCommentStart)) {
            var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
            var lineCommentStart = this.lineCommentStart[0];
          } else {
            var regexpStart = lang.escapeRegExp(this.lineCommentStart);
            var lineCommentStart = this.lineCommentStart;
          }
          regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
          insertAtTabStop = session.getUseSoftTabs();
          var uncomment = function(line, i) {
            var m2 = line.match(regexpStart);
            if (!m2)
              return;
            var start = m2[1].length, end = m2[0].length;
            if (!shouldInsertSpace(line, start, end) && m2[0][end - 1] == " ")
              end--;
            doc.removeInLine(i, start, end);
          };
          var commentWithSpace = lineCommentStart + " ";
          var comment = function(line, i) {
            if (!ignoreBlankLines || /\S/.test(line)) {
              if (shouldInsertSpace(line, minIndent, minIndent))
                doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
              else
                doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
            }
          };
          var testRemove = function(line, i) {
            return regexpStart.test(line);
          };
          var shouldInsertSpace = function(line, before, after) {
            var spaces = 0;
            while (before-- && line.charAt(before) == " ")
              spaces++;
            if (spaces % tabSize != 0)
              return false;
            var spaces = 0;
            while (line.charAt(after++) == " ")
              spaces++;
            if (tabSize > 2)
              return spaces % tabSize != tabSize - 1;
            else
              return spaces % tabSize == 0;
          };
        }
        function iter(fun) {
          for (var i = startRow; i <= endRow; i++)
            fun(doc.getLine(i), i);
        }
        var minEmptyLength = Infinity;
        iter(function(line, i) {
          var indent = line.search(/\S/);
          if (indent !== -1) {
            if (indent < minIndent)
              minIndent = indent;
            if (shouldRemove && !testRemove(line, i))
              shouldRemove = false;
          } else if (minEmptyLength > line.length) {
            minEmptyLength = line.length;
          }
        });
        if (minIndent == Infinity) {
          minIndent = minEmptyLength;
          ignoreBlankLines = false;
          shouldRemove = false;
        }
        if (insertAtTabStop && minIndent % tabSize != 0)
          minIndent = Math.floor(minIndent / tabSize) * tabSize;
        iter(shouldRemove ? uncomment : comment);
      };
      this.toggleBlockComment = function(state, session, range, cursor) {
        var comment = this.blockComment;
        if (!comment)
          return;
        if (!comment.start && comment[0])
          comment = comment[0];
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();
        var sel = session.selection;
        var initialRange = session.selection.toOrientedRange();
        var startRow, colDiff;
        if (token && /comment/.test(token.type)) {
          var startRange, endRange;
          while (token && /comment/.test(token.type)) {
            var i = token.value.indexOf(comment.start);
            if (i != -1) {
              var row = iterator.getCurrentTokenRow();
              var column = iterator.getCurrentTokenColumn() + i;
              startRange = new Range(row, column, row, column + comment.start.length);
              break;
            }
            token = iterator.stepBackward();
          }
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          while (token && /comment/.test(token.type)) {
            var i = token.value.indexOf(comment.end);
            if (i != -1) {
              var row = iterator.getCurrentTokenRow();
              var column = iterator.getCurrentTokenColumn() + i;
              endRange = new Range(row, column, row, column + comment.end.length);
              break;
            }
            token = iterator.stepForward();
          }
          if (endRange)
            session.remove(endRange);
          if (startRange) {
            session.remove(startRange);
            startRow = startRange.start.row;
            colDiff = -comment.start.length;
          }
        } else {
          colDiff = comment.start.length;
          startRow = range.start.row;
          session.insert(range.end, comment.end);
          session.insert(range.start, comment.start);
        }
        if (initialRange.start.row == startRow)
          initialRange.start.column += colDiff;
        if (initialRange.end.row == startRow)
          initialRange.end.column += colDiff;
        session.selection.fromOrientedRange(initialRange);
      };
      this.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
      };
      this.checkOutdent = function(state, line, input) {
        return false;
      };
      this.autoOutdent = function(state, doc, row) {
      };
      this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
      };
      this.createWorker = function(session) {
        return null;
      };
      this.createModeDelegates = function(mapping) {
        this.$embeds = [];
        this.$modes = {};
        for (var i in mapping) {
          if (mapping[i]) {
            var Mode3 = mapping[i];
            var id2 = Mode3.prototype.$id;
            var mode = config.$modes[id2];
            if (!mode)
              config.$modes[id2] = mode = new Mode3();
            if (!config.$modes[i])
              config.$modes[i] = mode;
            this.$embeds.push(i);
            this.$modes[i] = mode;
          }
        }
        var delegations = [
          "toggleBlockComment",
          "toggleCommentLines",
          "getNextLineIndent",
          "checkOutdent",
          "autoOutdent",
          "transformAction",
          "getCompletions"
        ];
        for (var i = 0; i < delegations.length; i++) {
          (function(scope) {
            var functionName = delegations[i];
            var defaultHandler = scope[functionName];
            scope[delegations[i]] = function() {
              return this.$delegator(functionName, arguments, defaultHandler);
            };
          })(this);
        }
      };
      this.$delegator = function(method, args, defaultHandler) {
        var state = args[0] || "start";
        if (typeof state != "string") {
          if (Array.isArray(state[2])) {
            var language = state[2][state[2].length - 1];
            var mode = this.$modes[language];
            if (mode)
              return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
          }
          state = state[0] || "start";
        }
        for (var i = 0; i < this.$embeds.length; i++) {
          if (!this.$modes[this.$embeds[i]])
            continue;
          var split2 = state.split(this.$embeds[i]);
          if (!split2[0] && split2[1]) {
            args[0] = split2[1];
            var mode = this.$modes[this.$embeds[i]];
            return mode[method].apply(mode, args);
          }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : void 0;
      };
      this.transformAction = function(state, action, editor, session, param) {
        if (this.$behaviour) {
          var behaviours = this.$behaviour.getBehaviours();
          for (var key in behaviours) {
            if (behaviours[key][action]) {
              var ret = behaviours[key][action].apply(this, arguments);
              if (ret) {
                return ret;
              }
            }
          }
        }
      };
      this.getKeywords = function(append) {
        if (!this.completionKeywords) {
          var rules = this.$tokenizer.rules;
          var completionKeywords = [];
          for (var rule in rules) {
            var ruleItr = rules[rule];
            for (var r2 = 0, l2 = ruleItr.length; r2 < l2; r2++) {
              if (typeof ruleItr[r2].token === "string") {
                if (/keyword|support|storage/.test(ruleItr[r2].token))
                  completionKeywords.push(ruleItr[r2].regex);
              } else if (typeof ruleItr[r2].token === "object") {
                for (var a = 0, aLength = ruleItr[r2].token.length; a < aLength; a++) {
                  if (/keyword|support|storage/.test(ruleItr[r2].token[a])) {
                    var rule = ruleItr[r2].regex.match(/\(.+?\)/g)[a];
                    completionKeywords.push(rule.substr(1, rule.length - 2));
                  }
                }
              }
            }
          }
          this.completionKeywords = completionKeywords;
        }
        if (!append)
          return this.$keywordList;
        return completionKeywords.concat(this.$keywordList || []);
      };
      this.$createKeywordList = function() {
        if (!this.$highlightRules)
          this.getTokenizer();
        return this.$keywordList = this.$highlightRules.$keywordList || [];
      };
      this.getCompletions = function(state, session, pos, prefix2) {
        var keywords = this.$keywordList || this.$createKeywordList();
        return keywords.map(function(word) {
          return {
            name: word,
            value: word,
            score: 0,
            meta: "keyword"
          };
        });
      };
      this.$id = "ace/mode/text";
    }).call(Mode2.prototype);
    exports2.Mode = Mode2;
  });
  ace.define("ace/apply_delta", ["require", "exports", "module"], function(require2, exports2, module2) {
    exports2.applyDelta = function(docLines, delta, doNotValidate) {
      var row = delta.start.row;
      var startColumn = delta.start.column;
      var line = docLines[row] || "";
      switch (delta.action) {
        case "insert":
          var lines = delta.lines;
          if (lines.length === 1) {
            docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
          } else {
            var args = [row, 1].concat(delta.lines);
            docLines.splice.apply(docLines, args);
            docLines[row] = line.substring(0, startColumn) + docLines[row];
            docLines[row + delta.lines.length - 1] += line.substring(startColumn);
          }
          break;
        case "remove":
          var endColumn = delta.end.column;
          var endRow = delta.end.row;
          if (row === endRow) {
            docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
          } else {
            docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
          }
          break;
      }
    };
  });
  ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var Anchor = exports2.Anchor = function(doc, row, column) {
      this.$onChange = this.onChange.bind(this);
      this.attach(doc);
      if (typeof column == "undefined")
        this.setPosition(row.row, row.column);
      else
        this.setPosition(row, column);
    };
    (function() {
      oop.implement(this, EventEmitter);
      this.getPosition = function() {
        return this.$clipPositionToDocument(this.row, this.column);
      };
      this.getDocument = function() {
        return this.document;
      };
      this.$insertRight = false;
      this.onChange = function(delta) {
        if (delta.start.row == delta.end.row && delta.start.row != this.row)
          return;
        if (delta.start.row > this.row)
          return;
        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
        this.setPosition(point.row, point.column, true);
      };
      function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
      }
      function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end;
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
          return {
            row: point.row,
            column: point.column
          };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
          return {
            row: point.row + deltaRowShift,
            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
          };
        }
        return {
          row: deltaStart.row,
          column: deltaStart.column
        };
      }
      this.setPosition = function(row, column, noClip) {
        var pos;
        if (noClip) {
          pos = {
            row,
            column
          };
        } else {
          pos = this.$clipPositionToDocument(row, column);
        }
        if (this.row == pos.row && this.column == pos.column)
          return;
        var old = {
          row: this.row,
          column: this.column
        };
        this.row = pos.row;
        this.column = pos.column;
        this._signal("change", {
          old,
          value: pos
        });
      };
      this.detach = function() {
        this.document.off("change", this.$onChange);
      };
      this.attach = function(doc) {
        this.document = doc || this.document;
        this.document.on("change", this.$onChange);
      };
      this.$clipPositionToDocument = function(row, column) {
        var pos = {};
        if (row >= this.document.getLength()) {
          pos.row = Math.max(0, this.document.getLength() - 1);
          pos.column = this.document.getLine(pos.row).length;
        } else if (row < 0) {
          pos.row = 0;
          pos.column = 0;
        } else {
          pos.row = row;
          pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }
        if (column < 0)
          pos.column = 0;
        return pos;
      };
    }).call(Anchor.prototype);
  });
  ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var applyDelta = require2("./apply_delta").applyDelta;
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var Range = require2("./range").Range;
    var Anchor = require2("./anchor").Anchor;
    var Document = function(textOrLines) {
      this.$lines = [""];
      if (textOrLines.length === 0) {
        this.$lines = [""];
      } else if (Array.isArray(textOrLines)) {
        this.insertMergedLines({row: 0, column: 0}, textOrLines);
      } else {
        this.insert({row: 0, column: 0}, textOrLines);
      }
    };
    (function() {
      oop.implement(this, EventEmitter);
      this.setValue = function(text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({row: 0, column: 0}, text);
      };
      this.getValue = function() {
        return this.getAllLines().join(this.getNewLineCharacter());
      };
      this.createAnchor = function(row, column) {
        return new Anchor(this, row, column);
      };
      if ("aaa".split(/a/).length === 0) {
        this.$split = function(text) {
          return text.replace(/\r\n|\r/g, "\n").split("\n");
        };
      } else {
        this.$split = function(text) {
          return text.split(/\r\n|\r|\n/);
        };
      }
      this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : "\n";
        this._signal("changeNewLineMode");
      };
      this.getNewLineCharacter = function() {
        switch (this.$newLineMode) {
          case "windows":
            return "\r\n";
          case "unix":
            return "\n";
          default:
            return this.$autoNewLine || "\n";
        }
      };
      this.$autoNewLine = "";
      this.$newLineMode = "auto";
      this.setNewLineMode = function(newLineMode) {
        if (this.$newLineMode === newLineMode)
          return;
        this.$newLineMode = newLineMode;
        this._signal("changeNewLineMode");
      };
      this.getNewLineMode = function() {
        return this.$newLineMode;
      };
      this.isNewLine = function(text) {
        return text == "\r\n" || text == "\r" || text == "\n";
      };
      this.getLine = function(row) {
        return this.$lines[row] || "";
      };
      this.getLines = function(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
      };
      this.getAllLines = function() {
        return this.getLines(0, this.getLength());
      };
      this.getLength = function() {
        return this.$lines.length;
      };
      this.getTextRange = function(range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
      };
      this.getLinesForRange = function(range) {
        var lines;
        if (range.start.row === range.end.row) {
          lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        } else {
          lines = this.getLines(range.start.row, range.end.row);
          lines[0] = (lines[0] || "").substring(range.start.column);
          var l2 = lines.length - 1;
          if (range.end.row - range.start.row == l2)
            lines[l2] = lines[l2].substring(0, range.end.column);
        }
        return lines;
      };
      this.insertLines = function(row, lines) {
        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
        return this.insertFullLines(row, lines);
      };
      this.removeLines = function(firstRow, lastRow) {
        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
        return this.removeFullLines(firstRow, lastRow);
      };
      this.insertNewLine = function(position) {
        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
        return this.insertMergedLines(position, ["", ""]);
      };
      this.insert = function(position, text) {
        if (this.getLength() <= 1)
          this.$detectNewLine(text);
        return this.insertMergedLines(position, this.$split(text));
      };
      this.insertInLine = function(position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        this.applyDelta({
          start,
          end,
          action: "insert",
          lines: [text]
        }, true);
        return this.clonePos(end);
      };
      this.clippedPos = function(row, column) {
        var length = this.getLength();
        if (row === void 0) {
          row = length;
        } else if (row < 0) {
          row = 0;
        } else if (row >= length) {
          row = length - 1;
          column = void 0;
        }
        var line = this.getLine(row);
        if (column == void 0)
          column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return {row, column};
      };
      this.clonePos = function(pos) {
        return {row: pos.row, column: pos.column};
      };
      this.pos = function(row, column) {
        return {row, column};
      };
      this.$clipPosition = function(position) {
        var length = this.getLength();
        if (position.row >= length) {
          position.row = Math.max(0, length - 1);
          position.column = this.getLine(length - 1).length;
        } else {
          position.row = Math.max(0, position.row);
          position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
      };
      this.insertFullLines = function(row, lines) {
        row = Math.min(Math.max(row, 0), this.getLength());
        var column = 0;
        if (row < this.getLength()) {
          lines = lines.concat([""]);
          column = 0;
        } else {
          lines = [""].concat(lines);
          row--;
          column = this.$lines[row].length;
        }
        this.insertMergedLines({row, column}, lines);
      };
      this.insertMergedLines = function(position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
          row: start.row + lines.length - 1,
          column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        this.applyDelta({
          start,
          end,
          action: "insert",
          lines
        });
        return this.clonePos(end);
      };
      this.remove = function(range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
          start,
          end,
          action: "remove",
          lines: this.getLinesForRange({start, end})
        });
        return this.clonePos(start);
      };
      this.removeInLine = function(row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        this.applyDelta({
          start,
          end,
          action: "remove",
          lines: this.getLinesForRange({start, end})
        }, true);
        return this.clonePos(start);
      };
      this.removeFullLines = function(firstRow, lastRow) {
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
        var deleteLastNewLine = lastRow < this.getLength() - 1;
        var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
        var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
        var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
        var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
        var range = new Range(startRow, startCol, endRow, endCol);
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        this.applyDelta({
          start: range.start,
          end: range.end,
          action: "remove",
          lines: this.getLinesForRange(range)
        });
        return deletedLines;
      };
      this.removeNewLine = function(row) {
        if (row < this.getLength() - 1 && row >= 0) {
          this.applyDelta({
            start: this.pos(row, this.getLine(row).length),
            end: this.pos(row + 1, 0),
            action: "remove",
            lines: ["", ""]
          });
        }
      };
      this.replace = function(range, text) {
        if (!(range instanceof Range))
          range = Range.fromPoints(range.start, range.end);
        if (text.length === 0 && range.isEmpty())
          return range.start;
        if (text == this.getTextRange(range))
          return range.end;
        this.remove(range);
        var end;
        if (text) {
          end = this.insert(range.start, text);
        } else {
          end = range.start;
        }
        return end;
      };
      this.applyDeltas = function(deltas) {
        for (var i = 0; i < deltas.length; i++) {
          this.applyDelta(deltas[i]);
        }
      };
      this.revertDeltas = function(deltas) {
        for (var i = deltas.length - 1; i >= 0; i--) {
          this.revertDelta(deltas[i]);
        }
      };
      this.applyDelta = function(delta, doNotValidate) {
        var isInsert = delta.action == "insert";
        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
          return;
        }
        if (isInsert && delta.lines.length > 2e4) {
          this.$splitAndapplyLargeDelta(delta, 2e4);
        } else {
          applyDelta(this.$lines, delta, doNotValidate);
          this._signal("change", delta);
        }
      };
      this.$safeApplyDelta = function(delta) {
        var docLength = this.$lines.length;
        if (delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength || delta.action == "insert" && delta.start.row <= docLength) {
          this.applyDelta(delta);
        }
      };
      this.$splitAndapplyLargeDelta = function(delta, MAX) {
        var lines = delta.lines;
        var l2 = lines.length - MAX + 1;
        var row = delta.start.row;
        var column = delta.start.column;
        for (var from = 0, to = 0; from < l2; from = to) {
          to += MAX - 1;
          var chunk = lines.slice(from, to);
          chunk.push("");
          this.applyDelta({
            start: this.pos(row + from, column),
            end: this.pos(row + to, column = 0),
            action: delta.action,
            lines: chunk
          }, true);
        }
        delta.lines = lines.slice(from);
        delta.start.row = row + from;
        delta.start.column = column;
        this.applyDelta(delta, true);
      };
      this.revertDelta = function(delta) {
        this.$safeApplyDelta({
          start: this.clonePos(delta.start),
          end: this.clonePos(delta.end),
          action: delta.action == "insert" ? "remove" : "insert",
          lines: delta.lines.slice()
        });
      };
      this.indexToPosition = function(index2, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l2 = lines.length; i < l2; i++) {
          index2 -= lines[i].length + newlineLength;
          if (index2 < 0)
            return {row: i, column: index2 + lines[i].length + newlineLength};
        }
        return {row: l2 - 1, column: index2 + lines[l2 - 1].length + newlineLength};
      };
      this.positionToIndex = function(pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index2 = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
          index2 += lines[i].length + newlineLength;
        return index2 + pos.column;
      };
    }).call(Document.prototype);
    exports2.Document = Document;
  });
  ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var BackgroundTokenizer = function(tokenizer, editor) {
      this.running = false;
      this.lines = [];
      this.states = [];
      this.currentLine = 0;
      this.tokenizer = tokenizer;
      var self2 = this;
      this.$worker = function() {
        if (!self2.running) {
          return;
        }
        var workerStart = new Date();
        var currentLine = self2.currentLine;
        var endLine = -1;
        var doc = self2.doc;
        var startLine = currentLine;
        while (self2.lines[currentLine])
          currentLine++;
        var len = doc.getLength();
        var processedLines = 0;
        self2.running = false;
        while (currentLine < len) {
          self2.$tokenizeRow(currentLine);
          endLine = currentLine;
          do {
            currentLine++;
          } while (self2.lines[currentLine]);
          processedLines++;
          if (processedLines % 5 === 0 && new Date() - workerStart > 20) {
            self2.running = setTimeout(self2.$worker, 20);
            break;
          }
        }
        self2.currentLine = currentLine;
        if (endLine == -1)
          endLine = currentLine;
        if (startLine <= endLine)
          self2.fireUpdateEvent(startLine, endLine);
      };
    };
    (function() {
      oop.implement(this, EventEmitter);
      this.setTokenizer = function(tokenizer) {
        this.tokenizer = tokenizer;
        this.lines = [];
        this.states = [];
        this.start(0);
      };
      this.setDocument = function(doc) {
        this.doc = doc;
        this.lines = [];
        this.states = [];
        this.stop();
      };
      this.fireUpdateEvent = function(firstRow, lastRow) {
        var data = {
          first: firstRow,
          last: lastRow
        };
        this._signal("update", {data});
      };
      this.start = function(startRow) {
        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
        this.lines.splice(this.currentLine, this.lines.length);
        this.states.splice(this.currentLine, this.states.length);
        this.stop();
        this.running = setTimeout(this.$worker, 700);
      };
      this.scheduleStart = function() {
        if (!this.running)
          this.running = setTimeout(this.$worker, 700);
      };
      this.$updateOnChange = function(delta) {
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;
        if (len === 0) {
          this.lines[startRow] = null;
        } else if (delta.action == "remove") {
          this.lines.splice(startRow, len + 1, null);
          this.states.splice(startRow, len + 1, null);
        } else {
          var args = Array(len + 1);
          args.unshift(startRow, 1);
          this.lines.splice.apply(this.lines, args);
          this.states.splice.apply(this.states, args);
        }
        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
        this.stop();
      };
      this.stop = function() {
        if (this.running)
          clearTimeout(this.running);
        this.running = false;
      };
      this.getTokens = function(row) {
        return this.lines[row] || this.$tokenizeRow(row);
      };
      this.getState = function(row) {
        if (this.currentLine == row)
          this.$tokenizeRow(row);
        return this.states[row] || "start";
      };
      this.$tokenizeRow = function(row) {
        var line = this.doc.getLine(row);
        var state = this.states[row - 1];
        var data = this.tokenizer.getLineTokens(line, state, row);
        if (this.states[row] + "" !== data.state + "") {
          this.states[row] = data.state;
          this.lines[row + 1] = null;
          if (this.currentLine > row + 1)
            this.currentLine = row + 1;
        } else if (this.currentLine == row) {
          this.currentLine = row + 1;
        }
        return this.lines[row] = data.tokens;
      };
    }).call(BackgroundTokenizer.prototype);
    exports2.BackgroundTokenizer = BackgroundTokenizer;
  });
  ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(require2, exports2, module2) {
    var lang = require2("./lib/lang");
    var oop = require2("./lib/oop");
    var Range = require2("./range").Range;
    var SearchHighlight = function(regExp, clazz, type2) {
      this.setRegexp(regExp);
      this.clazz = clazz;
      this.type = type2 || "text";
    };
    (function() {
      this.MAX_RANGES = 500;
      this.setRegexp = function(regExp) {
        if (this.regExp + "" == regExp + "")
          return;
        this.regExp = regExp;
        this.cache = [];
      };
      this.update = function(html, markerLayer, session, config) {
        if (!this.regExp)
          return;
        var start = config.firstRow, end = config.lastRow;
        for (var i = start; i <= end; i++) {
          var ranges = this.cache[i];
          if (ranges == null) {
            ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
            if (ranges.length > this.MAX_RANGES)
              ranges = ranges.slice(0, this.MAX_RANGES);
            ranges = ranges.map(function(match) {
              return new Range(i, match.offset, i, match.offset + match.length);
            });
            this.cache[i] = ranges.length ? ranges : "";
          }
          for (var j = ranges.length; j--; ) {
            markerLayer.drawSingleLineMarker(html, ranges[j].toScreenRange(session), this.clazz, config);
          }
        }
      };
    }).call(SearchHighlight.prototype);
    exports2.SearchHighlight = SearchHighlight;
  });
  ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var Range = require2("../range").Range;
    function FoldLine(foldData, folds) {
      this.foldData = foldData;
      if (Array.isArray(folds)) {
        this.folds = folds;
      } else {
        folds = this.folds = [folds];
      }
      var last = folds[folds.length - 1];
      this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
      this.start = this.range.start;
      this.end = this.range.end;
      this.folds.forEach(function(fold) {
        fold.setFoldLine(this);
      }, this);
    }
    (function() {
      this.shiftRow = function(shift) {
        this.start.row += shift;
        this.end.row += shift;
        this.folds.forEach(function(fold) {
          fold.start.row += shift;
          fold.end.row += shift;
        });
      };
      this.addFold = function(fold) {
        if (fold.sameRow) {
          if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
            throw new Error("Can't add a fold to this FoldLine as it has no connection");
          }
          this.folds.push(fold);
          this.folds.sort(function(a, b2) {
            return -a.range.compareEnd(b2.start.row, b2.start.column);
          });
          if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
          } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
          }
        } else if (fold.start.row == this.end.row) {
          this.folds.push(fold);
          this.end.row = fold.end.row;
          this.end.column = fold.end.column;
        } else if (fold.end.row == this.start.row) {
          this.folds.unshift(fold);
          this.start.row = fold.start.row;
          this.start.column = fold.start.column;
        } else {
          throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
        }
        fold.foldLine = this;
      };
      this.containsRow = function(row) {
        return row >= this.start.row && row <= this.end.row;
      };
      this.walk = function(callback, endRow, endColumn) {
        var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;
        if (endRow == null) {
          endRow = this.end.row;
          endColumn = this.end.column;
        }
        for (var i = 0; i < folds.length; i++) {
          fold = folds[i];
          cmp = fold.range.compareStart(endRow, endColumn);
          if (cmp == -1) {
            callback(null, endRow, endColumn, lastEnd, isNewRow);
            return;
          }
          stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
          stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
          if (stop || cmp === 0) {
            return;
          }
          isNewRow = !fold.sameRow;
          lastEnd = fold.end.column;
        }
        callback(null, endRow, endColumn, lastEnd, isNewRow);
      };
      this.getNextFoldTo = function(row, column) {
        var fold, cmp;
        for (var i = 0; i < this.folds.length; i++) {
          fold = this.folds[i];
          cmp = fold.range.compareEnd(row, column);
          if (cmp == -1) {
            return {
              fold,
              kind: "after"
            };
          } else if (cmp === 0) {
            return {
              fold,
              kind: "inside"
            };
          }
        }
        return null;
      };
      this.addRemoveChars = function(row, column, len) {
        var ret = this.getNextFoldTo(row, column), fold, folds;
        if (ret) {
          fold = ret.fold;
          if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
            window.console && window.console.log(row, column, fold);
          } else if (fold.start.row == row) {
            folds = this.folds;
            var i = folds.indexOf(fold);
            if (i === 0) {
              this.start.column += len;
            }
            for (i; i < folds.length; i++) {
              fold = folds[i];
              fold.start.column += len;
              if (!fold.sameRow) {
                return;
              }
              fold.end.column += len;
            }
            this.end.column += len;
          }
        }
      };
      this.split = function(row, column) {
        var pos = this.getNextFoldTo(row, column);
        if (!pos || pos.kind == "inside")
          return null;
        var fold = pos.fold;
        var folds = this.folds;
        var foldData = this.foldData;
        var i = folds.indexOf(fold);
        var foldBefore = folds[i - 1];
        this.end.row = foldBefore.end.row;
        this.end.column = foldBefore.end.column;
        folds = folds.splice(i, folds.length - i);
        var newFoldLine = new FoldLine(foldData, folds);
        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
        return newFoldLine;
      };
      this.merge = function(foldLineNext) {
        var folds = foldLineNext.folds;
        for (var i = 0; i < folds.length; i++) {
          this.addFold(folds[i]);
        }
        var foldData = this.foldData;
        foldData.splice(foldData.indexOf(foldLineNext), 1);
      };
      this.toString = function() {
        var ret = [this.range.toString() + ": ["];
        this.folds.forEach(function(fold) {
          ret.push("  " + fold.toString());
        });
        ret.push("]");
        return ret.join("\n");
      };
      this.idxToPosition = function(idx) {
        var lastFoldEndColumn = 0;
        for (var i = 0; i < this.folds.length; i++) {
          var fold = this.folds[i];
          idx -= fold.start.column - lastFoldEndColumn;
          if (idx < 0) {
            return {
              row: fold.start.row,
              column: fold.start.column + idx
            };
          }
          idx -= fold.placeholder.length;
          if (idx < 0) {
            return fold.start;
          }
          lastFoldEndColumn = fold.end.column;
        }
        return {
          row: this.end.row,
          column: this.end.column + idx
        };
      };
    }).call(FoldLine.prototype);
    exports2.FoldLine = FoldLine;
  });
  ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var Range = require2("./range").Range;
    var comparePoints = Range.comparePoints;
    var RangeList = function() {
      this.ranges = [];
      this.$bias = 1;
    };
    (function() {
      this.comparePoints = comparePoints;
      this.pointIndex = function(pos, excludeEdges, startIndex) {
        var list = this.ranges;
        for (var i = startIndex || 0; i < list.length; i++) {
          var range = list[i];
          var cmpEnd = comparePoints(pos, range.end);
          if (cmpEnd > 0)
            continue;
          var cmpStart = comparePoints(pos, range.start);
          if (cmpEnd === 0)
            return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
          if (cmpStart > 0 || cmpStart === 0 && !excludeEdges)
            return i;
          return -i - 1;
        }
        return -i - 1;
      };
      this.add = function(range) {
        var excludeEdges = !range.isEmpty();
        var startIndex = this.pointIndex(range.start, excludeEdges);
        if (startIndex < 0)
          startIndex = -startIndex - 1;
        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
        if (endIndex < 0)
          endIndex = -endIndex - 1;
        else
          endIndex++;
        return this.ranges.splice(startIndex, endIndex - startIndex, range);
      };
      this.addList = function(list) {
        var removed = [];
        for (var i = list.length; i--; ) {
          removed.push.apply(removed, this.add(list[i]));
        }
        return removed;
      };
      this.substractPoint = function(pos) {
        var i = this.pointIndex(pos);
        if (i >= 0)
          return this.ranges.splice(i, 1);
      };
      this.merge = function() {
        var removed = [];
        var list = this.ranges;
        list = list.sort(function(a, b2) {
          return comparePoints(a.start, b2.start);
        });
        var next = list[0], range;
        for (var i = 1; i < list.length; i++) {
          range = next;
          next = list[i];
          var cmp = comparePoints(range.end, next.start);
          if (cmp < 0)
            continue;
          if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
            continue;
          if (comparePoints(range.end, next.end) < 0) {
            range.end.row = next.end.row;
            range.end.column = next.end.column;
          }
          list.splice(i, 1);
          removed.push(next);
          next = range;
          i--;
        }
        this.ranges = list;
        return removed;
      };
      this.contains = function(row, column) {
        return this.pointIndex({row, column}) >= 0;
      };
      this.containsPoint = function(pos) {
        return this.pointIndex(pos) >= 0;
      };
      this.rangeAtPoint = function(pos) {
        var i = this.pointIndex(pos);
        if (i >= 0)
          return this.ranges[i];
      };
      this.clipRows = function(startRow, endRow) {
        var list = this.ranges;
        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
          return [];
        var startIndex = this.pointIndex({row: startRow, column: 0});
        if (startIndex < 0)
          startIndex = -startIndex - 1;
        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
        if (endIndex < 0)
          endIndex = -endIndex - 1;
        var clipped = [];
        for (var i = startIndex; i < endIndex; i++) {
          clipped.push(list[i]);
        }
        return clipped;
      };
      this.removeAll = function() {
        return this.ranges.splice(0, this.ranges.length);
      };
      this.attach = function(session) {
        if (this.session)
          this.detach();
        this.session = session;
        this.onChange = this.$onChange.bind(this);
        this.session.on("change", this.onChange);
      };
      this.detach = function() {
        if (!this.session)
          return;
        this.session.removeListener("change", this.onChange);
        this.session = null;
      };
      this.$onChange = function(delta) {
        var start = delta.start;
        var end = delta.end;
        var startRow = start.row;
        var endRow = end.row;
        var ranges = this.ranges;
        for (var i = 0, n2 = ranges.length; i < n2; i++) {
          var r2 = ranges[i];
          if (r2.end.row >= startRow)
            break;
        }
        if (delta.action == "insert") {
          var lineDif = endRow - startRow;
          var colDiff = -start.column + end.column;
          for (; i < n2; i++) {
            var r2 = ranges[i];
            if (r2.start.row > startRow)
              break;
            if (r2.start.row == startRow && r2.start.column >= start.column) {
              if (r2.start.column == start.column && this.$bias <= 0)
                ;
              else {
                r2.start.column += colDiff;
                r2.start.row += lineDif;
              }
            }
            if (r2.end.row == startRow && r2.end.column >= start.column) {
              if (r2.end.column == start.column && this.$bias < 0) {
                continue;
              }
              if (r2.end.column == start.column && colDiff > 0 && i < n2 - 1) {
                if (r2.end.column > r2.start.column && r2.end.column == ranges[i + 1].start.column)
                  r2.end.column -= colDiff;
              }
              r2.end.column += colDiff;
              r2.end.row += lineDif;
            }
          }
        } else {
          var lineDif = startRow - endRow;
          var colDiff = start.column - end.column;
          for (; i < n2; i++) {
            var r2 = ranges[i];
            if (r2.start.row > endRow)
              break;
            if (r2.end.row < endRow && (startRow < r2.end.row || startRow == r2.end.row && start.column < r2.end.column)) {
              r2.end.row = startRow;
              r2.end.column = start.column;
            } else if (r2.end.row == endRow) {
              if (r2.end.column <= end.column) {
                if (lineDif || r2.end.column > start.column) {
                  r2.end.column = start.column;
                  r2.end.row = start.row;
                }
              } else {
                r2.end.column += colDiff;
                r2.end.row += lineDif;
              }
            } else if (r2.end.row > endRow) {
              r2.end.row += lineDif;
            }
            if (r2.start.row < endRow && (startRow < r2.start.row || startRow == r2.start.row && start.column < r2.start.column)) {
              r2.start.row = startRow;
              r2.start.column = start.column;
            } else if (r2.start.row == endRow) {
              if (r2.start.column <= end.column) {
                if (lineDif || r2.start.column > start.column) {
                  r2.start.column = start.column;
                  r2.start.row = start.row;
                }
              } else {
                r2.start.column += colDiff;
                r2.start.row += lineDif;
              }
            } else if (r2.start.row > endRow) {
              r2.start.row += lineDif;
            }
          }
        }
        if (lineDif != 0 && i < n2) {
          for (; i < n2; i++) {
            var r2 = ranges[i];
            r2.start.row += lineDif;
            r2.end.row += lineDif;
          }
        }
      };
    }).call(RangeList.prototype);
    exports2.RangeList = RangeList;
  });
  ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range_list", "ace/lib/oop"], function(require2, exports2, module2) {
    var RangeList = require2("../range_list").RangeList;
    var oop = require2("../lib/oop");
    var Fold = exports2.Fold = function(range, placeholder) {
      this.foldLine = null;
      this.placeholder = placeholder;
      this.range = range;
      this.start = range.start;
      this.end = range.end;
      this.sameRow = range.start.row == range.end.row;
      this.subFolds = this.ranges = [];
    };
    oop.inherits(Fold, RangeList);
    (function() {
      this.toString = function() {
        return '"' + this.placeholder + '" ' + this.range.toString();
      };
      this.setFoldLine = function(foldLine2) {
        this.foldLine = foldLine2;
        this.subFolds.forEach(function(fold) {
          fold.setFoldLine(foldLine2);
        });
      };
      this.clone = function() {
        var range = this.range.clone();
        var fold = new Fold(range, this.placeholder);
        this.subFolds.forEach(function(subFold) {
          fold.subFolds.push(subFold.clone());
        });
        fold.collapseChildren = this.collapseChildren;
        return fold;
      };
      this.addSubFold = function(fold) {
        if (this.range.isEqual(fold))
          return;
        consumeRange(fold, this.start);
        var row = fold.start.row, column = fold.start.column;
        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
          cmp = this.subFolds[i].range.compare(row, column);
          if (cmp != 1)
            break;
        }
        var afterStart = this.subFolds[i];
        var firstConsumed = 0;
        if (cmp == 0) {
          if (afterStart.range.containsRange(fold))
            return afterStart.addSubFold(fold);
          else
            firstConsumed = 1;
        }
        var row = fold.range.end.row, column = fold.range.end.column;
        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
          cmp = this.subFolds[j].range.compare(row, column);
          if (cmp != 1)
            break;
        }
        if (cmp == 0)
          j++;
        var consumedFolds = this.subFolds.splice(i, j - i, fold);
        var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
        for (var k2 = firstConsumed; k2 < last; k2++) {
          fold.addSubFold(consumedFolds[k2]);
        }
        fold.setFoldLine(this.foldLine);
        return fold;
      };
      this.restoreRange = function(range) {
        return restoreRange(range, this.start);
      };
    }).call(Fold.prototype);
    function consumePoint(point, anchor) {
      point.row -= anchor.row;
      if (point.row == 0)
        point.column -= anchor.column;
    }
    function consumeRange(range, anchor) {
      consumePoint(range.start, anchor);
      consumePoint(range.end, anchor);
    }
    function restorePoint(point, anchor) {
      if (point.row == 0)
        point.column += anchor.column;
      point.row += anchor.row;
    }
    function restoreRange(range, anchor) {
      restorePoint(range.start, anchor);
      restorePoint(range.end, anchor);
    }
  });
  ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator"], function(require2, exports2, module2) {
    var Range = require2("../range").Range;
    var FoldLine = require2("./fold_line").FoldLine;
    var Fold = require2("./fold").Fold;
    var TokenIterator = require2("../token_iterator").TokenIterator;
    function Folding() {
      this.getFoldAt = function(row, column, side) {
        var foldLine2 = this.getFoldLine(row);
        if (!foldLine2)
          return null;
        var folds = foldLine2.folds;
        for (var i = 0; i < folds.length; i++) {
          var range = folds[i].range;
          if (range.contains(row, column)) {
            if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
              continue;
            } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
              continue;
            }
            return folds[i];
          }
        }
      };
      this.getFoldsInRange = function(range) {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];
        start.column += 1;
        end.column -= 1;
        for (var i = 0; i < foldLines.length; i++) {
          var cmp = foldLines[i].range.compareRange(range);
          if (cmp == 2) {
            continue;
          } else if (cmp == -2) {
            break;
          }
          var folds = foldLines[i].folds;
          for (var j = 0; j < folds.length; j++) {
            var fold = folds[j];
            cmp = fold.range.compareRange(range);
            if (cmp == -2) {
              break;
            } else if (cmp == 2) {
              continue;
            } else if (cmp == 42) {
              break;
            }
            foundFolds.push(fold);
          }
        }
        start.column -= 1;
        end.column += 1;
        return foundFolds;
      };
      this.getFoldsInRangeList = function(ranges) {
        if (Array.isArray(ranges)) {
          var folds = [];
          ranges.forEach(function(range) {
            folds = folds.concat(this.getFoldsInRange(range));
          }, this);
        } else {
          var folds = this.getFoldsInRange(ranges);
        }
        return folds;
      };
      this.getAllFolds = function() {
        var folds = [];
        var foldLines = this.$foldData;
        for (var i = 0; i < foldLines.length; i++)
          for (var j = 0; j < foldLines[i].folds.length; j++)
            folds.push(foldLines[i].folds[j]);
        return folds;
      };
      this.getFoldStringAt = function(row, column, trim, foldLine2) {
        foldLine2 = foldLine2 || this.getFoldLine(row);
        if (!foldLine2)
          return null;
        var lastFold = {
          end: {column: 0}
        };
        var str2, fold;
        for (var i = 0; i < foldLine2.folds.length; i++) {
          fold = foldLine2.folds[i];
          var cmp = fold.range.compareEnd(row, column);
          if (cmp == -1) {
            str2 = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
            break;
          } else if (cmp === 0) {
            return null;
          }
          lastFold = fold;
        }
        if (!str2)
          str2 = this.getLine(fold.start.row).substring(lastFold.end.column);
        if (trim == -1)
          return str2.substring(0, column - lastFold.end.column);
        else if (trim == 1)
          return str2.substring(column - lastFold.end.column);
        else
          return str2;
      };
      this.getFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
          i = foldData.indexOf(startFoldLine);
        if (i == -1)
          i = 0;
        for (i; i < foldData.length; i++) {
          var foldLine2 = foldData[i];
          if (foldLine2.start.row <= docRow && foldLine2.end.row >= docRow) {
            return foldLine2;
          } else if (foldLine2.end.row > docRow) {
            return null;
          }
        }
        return null;
      };
      this.getNextFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
          i = foldData.indexOf(startFoldLine);
        if (i == -1)
          i = 0;
        for (i; i < foldData.length; i++) {
          var foldLine2 = foldData[i];
          if (foldLine2.end.row >= docRow) {
            return foldLine2;
          }
        }
        return null;
      };
      this.getFoldedRowCount = function(first, last) {
        var foldData = this.$foldData, rowCount = last - first + 1;
        for (var i = 0; i < foldData.length; i++) {
          var foldLine2 = foldData[i], end = foldLine2.end.row, start = foldLine2.start.row;
          if (end >= last) {
            if (start < last) {
              if (start >= first)
                rowCount -= last - start;
              else
                rowCount = 0;
            }
            break;
          } else if (end >= first) {
            if (start >= first)
              rowCount -= end - start;
            else
              rowCount -= end - first + 1;
          }
        }
        return rowCount;
      };
      this.$addFoldLine = function(foldLine2) {
        this.$foldData.push(foldLine2);
        this.$foldData.sort(function(a, b2) {
          return a.start.row - b2.start.row;
        });
        return foldLine2;
      };
      this.addFold = function(placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        var fold;
        if (placeholder instanceof Fold)
          fold = placeholder;
        else {
          fold = new Fold(range, placeholder);
          fold.collapseChildren = range.collapseChildren;
        }
        this.$clipRangeToDocument(fold.range);
        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;
        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold && endFold == startFold)
          return startFold.addSubFold(fold);
        if (startFold && !startFold.range.isStart(startRow, startColumn))
          this.removeFold(startFold);
        if (endFold && !endFold.range.isEnd(endRow, endColumn))
          this.removeFold(endFold);
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length > 0) {
          this.removeFolds(folds);
          if (!fold.collapseChildren) {
            folds.forEach(function(subFold) {
              fold.addSubFold(subFold);
            });
          }
        }
        for (var i = 0; i < foldData.length; i++) {
          var foldLine2 = foldData[i];
          if (endRow == foldLine2.start.row) {
            foldLine2.addFold(fold);
            added = true;
            break;
          } else if (startRow == foldLine2.end.row) {
            foldLine2.addFold(fold);
            added = true;
            if (!fold.sameRow) {
              var foldLineNext = foldData[i + 1];
              if (foldLineNext && foldLineNext.start.row == endRow) {
                foldLine2.merge(foldLineNext);
                break;
              }
            }
            break;
          } else if (endRow <= foldLine2.start.row) {
            break;
          }
        }
        if (!added)
          foldLine2 = this.$addFoldLine(new FoldLine(this.$foldData, fold));
        if (this.$useWrapMode)
          this.$updateWrapData(foldLine2.start.row, foldLine2.start.row);
        else
          this.$updateRowLengthCache(foldLine2.start.row, foldLine2.start.row);
        this.$modified = true;
        this._signal("changeFold", {data: fold, action: "add"});
        return fold;
      };
      this.addFolds = function(folds) {
        folds.forEach(function(fold) {
          this.addFold(fold);
        }, this);
      };
      this.removeFold = function(fold) {
        var foldLine2 = fold.foldLine;
        var startRow = foldLine2.start.row;
        var endRow = foldLine2.end.row;
        var foldLines = this.$foldData;
        var folds = foldLine2.folds;
        if (folds.length == 1) {
          foldLines.splice(foldLines.indexOf(foldLine2), 1);
        } else if (foldLine2.range.isEnd(fold.end.row, fold.end.column)) {
          folds.pop();
          foldLine2.end.row = folds[folds.length - 1].end.row;
          foldLine2.end.column = folds[folds.length - 1].end.column;
        } else if (foldLine2.range.isStart(fold.start.row, fold.start.column)) {
          folds.shift();
          foldLine2.start.row = folds[0].start.row;
          foldLine2.start.column = folds[0].start.column;
        } else if (fold.sameRow) {
          folds.splice(folds.indexOf(fold), 1);
        } else {
          var newFoldLine = foldLine2.split(fold.start.row, fold.start.column);
          folds = newFoldLine.folds;
          folds.shift();
          newFoldLine.start.row = folds[0].start.row;
          newFoldLine.start.column = folds[0].start.column;
        }
        if (!this.$updating) {
          if (this.$useWrapMode)
            this.$updateWrapData(startRow, endRow);
          else
            this.$updateRowLengthCache(startRow, endRow);
        }
        this.$modified = true;
        this._signal("changeFold", {data: fold, action: "remove"});
      };
      this.removeFolds = function(folds) {
        var cloneFolds = [];
        for (var i = 0; i < folds.length; i++) {
          cloneFolds.push(folds[i]);
        }
        cloneFolds.forEach(function(fold) {
          this.removeFold(fold);
        }, this);
        this.$modified = true;
      };
      this.expandFold = function(fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function(subFold) {
          fold.restoreRange(subFold);
          this.addFold(subFold);
        }, this);
        if (fold.collapseChildren > 0) {
          this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
        }
        fold.subFolds = [];
      };
      this.expandFolds = function(folds) {
        folds.forEach(function(fold) {
          this.expandFold(fold);
        }, this);
      };
      this.unfold = function(location, expandInner) {
        var range, folds;
        if (location == null) {
          range = new Range(0, 0, this.getLength(), 0);
          if (expandInner == null)
            expandInner = true;
        } else if (typeof location == "number")
          range = new Range(location, 0, location, this.getLine(location).length);
        else if ("row" in location)
          range = Range.fromPoints(location, location);
        else
          range = location;
        folds = this.getFoldsInRangeList(range);
        if (expandInner != false) {
          this.removeFolds(folds);
        } else {
          this.expandFolds(folds);
        }
        if (folds.length)
          return folds;
      };
      this.isRowFolded = function(docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
      };
      this.getRowFoldEnd = function(docRow, startFoldRow) {
        var foldLine2 = this.getFoldLine(docRow, startFoldRow);
        return foldLine2 ? foldLine2.end.row : docRow;
      };
      this.getRowFoldStart = function(docRow, startFoldRow) {
        var foldLine2 = this.getFoldLine(docRow, startFoldRow);
        return foldLine2 ? foldLine2.start.row : docRow;
      };
      this.getFoldDisplayLine = function(foldLine2, endRow, endColumn, startRow, startColumn) {
        if (startRow == null)
          startRow = foldLine2.start.row;
        if (startColumn == null)
          startColumn = 0;
        if (endRow == null)
          endRow = foldLine2.end.row;
        if (endColumn == null)
          endColumn = this.getLine(endRow).length;
        var doc = this.doc;
        var textLine = "";
        foldLine2.walk(function(placeholder, row, column, lastColumn) {
          if (row < startRow)
            return;
          if (row == startRow) {
            if (column < startColumn)
              return;
            lastColumn = Math.max(startColumn, lastColumn);
          }
          if (placeholder != null) {
            textLine += placeholder;
          } else {
            textLine += doc.getLine(row).substring(lastColumn, column);
          }
        }, endRow, endColumn);
        return textLine;
      };
      this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
        var foldLine2 = this.getFoldLine(row);
        if (!foldLine2) {
          var line;
          line = this.doc.getLine(row);
          return line.substring(startColumn || 0, endColumn || line.length);
        } else {
          return this.getFoldDisplayLine(foldLine2, row, endColumn, startRow, startColumn);
        }
      };
      this.$cloneFoldData = function() {
        var fd2 = [];
        fd2 = this.$foldData.map(function(foldLine2) {
          var folds = foldLine2.folds.map(function(fold) {
            return fold.clone();
          });
          return new FoldLine(fd2, folds);
        });
        return fd2;
      };
      this.toggleFold = function(tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;
        if (range.isEmpty()) {
          var cursor = range.start;
          fold = this.getFoldAt(cursor.row, cursor.column);
          if (fold) {
            this.expandFold(fold);
            return;
          } else if (bracketPos = this.findMatchingBracket(cursor)) {
            if (range.comparePoint(bracketPos) == 1) {
              range.end = bracketPos;
            } else {
              range.start = bracketPos;
              range.start.column++;
              range.end.column--;
            }
          } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
            if (range.comparePoint(bracketPos) == 1)
              range.end = bracketPos;
            else
              range.start = bracketPos;
            range.start.column++;
          } else {
            range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
          }
        } else {
          var folds = this.getFoldsInRange(range);
          if (tryToUnfold && folds.length) {
            this.expandFolds(folds);
            return;
          } else if (folds.length == 1) {
            fold = folds[0];
          }
        }
        if (!fold)
          fold = this.getFoldAt(range.start.row, range.start.column);
        if (fold && fold.range.toString() == range.toString()) {
          this.expandFold(fold);
          return;
        }
        var placeholder = "...";
        if (!range.isMultiLine()) {
          placeholder = this.getTextRange(range);
          if (placeholder.length < 4)
            return;
          placeholder = placeholder.trim().substring(0, 2) + "..";
        }
        this.addFold(placeholder, range);
      };
      this.getCommentFoldRange = function(row, column, dir) {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        var type2 = token && token.type;
        if (token && /^comment|string/.test(type2)) {
          type2 = type2.match(/comment|string/)[0];
          if (type2 == "comment")
            type2 += "|doc-start";
          var re2 = new RegExp(type2);
          var range = new Range();
          if (dir != 1) {
            do {
              token = iterator.stepBackward();
            } while (token && re2.test(token.type));
            iterator.stepForward();
          }
          range.start.row = iterator.getCurrentTokenRow();
          range.start.column = iterator.getCurrentTokenColumn() + 2;
          iterator = new TokenIterator(this, row, column);
          if (dir != -1) {
            var lastRow = -1;
            do {
              token = iterator.stepForward();
              if (lastRow == -1) {
                var state = this.getState(iterator.$row);
                if (!re2.test(state))
                  lastRow = iterator.$row;
              } else if (iterator.$row > lastRow) {
                break;
              }
            } while (token && re2.test(token.type));
            token = iterator.stepBackward();
          } else
            token = iterator.getCurrentToken();
          range.end.row = iterator.getCurrentTokenRow();
          range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
          return range;
        }
      };
      this.foldAll = function(startRow, endRow, depth, test) {
        if (depth == void 0)
          depth = 1e5;
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets)
          return;
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row < endRow; row++) {
          if (foldWidgets[row] == null)
            foldWidgets[row] = this.getFoldWidget(row);
          if (foldWidgets[row] != "start")
            continue;
          if (test && !test(row))
            continue;
          var range = this.getFoldWidgetRange(row);
          if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
            row = range.end.row;
            range.collapseChildren = depth;
            this.addFold("...", range);
          }
        }
      };
      this.foldToLevel = function(level) {
        this.foldAll();
        while (level-- > 0)
          this.unfold(null, false);
      };
      this.foldAllComments = function() {
        var session = this;
        this.foldAll(null, null, null, function(row) {
          var tokens = session.getTokens(row);
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (token.type == "text" && /^\s+$/.test(token.value))
              continue;
            if (/comment/.test(token.type))
              return true;
            return false;
          }
        });
      };
      this.$foldStyles = {
        manual: 1,
        markbegin: 1,
        markbeginend: 1
      };
      this.$foldStyle = "markbegin";
      this.setFoldStyle = function(style) {
        if (!this.$foldStyles[style])
          throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
        if (this.$foldStyle == style)
          return;
        this.$foldStyle = style;
        if (style == "manual")
          this.unfold();
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
      };
      this.$setFolding = function(foldMode) {
        if (this.$foldMode == foldMode)
          return;
        this.$foldMode = foldMode;
        this.off("change", this.$updateFoldWidgets);
        this.off("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
        this._signal("changeAnnotation");
        if (!foldMode || this.$foldStyle == "manual") {
          this.foldWidgets = null;
          return;
        }
        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
        this.on("change", this.$updateFoldWidgets);
        this.on("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
      };
      this.getParentFoldRangeData = function(row, ignoreCurrent) {
        var fw = this.foldWidgets;
        if (!fw || ignoreCurrent && fw[row])
          return {};
        var i = row - 1, firstRange;
        while (i >= 0) {
          var c2 = fw[i];
          if (c2 == null)
            c2 = fw[i] = this.getFoldWidget(i);
          if (c2 == "start") {
            var range = this.getFoldWidgetRange(i);
            if (!firstRange)
              firstRange = range;
            if (range && range.end.row >= row)
              break;
          }
          i--;
        }
        return {
          range: i !== -1 && range,
          firstRange
        };
      };
      this.onFoldWidgetClick = function(row, e2) {
        e2 = e2.domEvent;
        var options = {
          children: e2.shiftKey,
          all: e2.ctrlKey || e2.metaKey,
          siblings: e2.altKey
        };
        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
          var el = e2.target || e2.srcElement;
          if (el && /ace_fold-widget/.test(el.className))
            el.className += " ace_invalid";
        }
      };
      this.$toggleFoldWidget = function(row, options) {
        if (!this.getFoldWidget)
          return;
        var type2 = this.getFoldWidget(row);
        var line = this.getLine(row);
        var dir = type2 === "end" ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
        if (fold) {
          if (options.children || options.all)
            this.removeFold(fold);
          else
            this.expandFold(fold);
          return fold;
        }
        var range = this.getFoldWidgetRange(row, true);
        if (range && !range.isMultiLine()) {
          fold = this.getFoldAt(range.start.row, range.start.column, 1);
          if (fold && range.isEqual(fold.range)) {
            this.removeFold(fold);
            return fold;
          }
        }
        if (options.siblings) {
          var data = this.getParentFoldRangeData(row);
          if (data.range) {
            var startRow = data.range.start.row + 1;
            var endRow = data.range.end.row;
          }
          this.foldAll(startRow, endRow, options.all ? 1e4 : 0);
        } else if (options.children) {
          endRow = range ? range.end.row : this.getLength();
          this.foldAll(row + 1, endRow, options.all ? 1e4 : 0);
        } else if (range) {
          if (options.all)
            range.collapseChildren = 1e4;
          this.addFold("...", range);
        }
        return range;
      };
      this.toggleFoldWidget = function(toggleParent) {
        var row = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});
        if (range)
          return;
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;
        if (range) {
          row = range.start.row;
          var fold = this.getFoldAt(row, this.getLine(row).length, 1);
          if (fold) {
            this.removeFold(fold);
          } else {
            this.addFold("...", range);
          }
        }
      };
      this.updateFoldWidgets = function(delta) {
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) {
          this.foldWidgets[firstRow] = null;
        } else if (delta.action == "remove") {
          this.foldWidgets.splice(firstRow, len + 1, null);
        } else {
          var args = Array(len + 1);
          args.unshift(firstRow, 1);
          this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
      };
      this.tokenizerUpdateFoldWidgets = function(e2) {
        var rows = e2.data;
        if (rows.first != rows.last) {
          if (this.foldWidgets.length > rows.first)
            this.foldWidgets.splice(rows.first, this.foldWidgets.length);
        }
      };
    }
    exports2.Folding = Folding;
  });
  ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function(require2, exports2, module2) {
    var TokenIterator = require2("../token_iterator").TokenIterator;
    var Range = require2("../range").Range;
    function BracketMatch() {
      this.findMatchingBracket = function(position, chr) {
        if (position.column == 0)
          return null;
        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
        if (charBeforeCursor == "")
          return null;
        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match)
          return null;
        if (match[1])
          return this.$findClosingBracket(match[1], position);
        else
          return this.$findOpeningBracket(match[2], position);
      };
      this.getBracketRange = function(pos) {
        var line = this.getLine(pos.row);
        var before = true, range;
        var chr = line.charAt(pos.column - 1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
          chr = line.charAt(pos.column);
          pos = {row: pos.row, column: pos.column + 1};
          match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
          before = false;
        }
        if (!match)
          return null;
        if (match[1]) {
          var bracketPos = this.$findClosingBracket(match[1], pos);
          if (!bracketPos)
            return null;
          range = Range.fromPoints(pos, bracketPos);
          if (!before) {
            range.end.column++;
            range.start.column--;
          }
          range.cursor = range.end;
        } else {
          var bracketPos = this.$findOpeningBracket(match[2], pos);
          if (!bracketPos)
            return null;
          range = Range.fromPoints(bracketPos, pos);
          if (!before) {
            range.start.column++;
            range.end.column--;
          }
          range.cursor = range.start;
        }
        return range;
      };
      this.getMatchingBracketRanges = function(pos) {
        var line = this.getLine(pos.row);
        var chr = line.charAt(pos.column - 1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
          chr = line.charAt(pos.column);
          pos = {row: pos.row, column: pos.column + 1};
          match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        }
        if (!match)
          return null;
        var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
        var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos) : this.$findOpeningBracket(match[2], pos);
        if (!bracketPos)
          return [startRange];
        var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);
        return [startRange, endRange];
      };
      this.$brackets = {
        ")": "(",
        "(": ")",
        "]": "[",
        "[": "]",
        "{": "}",
        "}": "{",
        "<": ">",
        ">": "<"
      };
      this.$findOpeningBracket = function(bracket, position, typeRe) {
        var openBracket = this.$brackets[bracket];
        var depth = 1;
        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
          token = iterator.stepForward();
        if (!token)
          return;
        if (!typeRe) {
          typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)") + ")+");
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;
        while (true) {
          while (valueIndex >= 0) {
            var chr = value.charAt(valueIndex);
            if (chr == openBracket) {
              depth -= 1;
              if (depth == 0) {
                return {
                  row: iterator.getCurrentTokenRow(),
                  column: valueIndex + iterator.getCurrentTokenColumn()
                };
              }
            } else if (chr == bracket) {
              depth += 1;
            }
            valueIndex -= 1;
          }
          do {
            token = iterator.stepBackward();
          } while (token && !typeRe.test(token.type));
          if (token == null)
            break;
          value = token.value;
          valueIndex = value.length - 1;
        }
        return null;
      };
      this.$findClosingBracket = function(bracket, position, typeRe) {
        var closingBracket = this.$brackets[bracket];
        var depth = 1;
        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
          token = iterator.stepForward();
        if (!token)
          return;
        if (!typeRe) {
          typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)") + ")+");
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn();
        while (true) {
          var value = token.value;
          var valueLength = value.length;
          while (valueIndex < valueLength) {
            var chr = value.charAt(valueIndex);
            if (chr == closingBracket) {
              depth -= 1;
              if (depth == 0) {
                return {
                  row: iterator.getCurrentTokenRow(),
                  column: valueIndex + iterator.getCurrentTokenColumn()
                };
              }
            } else if (chr == bracket) {
              depth += 1;
            }
            valueIndex += 1;
          }
          do {
            token = iterator.stepForward();
          } while (token && !typeRe.test(token.type));
          if (token == null)
            break;
          valueIndex = 0;
        }
        return null;
      };
    }
    exports2.BracketMatch = BracketMatch;
  });
  ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/bidihandler", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var lang = require2("./lib/lang");
    var BidiHandler = require2("./bidihandler").BidiHandler;
    var config = require2("./config");
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var Selection = require2("./selection").Selection;
    var TextMode = require2("./mode/text").Mode;
    var Range = require2("./range").Range;
    var Document = require2("./document").Document;
    var BackgroundTokenizer = require2("./background_tokenizer").BackgroundTokenizer;
    var SearchHighlight = require2("./search_highlight").SearchHighlight;
    var EditSession = function(text, mode) {
      this.$breakpoints = [];
      this.$decorations = [];
      this.$frontMarkers = {};
      this.$backMarkers = {};
      this.$markerId = 1;
      this.$undoSelect = true;
      this.$foldData = [];
      this.id = "session" + ++EditSession.$uid;
      this.$foldData.toString = function() {
        return this.join("\n");
      };
      this.on("changeFold", this.onChangeFold.bind(this));
      this.$onChange = this.onChange.bind(this);
      if (typeof text != "object" || !text.getLine)
        text = new Document(text);
      this.setDocument(text);
      this.selection = new Selection(this);
      this.$bidiHandler = new BidiHandler(this);
      config.resetOptions(this);
      this.setMode(mode);
      config._signal("session", this);
    };
    EditSession.$uid = 0;
    (function() {
      oop.implement(this, EventEmitter);
      this.setDocument = function(doc) {
        if (this.doc)
          this.doc.removeListener("change", this.$onChange);
        this.doc = doc;
        doc.on("change", this.$onChange);
        if (this.bgTokenizer)
          this.bgTokenizer.setDocument(this.getDocument());
        this.resetCaches();
      };
      this.getDocument = function() {
        return this.doc;
      };
      this.$resetRowCache = function(docRow) {
        if (!docRow) {
          this.$docRowCache = [];
          this.$screenRowCache = [];
          return;
        }
        var l2 = this.$docRowCache.length;
        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
        if (l2 > i) {
          this.$docRowCache.splice(i, l2);
          this.$screenRowCache.splice(i, l2);
        }
      };
      this.$getRowCacheIndex = function(cacheArray, val) {
        var low = 0;
        var hi2 = cacheArray.length - 1;
        while (low <= hi2) {
          var mid = low + hi2 >> 1;
          var c2 = cacheArray[mid];
          if (val > c2)
            low = mid + 1;
          else if (val < c2)
            hi2 = mid - 1;
          else
            return mid;
        }
        return low - 1;
      };
      this.resetCaches = function() {
        this.$modified = true;
        this.$wrapData = [];
        this.$rowLengthCache = [];
        this.$resetRowCache(0);
        if (this.bgTokenizer)
          this.bgTokenizer.start(0);
      };
      this.onChangeFold = function(e2) {
        var fold = e2.data;
        this.$resetRowCache(fold.start.row);
      };
      this.onChange = function(delta) {
        this.$modified = true;
        this.$bidiHandler.onChange(delta);
        this.$resetRowCache(delta.start.row);
        var removedFolds = this.$updateInternalDataOnChange(delta);
        if (!this.$fromUndo && this.$undoManager) {
          if (removedFolds && removedFolds.length) {
            this.$undoManager.add({
              action: "removeFolds",
              folds: removedFolds
            }, this.mergeUndoDeltas);
            this.mergeUndoDeltas = true;
          }
          this.$undoManager.add(delta, this.mergeUndoDeltas);
          this.mergeUndoDeltas = true;
          this.$informUndoManager.schedule();
        }
        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
        this._signal("change", delta);
      };
      this.setValue = function(text) {
        this.doc.setValue(text);
        this.selection.moveTo(0, 0);
        this.$resetRowCache(0);
        this.setUndoManager(this.$undoManager);
        this.getUndoManager().reset();
      };
      this.getValue = this.toString = function() {
        return this.doc.getValue();
      };
      this.getSelection = function() {
        return this.selection;
      };
      this.getState = function(row) {
        return this.bgTokenizer.getState(row);
      };
      this.getTokens = function(row) {
        return this.bgTokenizer.getTokens(row);
      };
      this.getTokenAt = function(row, column) {
        var tokens = this.bgTokenizer.getTokens(row);
        var token, c2 = 0;
        if (column == null) {
          var i = tokens.length - 1;
          c2 = this.getLine(row).length;
        } else {
          for (var i = 0; i < tokens.length; i++) {
            c2 += tokens[i].value.length;
            if (c2 >= column)
              break;
          }
        }
        token = tokens[i];
        if (!token)
          return null;
        token.index = i;
        token.start = c2 - token.value.length;
        return token;
      };
      this.setUndoManager = function(undoManager) {
        this.$undoManager = undoManager;
        if (this.$informUndoManager)
          this.$informUndoManager.cancel();
        if (undoManager) {
          var self2 = this;
          undoManager.addSession(this);
          this.$syncInformUndoManager = function() {
            self2.$informUndoManager.cancel();
            self2.mergeUndoDeltas = false;
          };
          this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
        } else {
          this.$syncInformUndoManager = function() {
          };
        }
      };
      this.markUndoGroup = function() {
        if (this.$syncInformUndoManager)
          this.$syncInformUndoManager();
      };
      this.$defaultUndoManager = {
        undo: function() {
        },
        redo: function() {
        },
        hasUndo: function() {
        },
        hasRedo: function() {
        },
        reset: function() {
        },
        add: function() {
        },
        addSelection: function() {
        },
        startNewGroup: function() {
        },
        addSession: function() {
        }
      };
      this.getUndoManager = function() {
        return this.$undoManager || this.$defaultUndoManager;
      };
      this.getTabString = function() {
        if (this.getUseSoftTabs()) {
          return lang.stringRepeat(" ", this.getTabSize());
        } else {
          return "	";
        }
      };
      this.setUseSoftTabs = function(val) {
        this.setOption("useSoftTabs", val);
      };
      this.getUseSoftTabs = function() {
        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
      };
      this.setTabSize = function(tabSize) {
        this.setOption("tabSize", tabSize);
      };
      this.getTabSize = function() {
        return this.$tabSize;
      };
      this.isTabStop = function(position) {
        return this.$useSoftTabs && position.column % this.$tabSize === 0;
      };
      this.setNavigateWithinSoftTabs = function(navigateWithinSoftTabs) {
        this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
      };
      this.getNavigateWithinSoftTabs = function() {
        return this.$navigateWithinSoftTabs;
      };
      this.$overwrite = false;
      this.setOverwrite = function(overwrite) {
        this.setOption("overwrite", overwrite);
      };
      this.getOverwrite = function() {
        return this.$overwrite;
      };
      this.toggleOverwrite = function() {
        this.setOverwrite(!this.$overwrite);
      };
      this.addGutterDecoration = function(row, className) {
        if (!this.$decorations[row])
          this.$decorations[row] = "";
        this.$decorations[row] += " " + className;
        this._signal("changeBreakpoint", {});
      };
      this.removeGutterDecoration = function(row, className) {
        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
        this._signal("changeBreakpoint", {});
      };
      this.getBreakpoints = function() {
        return this.$breakpoints;
      };
      this.setBreakpoints = function(rows) {
        this.$breakpoints = [];
        for (var i = 0; i < rows.length; i++) {
          this.$breakpoints[rows[i]] = "ace_breakpoint";
        }
        this._signal("changeBreakpoint", {});
      };
      this.clearBreakpoints = function() {
        this.$breakpoints = [];
        this._signal("changeBreakpoint", {});
      };
      this.setBreakpoint = function(row, className) {
        if (className === void 0)
          className = "ace_breakpoint";
        if (className)
          this.$breakpoints[row] = className;
        else
          delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
      };
      this.clearBreakpoint = function(row) {
        delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
      };
      this.addMarker = function(range, clazz, type2, inFront) {
        var id2 = this.$markerId++;
        var marker = {
          range,
          type: type2 || "line",
          renderer: typeof type2 == "function" ? type2 : null,
          clazz,
          inFront: !!inFront,
          id: id2
        };
        if (inFront) {
          this.$frontMarkers[id2] = marker;
          this._signal("changeFrontMarker");
        } else {
          this.$backMarkers[id2] = marker;
          this._signal("changeBackMarker");
        }
        return id2;
      };
      this.addDynamicMarker = function(marker, inFront) {
        if (!marker.update)
          return;
        var id2 = this.$markerId++;
        marker.id = id2;
        marker.inFront = !!inFront;
        if (inFront) {
          this.$frontMarkers[id2] = marker;
          this._signal("changeFrontMarker");
        } else {
          this.$backMarkers[id2] = marker;
          this._signal("changeBackMarker");
        }
        return marker;
      };
      this.removeMarker = function(markerId) {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
          return;
        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        delete markers[markerId];
        this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
      };
      this.getMarkers = function(inFront) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
      };
      this.highlight = function(re2) {
        if (!this.$searchHighlight) {
          var highlight = new SearchHighlight(null, "ace_selected-word", "text");
          this.$searchHighlight = this.addDynamicMarker(highlight);
        }
        this.$searchHighlight.setRegexp(re2);
      };
      this.highlightLines = function(startRow, endRow, clazz, inFront) {
        if (typeof endRow != "number") {
          clazz = endRow;
          endRow = startRow;
        }
        if (!clazz)
          clazz = "ace_step";
        var range = new Range(startRow, 0, endRow, Infinity);
        range.id = this.addMarker(range, clazz, "fullLine", inFront);
        return range;
      };
      this.setAnnotations = function(annotations) {
        this.$annotations = annotations;
        this._signal("changeAnnotation", {});
      };
      this.getAnnotations = function() {
        return this.$annotations || [];
      };
      this.clearAnnotations = function() {
        this.setAnnotations([]);
      };
      this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
          this.$autoNewLine = match[1];
        } else {
          this.$autoNewLine = "\n";
        }
      };
      this.getWordRange = function(row, column) {
        var line = this.getLine(row);
        var inToken = false;
        if (column > 0)
          inToken = !!line.charAt(column - 1).match(this.tokenRe);
        if (!inToken)
          inToken = !!line.charAt(column).match(this.tokenRe);
        if (inToken)
          var re2 = this.tokenRe;
        else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
          var re2 = /\s/;
        else
          var re2 = this.nonTokenRe;
        var start = column;
        if (start > 0) {
          do {
            start--;
          } while (start >= 0 && line.charAt(start).match(re2));
          start++;
        }
        var end = column;
        while (end < line.length && line.charAt(end).match(re2)) {
          end++;
        }
        return new Range(row, start, row, end);
      };
      this.getAWordRange = function(row, column) {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);
        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
          wordRange.end.column += 1;
        }
        return wordRange;
      };
      this.setNewLineMode = function(newLineMode) {
        this.doc.setNewLineMode(newLineMode);
      };
      this.getNewLineMode = function() {
        return this.doc.getNewLineMode();
      };
      this.setUseWorker = function(useWorker) {
        this.setOption("useWorker", useWorker);
      };
      this.getUseWorker = function() {
        return this.$useWorker;
      };
      this.onReloadTokenizer = function(e2) {
        var rows = e2.data;
        this.bgTokenizer.start(rows.first);
        this._signal("tokenizerUpdate", e2);
      };
      this.$modes = config.$modes;
      this.$mode = null;
      this.$modeId = null;
      this.setMode = function(mode, cb2) {
        if (mode && typeof mode === "object") {
          if (mode.getTokenizer)
            return this.$onChangeMode(mode);
          var options = mode;
          var path = options.path;
        } else {
          path = mode || "ace/mode/text";
        }
        if (!this.$modes["ace/mode/text"])
          this.$modes["ace/mode/text"] = new TextMode();
        if (this.$modes[path] && !options) {
          this.$onChangeMode(this.$modes[path]);
          cb2 && cb2();
          return;
        }
        this.$modeId = path;
        config.loadModule(["mode", path], function(m2) {
          if (this.$modeId !== path)
            return cb2 && cb2();
          if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
          } else if (m2 && m2.Mode) {
            m2 = new m2.Mode(options);
            if (!options) {
              this.$modes[path] = m2;
              m2.$id = path;
            }
            this.$onChangeMode(m2);
          }
          cb2 && cb2();
        }.bind(this));
        if (!this.$mode)
          this.$onChangeMode(this.$modes["ace/mode/text"], true);
      };
      this.$onChangeMode = function(mode, $isPlaceholder) {
        if (!$isPlaceholder)
          this.$modeId = mode.$id;
        if (this.$mode === mode)
          return;
        var oldMode = this.$mode;
        this.$mode = mode;
        this.$stopWorker();
        if (this.$useWorker)
          this.$startWorker();
        var tokenizer = mode.getTokenizer();
        if (tokenizer.on !== void 0) {
          var onReloadTokenizer = this.onReloadTokenizer.bind(this);
          tokenizer.on("update", onReloadTokenizer);
        }
        if (!this.bgTokenizer) {
          this.bgTokenizer = new BackgroundTokenizer(tokenizer);
          var _self = this;
          this.bgTokenizer.on("update", function(e2) {
            _self._signal("tokenizerUpdate", e2);
          });
        } else {
          this.bgTokenizer.setTokenizer(tokenizer);
        }
        this.bgTokenizer.setDocument(this.getDocument());
        this.tokenRe = mode.tokenRe;
        this.nonTokenRe = mode.nonTokenRe;
        if (!$isPlaceholder) {
          if (mode.attachToSession)
            mode.attachToSession(this);
          this.$options.wrapMethod.set.call(this, this.$wrapMethod);
          this.$setFolding(mode.foldingRules);
          this.bgTokenizer.start(0);
          this._emit("changeMode", {oldMode, mode});
        }
      };
      this.$stopWorker = function() {
        if (this.$worker) {
          this.$worker.terminate();
          this.$worker = null;
        }
      };
      this.$startWorker = function() {
        try {
          this.$worker = this.$mode.createWorker(this);
        } catch (e2) {
          config.warn("Could not load worker", e2);
          this.$worker = null;
        }
      };
      this.getMode = function() {
        return this.$mode;
      };
      this.$scrollTop = 0;
      this.setScrollTop = function(scrollTop) {
        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
          return;
        this.$scrollTop = scrollTop;
        this._signal("changeScrollTop", scrollTop);
      };
      this.getScrollTop = function() {
        return this.$scrollTop;
      };
      this.$scrollLeft = 0;
      this.setScrollLeft = function(scrollLeft) {
        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
          return;
        this.$scrollLeft = scrollLeft;
        this._signal("changeScrollLeft", scrollLeft);
      };
      this.getScrollLeft = function() {
        return this.$scrollLeft;
      };
      this.getScreenWidth = function() {
        this.$computeWidth();
        if (this.lineWidgets)
          return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
        return this.screenWidth;
      };
      this.getLineWidgetMaxWidth = function() {
        if (this.lineWidgetsWidth != null)
          return this.lineWidgetsWidth;
        var width = 0;
        this.lineWidgets.forEach(function(w2) {
          if (w2 && w2.screenWidth > width)
            width = w2.screenWidth;
        });
        return this.lineWidgetWidth = width;
      };
      this.$computeWidth = function(force) {
        if (this.$modified || force) {
          this.$modified = false;
          if (this.$useWrapMode)
            return this.screenWidth = this.$wrapLimit;
          var lines = this.doc.getAllLines();
          var cache = this.$rowLengthCache;
          var longestScreenLine = 0;
          var foldIndex = 0;
          var foldLine2 = this.$foldData[foldIndex];
          var foldStart = foldLine2 ? foldLine2.start.row : Infinity;
          var len = lines.length;
          for (var i = 0; i < len; i++) {
            if (i > foldStart) {
              i = foldLine2.end.row + 1;
              if (i >= len)
                break;
              foldLine2 = this.$foldData[foldIndex++];
              foldStart = foldLine2 ? foldLine2.start.row : Infinity;
            }
            if (cache[i] == null)
              cache[i] = this.$getStringScreenWidth(lines[i])[0];
            if (cache[i] > longestScreenLine)
              longestScreenLine = cache[i];
          }
          this.screenWidth = longestScreenLine;
        }
      };
      this.getLine = function(row) {
        return this.doc.getLine(row);
      };
      this.getLines = function(firstRow, lastRow) {
        return this.doc.getLines(firstRow, lastRow);
      };
      this.getLength = function() {
        return this.doc.getLength();
      };
      this.getTextRange = function(range) {
        return this.doc.getTextRange(range || this.selection.getRange());
      };
      this.insert = function(position, text) {
        return this.doc.insert(position, text);
      };
      this.remove = function(range) {
        return this.doc.remove(range);
      };
      this.removeFullLines = function(firstRow, lastRow) {
        return this.doc.removeFullLines(firstRow, lastRow);
      };
      this.undoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
          return;
        this.$fromUndo = true;
        for (var i = deltas.length - 1; i != -1; i--) {
          var delta = deltas[i];
          if (delta.action == "insert" || delta.action == "remove") {
            this.doc.revertDelta(delta);
          } else if (delta.folds) {
            this.addFolds(delta.folds);
          }
        }
        if (!dontSelect && this.$undoSelect) {
          if (deltas.selectionBefore)
            this.selection.fromJSON(deltas.selectionBefore);
          else
            this.selection.setRange(this.$getUndoSelection(deltas, true));
        }
        this.$fromUndo = false;
      };
      this.redoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
          return;
        this.$fromUndo = true;
        for (var i = 0; i < deltas.length; i++) {
          var delta = deltas[i];
          if (delta.action == "insert" || delta.action == "remove") {
            this.doc.$safeApplyDelta(delta);
          }
        }
        if (!dontSelect && this.$undoSelect) {
          if (deltas.selectionAfter)
            this.selection.fromJSON(deltas.selectionAfter);
          else
            this.selection.setRange(this.$getUndoSelection(deltas, false));
        }
        this.$fromUndo = false;
      };
      this.setUndoSelect = function(enable) {
        this.$undoSelect = enable;
      };
      this.$getUndoSelection = function(deltas, isUndo) {
        function isInsert(delta2) {
          return isUndo ? delta2.action !== "insert" : delta2.action === "insert";
        }
        var range, point;
        for (var i = 0; i < deltas.length; i++) {
          var delta = deltas[i];
          if (!delta.start)
            continue;
          if (!range) {
            if (isInsert(delta)) {
              range = Range.fromPoints(delta.start, delta.end);
            } else {
              range = Range.fromPoints(delta.start, delta.start);
            }
            continue;
          }
          if (isInsert(delta)) {
            point = delta.start;
            if (range.compare(point.row, point.column) == -1) {
              range.setStart(point);
            }
            point = delta.end;
            if (range.compare(point.row, point.column) == 1) {
              range.setEnd(point);
            }
          } else {
            point = delta.start;
            if (range.compare(point.row, point.column) == -1) {
              range = Range.fromPoints(delta.start, delta.start);
            }
          }
        }
        return range;
      };
      this.replace = function(range, text) {
        return this.doc.replace(range, text);
      };
      this.moveText = function(fromRange, toPosition, copy) {
        var text = this.getTextRange(fromRange);
        var folds = this.getFoldsInRange(fromRange);
        var toRange = Range.fromPoints(toPosition, toPosition);
        if (!copy) {
          this.remove(fromRange);
          var rowDiff = fromRange.start.row - fromRange.end.row;
          var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
          if (collDiff) {
            if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
              toRange.start.column += collDiff;
            if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
              toRange.end.column += collDiff;
          }
          if (rowDiff && toRange.start.row >= fromRange.end.row) {
            toRange.start.row += rowDiff;
            toRange.end.row += rowDiff;
          }
        }
        toRange.end = this.insert(toRange.start, text);
        if (folds.length) {
          var oldStart = fromRange.start;
          var newStart = toRange.start;
          var rowDiff = newStart.row - oldStart.row;
          var collDiff = newStart.column - oldStart.column;
          this.addFolds(folds.map(function(x2) {
            x2 = x2.clone();
            if (x2.start.row == oldStart.row)
              x2.start.column += collDiff;
            if (x2.end.row == oldStart.row)
              x2.end.column += collDiff;
            x2.start.row += rowDiff;
            x2.end.row += rowDiff;
            return x2;
          }));
        }
        return toRange;
      };
      this.indentRows = function(startRow, endRow, indentString2) {
        indentString2 = indentString2.replace(/\t/g, this.getTabString());
        for (var row = startRow; row <= endRow; row++)
          this.doc.insertInLine({row, column: 0}, indentString2);
      };
      this.outdentRows = function(range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range(0, 0, 0, 0);
        var size = this.getTabSize();
        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
          var line = this.getLine(i);
          deleteRange.start.row = i;
          deleteRange.end.row = i;
          for (var j = 0; j < size; ++j)
            if (line.charAt(j) != " ")
              break;
          if (j < size && line.charAt(j) == "	") {
            deleteRange.start.column = j;
            deleteRange.end.column = j + 1;
          } else {
            deleteRange.start.column = 0;
            deleteRange.end.column = j;
          }
          this.remove(deleteRange);
        }
      };
      this.$moveLines = function(firstRow, lastRow, dir) {
        firstRow = this.getRowFoldStart(firstRow);
        lastRow = this.getRowFoldEnd(lastRow);
        if (dir < 0) {
          var row = this.getRowFoldStart(firstRow + dir);
          if (row < 0)
            return 0;
          var diff2 = row - firstRow;
        } else if (dir > 0) {
          var row = this.getRowFoldEnd(lastRow + dir);
          if (row > this.doc.getLength() - 1)
            return 0;
          var diff2 = row - lastRow;
        } else {
          firstRow = this.$clipRowToDocument(firstRow);
          lastRow = this.$clipRowToDocument(lastRow);
          var diff2 = lastRow - firstRow + 1;
        }
        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
        var folds = this.getFoldsInRange(range).map(function(x2) {
          x2 = x2.clone();
          x2.start.row += diff2;
          x2.end.row += diff2;
          return x2;
        });
        var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
        this.doc.insertFullLines(firstRow + diff2, lines);
        folds.length && this.addFolds(folds);
        return diff2;
      };
      this.moveLinesUp = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, -1);
      };
      this.moveLinesDown = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 1);
      };
      this.duplicateLines = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 0);
      };
      this.$clipRowToDocument = function(row) {
        return Math.max(0, Math.min(row, this.doc.getLength() - 1));
      };
      this.$clipColumnToRow = function(row, column) {
        if (column < 0)
          return 0;
        return Math.min(this.doc.getLine(row).length, column);
      };
      this.$clipPositionToDocument = function(row, column) {
        column = Math.max(0, column);
        if (row < 0) {
          row = 0;
          column = 0;
        } else {
          var len = this.doc.getLength();
          if (row >= len) {
            row = len - 1;
            column = this.doc.getLine(len - 1).length;
          } else {
            column = Math.min(this.doc.getLine(row).length, column);
          }
        }
        return {
          row,
          column
        };
      };
      this.$clipRangeToDocument = function(range) {
        if (range.start.row < 0) {
          range.start.row = 0;
          range.start.column = 0;
        } else {
          range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
        }
        var len = this.doc.getLength() - 1;
        if (range.end.row > len) {
          range.end.row = len;
          range.end.column = this.doc.getLine(len).length;
        } else {
          range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
        }
        return range;
      };
      this.$wrapLimit = 80;
      this.$useWrapMode = false;
      this.$wrapLimitRange = {
        min: null,
        max: null
      };
      this.setUseWrapMode = function(useWrapMode) {
        if (useWrapMode != this.$useWrapMode) {
          this.$useWrapMode = useWrapMode;
          this.$modified = true;
          this.$resetRowCache(0);
          if (useWrapMode) {
            var len = this.getLength();
            this.$wrapData = Array(len);
            this.$updateWrapData(0, len - 1);
          }
          this._signal("changeWrapMode");
        }
      };
      this.getUseWrapMode = function() {
        return this.$useWrapMode;
      };
      this.setWrapLimitRange = function(min, max) {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
          this.$wrapLimitRange = {min, max};
          this.$modified = true;
          this.$bidiHandler.markAsDirty();
          if (this.$useWrapMode)
            this._signal("changeWrapMode");
        }
      };
      this.adjustWrapLimit = function(desiredLimit, $printMargin) {
        var limits = this.$wrapLimitRange;
        if (limits.max < 0)
          limits = {min: $printMargin, max: $printMargin};
        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
          this.$wrapLimit = wrapLimit;
          this.$modified = true;
          if (this.$useWrapMode) {
            this.$updateWrapData(0, this.getLength() - 1);
            this.$resetRowCache(0);
            this._signal("changeWrapLimit");
          }
          return true;
        }
        return false;
      };
      this.$constrainWrapLimit = function(wrapLimit, min, max) {
        if (min)
          wrapLimit = Math.max(min, wrapLimit);
        if (max)
          wrapLimit = Math.min(max, wrapLimit);
        return wrapLimit;
      };
      this.getWrapLimit = function() {
        return this.$wrapLimit;
      };
      this.setWrapLimit = function(limit) {
        this.setWrapLimitRange(limit, limit);
      };
      this.getWrapLimitRange = function() {
        return {
          min: this.$wrapLimitRange.min,
          max: this.$wrapLimitRange.max
        };
      };
      this.$updateInternalDataOnChange = function(delta) {
        var useWrapMode = this.$useWrapMode;
        var action = delta.action;
        var start = delta.start;
        var end = delta.end;
        var firstRow = start.row;
        var lastRow = end.row;
        var len = lastRow - firstRow;
        var removedFolds = null;
        this.$updating = true;
        if (len != 0) {
          if (action === "remove") {
            this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
            var foldLines = this.$foldData;
            removedFolds = this.getFoldsInRange(delta);
            this.removeFolds(removedFolds);
            var foldLine2 = this.getFoldLine(end.row);
            var idx = 0;
            if (foldLine2) {
              foldLine2.addRemoveChars(end.row, end.column, start.column - end.column);
              foldLine2.shiftRow(-len);
              var foldLineBefore = this.getFoldLine(firstRow);
              if (foldLineBefore && foldLineBefore !== foldLine2) {
                foldLineBefore.merge(foldLine2);
                foldLine2 = foldLineBefore;
              }
              idx = foldLines.indexOf(foldLine2) + 1;
            }
            for (idx; idx < foldLines.length; idx++) {
              var foldLine2 = foldLines[idx];
              if (foldLine2.start.row >= end.row) {
                foldLine2.shiftRow(-len);
              }
            }
            lastRow = firstRow;
          } else {
            var args = Array(len);
            args.unshift(firstRow, 0);
            var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
            arr.splice.apply(arr, args);
            var foldLines = this.$foldData;
            var foldLine2 = this.getFoldLine(firstRow);
            var idx = 0;
            if (foldLine2) {
              var cmp = foldLine2.range.compareInside(start.row, start.column);
              if (cmp == 0) {
                foldLine2 = foldLine2.split(start.row, start.column);
                if (foldLine2) {
                  foldLine2.shiftRow(len);
                  foldLine2.addRemoveChars(lastRow, 0, end.column - start.column);
                }
              } else if (cmp == -1) {
                foldLine2.addRemoveChars(firstRow, 0, end.column - start.column);
                foldLine2.shiftRow(len);
              }
              idx = foldLines.indexOf(foldLine2) + 1;
            }
            for (idx; idx < foldLines.length; idx++) {
              var foldLine2 = foldLines[idx];
              if (foldLine2.start.row >= firstRow) {
                foldLine2.shiftRow(len);
              }
            }
          }
        } else {
          len = Math.abs(delta.start.column - delta.end.column);
          if (action === "remove") {
            removedFolds = this.getFoldsInRange(delta);
            this.removeFolds(removedFolds);
            len = -len;
          }
          var foldLine2 = this.getFoldLine(firstRow);
          if (foldLine2) {
            foldLine2.addRemoveChars(firstRow, start.column, len);
          }
        }
        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
          console.error("doc.getLength() and $wrapData.length have to be the same!");
        }
        this.$updating = false;
        if (useWrapMode)
          this.$updateWrapData(firstRow, lastRow);
        else
          this.$updateRowLengthCache(firstRow, lastRow);
        return removedFolds;
      };
      this.$updateRowLengthCache = function(firstRow, lastRow, b2) {
        this.$rowLengthCache[firstRow] = null;
        this.$rowLengthCache[lastRow] = null;
      };
      this.$updateWrapData = function(firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine2;
        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row <= lastRow) {
          foldLine2 = this.getFoldLine(row, foldLine2);
          if (!foldLine2) {
            tokens = this.$getDisplayTokens(lines[row]);
            wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
            row++;
          } else {
            tokens = [];
            foldLine2.walk(function(placeholder, row2, column, lastColumn) {
              var walkTokens;
              if (placeholder != null) {
                walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                walkTokens[0] = PLACEHOLDER_START;
                for (var i = 1; i < walkTokens.length; i++) {
                  walkTokens[i] = PLACEHOLDER_BODY;
                }
              } else {
                walkTokens = this.$getDisplayTokens(lines[row2].substring(lastColumn, column), tokens.length);
              }
              tokens = tokens.concat(walkTokens);
            }.bind(this), foldLine2.end.row, lines[foldLine2.end.row].length + 1);
            wrapData[foldLine2.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
            row = foldLine2.end.row + 1;
          }
        }
      };
      var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
      this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
        if (tokens.length == 0) {
          return [];
        }
        var splits = [];
        var displayLength = tokens.length;
        var lastSplit = 0, lastDocSplit = 0;
        var isCode = this.$wrapAsCode;
        var indentedSoftWrap = this.$indentedSoftWrap;
        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
        function getWrapIndent() {
          var indentation = 0;
          if (maxIndent === 0)
            return indentation;
          if (indentedSoftWrap) {
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              if (token == SPACE)
                indentation += 1;
              else if (token == TAB)
                indentation += tabSize;
              else if (token == TAB_SPACE)
                continue;
              else
                break;
            }
          }
          if (isCode && indentedSoftWrap !== false)
            indentation += tabSize;
          return Math.min(indentation, maxIndent);
        }
        function addSplit(screenPos) {
          var len = screenPos - lastSplit;
          for (var i = lastSplit; i < screenPos; i++) {
            var ch2 = tokens[i];
            if (ch2 === 12 || ch2 === 2)
              len -= 1;
          }
          if (!splits.length) {
            indent = getWrapIndent();
            splits.indent = indent;
          }
          lastDocSplit += len;
          splits.push(lastDocSplit);
          lastSplit = screenPos;
        }
        var indent = 0;
        while (displayLength - lastSplit > wrapLimit - indent) {
          var split2 = lastSplit + wrapLimit - indent;
          if (tokens[split2 - 1] >= SPACE && tokens[split2] >= SPACE) {
            addSplit(split2);
            continue;
          }
          if (tokens[split2] == PLACEHOLDER_START || tokens[split2] == PLACEHOLDER_BODY) {
            for (split2; split2 != lastSplit - 1; split2--) {
              if (tokens[split2] == PLACEHOLDER_START) {
                break;
              }
            }
            if (split2 > lastSplit) {
              addSplit(split2);
              continue;
            }
            split2 = lastSplit + wrapLimit;
            for (split2; split2 < tokens.length; split2++) {
              if (tokens[split2] != PLACEHOLDER_BODY) {
                break;
              }
            }
            if (split2 == tokens.length) {
              break;
            }
            addSplit(split2);
            continue;
          }
          var minSplit = Math.max(split2 - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
          while (split2 > minSplit && tokens[split2] < PLACEHOLDER_START) {
            split2--;
          }
          if (isCode) {
            while (split2 > minSplit && tokens[split2] < PLACEHOLDER_START) {
              split2--;
            }
            while (split2 > minSplit && tokens[split2] == PUNCTUATION) {
              split2--;
            }
          } else {
            while (split2 > minSplit && tokens[split2] < SPACE) {
              split2--;
            }
          }
          if (split2 > minSplit) {
            addSplit(++split2);
            continue;
          }
          split2 = lastSplit + wrapLimit;
          if (tokens[split2] == CHAR_EXT)
            split2--;
          addSplit(split2 - indent);
        }
        return splits;
      };
      this.$getDisplayTokens = function(str2, offset) {
        var arr = [];
        var tabSize;
        offset = offset || 0;
        for (var i = 0; i < str2.length; i++) {
          var c2 = str2.charCodeAt(i);
          if (c2 == 9) {
            tabSize = this.getScreenTabSize(arr.length + offset);
            arr.push(TAB);
            for (var n2 = 1; n2 < tabSize; n2++) {
              arr.push(TAB_SPACE);
            }
          } else if (c2 == 32) {
            arr.push(SPACE);
          } else if (c2 > 39 && c2 < 48 || c2 > 57 && c2 < 64) {
            arr.push(PUNCTUATION);
          } else if (c2 >= 4352 && isFullWidth(c2)) {
            arr.push(CHAR, CHAR_EXT);
          } else {
            arr.push(CHAR);
          }
        }
        return arr;
      };
      this.$getStringScreenWidth = function(str2, maxScreenColumn, screenColumn) {
        if (maxScreenColumn == 0)
          return [0, 0];
        if (maxScreenColumn == null)
          maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;
        var c2, column;
        for (column = 0; column < str2.length; column++) {
          c2 = str2.charCodeAt(column);
          if (c2 == 9) {
            screenColumn += this.getScreenTabSize(screenColumn);
          } else if (c2 >= 4352 && isFullWidth(c2)) {
            screenColumn += 2;
          } else {
            screenColumn += 1;
          }
          if (screenColumn > maxScreenColumn) {
            break;
          }
        }
        return [screenColumn, column];
      };
      this.lineWidgets = null;
      this.getRowLength = function(row) {
        var h2 = 1;
        if (this.lineWidgets)
          h2 += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        if (!this.$useWrapMode || !this.$wrapData[row])
          return h2;
        else
          return this.$wrapData[row].length + h2;
      };
      this.getRowLineCount = function(row) {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
          return 1;
        } else {
          return this.$wrapData[row].length + 1;
        }
      };
      this.getRowWrapIndent = function(screenRow) {
        if (this.$useWrapMode) {
          var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
          var splits = this.$wrapData[pos.row];
          return splits.length && splits[0] < pos.column ? splits.indent : 0;
        } else {
          return 0;
        }
      };
      this.getScreenLastRowColumn = function(screenRow) {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        return this.documentToScreenColumn(pos.row, pos.column);
      };
      this.getDocumentLastRowColumn = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
      };
      this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
      };
      this.getRowSplitData = function(row) {
        if (!this.$useWrapMode) {
          return void 0;
        } else {
          return this.$wrapData[row];
        }
      };
      this.getScreenTabSize = function(screenColumn) {
        return this.$tabSize - (screenColumn % this.$tabSize | 0);
      };
      this.screenToDocumentRow = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
      };
      this.screenToDocumentColumn = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
      };
      this.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
        if (screenRow < 0)
          return {row: 0, column: 0};
        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;
        var rowCache = this.$screenRowCache;
        var i = this.$getRowCacheIndex(rowCache, screenRow);
        var l2 = rowCache.length;
        if (l2 && i >= 0) {
          var row = rowCache[i];
          var docRow = this.$docRowCache[i];
          var doCache = screenRow > rowCache[l2 - 1];
        } else {
          var doCache = !l2;
        }
        var maxRow = this.getLength() - 1;
        var foldLine2 = this.getNextFoldLine(docRow);
        var foldStart = foldLine2 ? foldLine2.start.row : Infinity;
        while (row <= screenRow) {
          rowLength = this.getRowLength(docRow);
          if (row + rowLength > screenRow || docRow >= maxRow) {
            break;
          } else {
            row += rowLength;
            docRow++;
            if (docRow > foldStart) {
              docRow = foldLine2.end.row + 1;
              foldLine2 = this.getNextFoldLine(docRow, foldLine2);
              foldStart = foldLine2 ? foldLine2.start.row : Infinity;
            }
          }
          if (doCache) {
            this.$docRowCache.push(docRow);
            this.$screenRowCache.push(row);
          }
        }
        if (foldLine2 && foldLine2.start.row <= docRow) {
          line = this.getFoldDisplayLine(foldLine2);
          docRow = foldLine2.start.row;
        } else if (row + rowLength <= screenRow || docRow > maxRow) {
          return {
            row: maxRow,
            column: this.getLine(maxRow).length
          };
        } else {
          line = this.getLine(docRow);
          foldLine2 = null;
        }
        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
        if (this.$useWrapMode) {
          var splits = this.$wrapData[docRow];
          if (splits) {
            column = splits[splitIndex];
            if (splitIndex > 0 && splits.length) {
              wrapIndent = splits.indent;
              docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
              line = line.substring(docColumn);
            }
          }
        }
        if (offsetX !== void 0 && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
          screenColumn = this.$bidiHandler.offsetToCol(offsetX);
        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
        if (this.$useWrapMode && docColumn >= column)
          docColumn = column - 1;
        if (foldLine2)
          return foldLine2.idxToPosition(docColumn);
        return {row: docRow, column: docColumn};
      };
      this.documentToScreenPosition = function(docRow, docColumn) {
        if (typeof docColumn === "undefined")
          var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
        else
          pos = this.$clipPositionToDocument(docRow, docColumn);
        docRow = pos.row;
        docColumn = pos.column;
        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
          docRow = fold.start.row;
          docColumn = fold.start.column;
        }
        var rowEnd, row = 0;
        var rowCache = this.$docRowCache;
        var i = this.$getRowCacheIndex(rowCache, docRow);
        var l2 = rowCache.length;
        if (l2 && i >= 0) {
          var row = rowCache[i];
          var screenRow = this.$screenRowCache[i];
          var doCache = docRow > rowCache[l2 - 1];
        } else {
          var doCache = !l2;
        }
        var foldLine2 = this.getNextFoldLine(row);
        var foldStart = foldLine2 ? foldLine2.start.row : Infinity;
        while (row < docRow) {
          if (row >= foldStart) {
            rowEnd = foldLine2.end.row + 1;
            if (rowEnd > docRow)
              break;
            foldLine2 = this.getNextFoldLine(rowEnd, foldLine2);
            foldStart = foldLine2 ? foldLine2.start.row : Infinity;
          } else {
            rowEnd = row + 1;
          }
          screenRow += this.getRowLength(row);
          row = rowEnd;
          if (doCache) {
            this.$docRowCache.push(row);
            this.$screenRowCache.push(screenRow);
          }
        }
        var textLine = "";
        if (foldLine2 && row >= foldStart) {
          textLine = this.getFoldDisplayLine(foldLine2, docRow, docColumn);
          foldStartRow = foldLine2.start.row;
        } else {
          textLine = this.getLine(docRow).substring(0, docColumn);
          foldStartRow = docRow;
        }
        var wrapIndent = 0;
        if (this.$useWrapMode) {
          var wrapRow = this.$wrapData[foldStartRow];
          if (wrapRow) {
            var screenRowOffset = 0;
            while (textLine.length >= wrapRow[screenRowOffset]) {
              screenRow++;
              screenRowOffset++;
            }
            textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
            wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
          }
        }
        if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
          screenRow += this.lineWidgets[row].rowsAbove;
        return {
          row: screenRow,
          column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
        };
      };
      this.documentToScreenColumn = function(row, docColumn) {
        return this.documentToScreenPosition(row, docColumn).column;
      };
      this.documentToScreenRow = function(docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).row;
      };
      this.getScreenLength = function() {
        var screenRows = 0;
        var fold = null;
        if (!this.$useWrapMode) {
          screenRows = this.getLength();
          var foldData = this.$foldData;
          for (var i = 0; i < foldData.length; i++) {
            fold = foldData[i];
            screenRows -= fold.end.row - fold.start.row;
          }
        } else {
          var lastRow = this.$wrapData.length;
          var row = 0, i = 0;
          var fold = this.$foldData[i++];
          var foldStart = fold ? fold.start.row : Infinity;
          while (row < lastRow) {
            var splits = this.$wrapData[row];
            screenRows += splits ? splits.length + 1 : 1;
            row++;
            if (row > foldStart) {
              row = fold.end.row + 1;
              fold = this.$foldData[i++];
              foldStart = fold ? fold.start.row : Infinity;
            }
          }
        }
        if (this.lineWidgets)
          screenRows += this.$getWidgetScreenLength();
        return screenRows;
      };
      this.$setFontMetrics = function(fm) {
        if (!this.$enableVarChar)
          return;
        this.$getStringScreenWidth = function(str2, maxScreenColumn, screenColumn) {
          if (maxScreenColumn === 0)
            return [0, 0];
          if (!maxScreenColumn)
            maxScreenColumn = Infinity;
          screenColumn = screenColumn || 0;
          var c2, column;
          for (column = 0; column < str2.length; column++) {
            c2 = str2.charAt(column);
            if (c2 === "	") {
              screenColumn += this.getScreenTabSize(screenColumn);
            } else {
              screenColumn += fm.getCharacterWidth(c2);
            }
            if (screenColumn > maxScreenColumn) {
              break;
            }
          }
          return [screenColumn, column];
        };
      };
      this.destroy = function() {
        if (this.bgTokenizer) {
          this.bgTokenizer.setDocument(null);
          this.bgTokenizer = null;
        }
        this.$stopWorker();
        this.removeAllListeners();
        this.selection.detach();
      };
      this.isFullWidth = isFullWidth;
      function isFullWidth(c2) {
        if (c2 < 4352)
          return false;
        return c2 >= 4352 && c2 <= 4447 || c2 >= 4515 && c2 <= 4519 || c2 >= 4602 && c2 <= 4607 || c2 >= 9001 && c2 <= 9002 || c2 >= 11904 && c2 <= 11929 || c2 >= 11931 && c2 <= 12019 || c2 >= 12032 && c2 <= 12245 || c2 >= 12272 && c2 <= 12283 || c2 >= 12288 && c2 <= 12350 || c2 >= 12353 && c2 <= 12438 || c2 >= 12441 && c2 <= 12543 || c2 >= 12549 && c2 <= 12589 || c2 >= 12593 && c2 <= 12686 || c2 >= 12688 && c2 <= 12730 || c2 >= 12736 && c2 <= 12771 || c2 >= 12784 && c2 <= 12830 || c2 >= 12832 && c2 <= 12871 || c2 >= 12880 && c2 <= 13054 || c2 >= 13056 && c2 <= 19903 || c2 >= 19968 && c2 <= 42124 || c2 >= 42128 && c2 <= 42182 || c2 >= 43360 && c2 <= 43388 || c2 >= 44032 && c2 <= 55203 || c2 >= 55216 && c2 <= 55238 || c2 >= 55243 && c2 <= 55291 || c2 >= 63744 && c2 <= 64255 || c2 >= 65040 && c2 <= 65049 || c2 >= 65072 && c2 <= 65106 || c2 >= 65108 && c2 <= 65126 || c2 >= 65128 && c2 <= 65131 || c2 >= 65281 && c2 <= 65376 || c2 >= 65504 && c2 <= 65510;
      }
    }).call(EditSession.prototype);
    require2("./edit_session/folding").Folding.call(EditSession.prototype);
    require2("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
    config.defineOptions(EditSession.prototype, "session", {
      wrap: {
        set: function(value) {
          if (!value || value == "off")
            value = false;
          else if (value == "free")
            value = true;
          else if (value == "printMargin")
            value = -1;
          else if (typeof value == "string")
            value = parseInt(value, 10) || false;
          if (this.$wrap == value)
            return;
          this.$wrap = value;
          if (!value) {
            this.setUseWrapMode(false);
          } else {
            var col = typeof value == "number" ? value : null;
            this.setWrapLimitRange(col, col);
            this.setUseWrapMode(true);
          }
        },
        get: function() {
          if (this.getUseWrapMode()) {
            if (this.$wrap == -1)
              return "printMargin";
            if (!this.getWrapLimitRange().min)
              return "free";
            return this.$wrap;
          }
          return "off";
        },
        handlesSet: true
      },
      wrapMethod: {
        set: function(val) {
          val = val == "auto" ? this.$mode.type != "text" : val != "text";
          if (val != this.$wrapAsCode) {
            this.$wrapAsCode = val;
            if (this.$useWrapMode) {
              this.$useWrapMode = false;
              this.setUseWrapMode(true);
            }
          }
        },
        initialValue: "auto"
      },
      indentedSoftWrap: {
        set: function() {
          if (this.$useWrapMode) {
            this.$useWrapMode = false;
            this.setUseWrapMode(true);
          }
        },
        initialValue: true
      },
      firstLineNumber: {
        set: function() {
          this._signal("changeBreakpoint");
        },
        initialValue: 1
      },
      useWorker: {
        set: function(useWorker) {
          this.$useWorker = useWorker;
          this.$stopWorker();
          if (useWorker)
            this.$startWorker();
        },
        initialValue: true
      },
      useSoftTabs: {initialValue: true},
      tabSize: {
        set: function(tabSize) {
          tabSize = parseInt(tabSize);
          if (tabSize > 0 && this.$tabSize !== tabSize) {
            this.$modified = true;
            this.$rowLengthCache = [];
            this.$tabSize = tabSize;
            this._signal("changeTabSize");
          }
        },
        initialValue: 4,
        handlesSet: true
      },
      navigateWithinSoftTabs: {initialValue: false},
      foldStyle: {
        set: function(val) {
          this.setFoldStyle(val);
        },
        handlesSet: true
      },
      overwrite: {
        set: function(val) {
          this._signal("changeOverwrite");
        },
        initialValue: false
      },
      newLineMode: {
        set: function(val) {
          this.doc.setNewLineMode(val);
        },
        get: function() {
          return this.doc.getNewLineMode();
        },
        handlesSet: true
      },
      mode: {
        set: function(val) {
          this.setMode(val);
        },
        get: function() {
          return this.$modeId;
        },
        handlesSet: true
      }
    });
    exports2.EditSession = EditSession;
  });
  ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(require2, exports2, module2) {
    var lang = require2("./lib/lang");
    var oop = require2("./lib/oop");
    var Range = require2("./range").Range;
    var Search = function() {
      this.$options = {};
    };
    (function() {
      this.set = function(options) {
        oop.mixin(this.$options, options);
        return this;
      };
      this.getOptions = function() {
        return lang.copyObject(this.$options);
      };
      this.setOptions = function(options) {
        this.$options = options;
      };
      this.find = function(session) {
        var options = this.$options;
        var iterator = this.$matchIterator(session, options);
        if (!iterator)
          return false;
        var firstRange = null;
        iterator.forEach(function(sr, sc2, er, ec2) {
          firstRange = new Range(sr, sc2, er, ec2);
          if (sc2 == ec2 && options.start && options.start.start && options.skipCurrent != false && firstRange.isEqual(options.start)) {
            firstRange = null;
            return false;
          }
          return true;
        });
        return firstRange;
      };
      this.findAll = function(session) {
        var options = this.$options;
        if (!options.needle)
          return [];
        this.$assembleRegExp(options);
        var range = options.range;
        var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
        var ranges = [];
        var re2 = options.re;
        if (options.$isMultiLine) {
          var len = re2.length;
          var maxRow = lines.length - len;
          var prevRange;
          outer:
            for (var row = re2.offset || 0; row <= maxRow; row++) {
              for (var j = 0; j < len; j++)
                if (lines[row + j].search(re2[j]) == -1)
                  continue outer;
              var startLine = lines[row];
              var line = lines[row + len - 1];
              var startIndex = startLine.length - startLine.match(re2[0])[0].length;
              var endIndex = line.match(re2[len - 1])[0].length;
              if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                continue;
              }
              ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
              if (len > 2)
                row = row + len - 2;
            }
        } else {
          for (var i = 0; i < lines.length; i++) {
            var matches = lang.getMatchOffsets(lines[i], re2);
            for (var j = 0; j < matches.length; j++) {
              var match = matches[j];
              ranges.push(new Range(i, match.offset, i, match.offset + match.length));
            }
          }
        }
        if (range) {
          var startColumn = range.start.column;
          var endColumn = range.start.column;
          var i = 0, j = ranges.length - 1;
          while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
            i++;
          while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
            j--;
          ranges = ranges.slice(i, j + 1);
          for (i = 0, j = ranges.length; i < j; i++) {
            ranges[i].start.row += range.start.row;
            ranges[i].end.row += range.start.row;
          }
        }
        return ranges;
      };
      this.replace = function(input, replacement) {
        var options = this.$options;
        var re2 = this.$assembleRegExp(options);
        if (options.$isMultiLine)
          return replacement;
        if (!re2)
          return;
        var match = re2.exec(input);
        if (!match || match[0].length != input.length)
          return null;
        replacement = input.replace(re2, replacement);
        if (options.preserveCase) {
          replacement = replacement.split("");
          for (var i = Math.min(input.length, input.length); i--; ) {
            var ch2 = input[i];
            if (ch2 && ch2.toLowerCase() != ch2)
              replacement[i] = replacement[i].toUpperCase();
            else
              replacement[i] = replacement[i].toLowerCase();
          }
          replacement = replacement.join("");
        }
        return replacement;
      };
      this.$assembleRegExp = function(options, $disableFakeMultiline) {
        if (options.needle instanceof RegExp)
          return options.re = options.needle;
        var needle = options.needle;
        if (!options.needle)
          return options.re = false;
        if (!options.regExp)
          needle = lang.escapeRegExp(needle);
        if (options.wholeWord)
          needle = addWordBoundary(needle, options);
        var modifier = options.caseSensitive ? "gm" : "gmi";
        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
        if (options.$isMultiLine)
          return options.re = this.$assembleMultilineRegExp(needle, modifier);
        try {
          var re2 = new RegExp(needle, modifier);
        } catch (e2) {
          re2 = false;
        }
        return options.re = re2;
      };
      this.$assembleMultilineRegExp = function(needle, modifier) {
        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
        var re2 = [];
        for (var i = 0; i < parts.length; i++)
          try {
            re2.push(new RegExp(parts[i], modifier));
          } catch (e2) {
            return false;
          }
        return re2;
      };
      this.$matchIterator = function(session, options) {
        var re2 = this.$assembleRegExp(options);
        if (!re2)
          return false;
        var backwards = options.backwards == true;
        var skipCurrent = options.skipCurrent != false;
        var range = options.range;
        var start = options.start;
        if (!start)
          start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
        if (start.start)
          start = start[skipCurrent != backwards ? "end" : "start"];
        var firstRow = range ? range.start.row : 0;
        var lastRow = range ? range.end.row : session.getLength() - 1;
        if (backwards) {
          var forEach = function(callback) {
            var row = start.row;
            if (forEachInLine(row, start.column, callback))
              return;
            for (row--; row >= firstRow; row--)
              if (forEachInLine(row, Number.MAX_VALUE, callback))
                return;
            if (options.wrap == false)
              return;
            for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
              if (forEachInLine(row, Number.MAX_VALUE, callback))
                return;
          };
        } else {
          var forEach = function(callback) {
            var row = start.row;
            if (forEachInLine(row, start.column, callback))
              return;
            for (row = row + 1; row <= lastRow; row++)
              if (forEachInLine(row, 0, callback))
                return;
            if (options.wrap == false)
              return;
            for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
              if (forEachInLine(row, 0, callback))
                return;
          };
        }
        if (options.$isMultiLine) {
          var len = re2.length;
          var forEachInLine = function(row, offset, callback) {
            var startRow = backwards ? row - len + 1 : row;
            if (startRow < 0)
              return;
            var line = session.getLine(startRow);
            var startIndex = line.search(re2[0]);
            if (!backwards && startIndex < offset || startIndex === -1)
              return;
            for (var i = 1; i < len; i++) {
              line = session.getLine(startRow + i);
              if (line.search(re2[i]) == -1)
                return;
            }
            var endIndex = line.match(re2[len - 1])[0].length;
            if (backwards && endIndex > offset)
              return;
            if (callback(startRow, startIndex, startRow + len - 1, endIndex))
              return true;
          };
        } else if (backwards) {
          var forEachInLine = function(row, endIndex, callback) {
            var line = session.getLine(row);
            var matches = [];
            var m2, last = 0;
            re2.lastIndex = 0;
            while (m2 = re2.exec(line)) {
              var length = m2[0].length;
              last = m2.index;
              if (!length) {
                if (last >= line.length)
                  break;
                re2.lastIndex = last += 1;
              }
              if (m2.index + length > endIndex)
                break;
              matches.push(m2.index, length);
            }
            for (var i = matches.length - 1; i >= 0; i -= 2) {
              var column = matches[i - 1];
              var length = matches[i];
              if (callback(row, column, row, column + length))
                return true;
            }
          };
        } else {
          var forEachInLine = function(row, startIndex, callback) {
            var line = session.getLine(row);
            var last;
            var m2;
            re2.lastIndex = startIndex;
            while (m2 = re2.exec(line)) {
              var length = m2[0].length;
              last = m2.index;
              if (callback(row, last, row, last + length))
                return true;
              if (!length) {
                re2.lastIndex = last += 1;
                if (last >= line.length)
                  return false;
              }
            }
          };
        }
        return {forEach};
      };
    }).call(Search.prototype);
    function addWordBoundary(needle, options) {
      function wordBoundary(c2) {
        if (/\w/.test(c2) || options.regExp)
          return "\\b";
        return "";
      }
      return wordBoundary(needle[0]) + needle + wordBoundary(needle[needle.length - 1]);
    }
    exports2.Search = Search;
  });
  ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require2, exports2, module2) {
    var keyUtil = require2("../lib/keys");
    var useragent = require2("../lib/useragent");
    var KEY_MODS = keyUtil.KEY_MODS;
    function HashHandler(config, platform) {
      this.platform = platform || (useragent.isMac ? "mac" : "win");
      this.commands = {};
      this.commandKeyBinding = {};
      this.addCommands(config);
      this.$singleCommand = true;
    }
    function MultiHashHandler(config, platform) {
      HashHandler.call(this, config, platform);
      this.$singleCommand = false;
    }
    MultiHashHandler.prototype = HashHandler.prototype;
    (function() {
      this.addCommand = function(command) {
        if (this.commands[command.name])
          this.removeCommand(command);
        this.commands[command.name] = command;
        if (command.bindKey)
          this._buildKeyHash(command);
      };
      this.removeCommand = function(command, keepCommand) {
        var name = command && (typeof command === "string" ? command : command.name);
        command = this.commands[name];
        if (!keepCommand)
          delete this.commands[name];
        var ckb = this.commandKeyBinding;
        for (var keyId in ckb) {
          var cmdGroup = ckb[keyId];
          if (cmdGroup == command) {
            delete ckb[keyId];
          } else if (Array.isArray(cmdGroup)) {
            var i = cmdGroup.indexOf(command);
            if (i != -1) {
              cmdGroup.splice(i, 1);
              if (cmdGroup.length == 1)
                ckb[keyId] = cmdGroup[0];
            }
          }
        }
      };
      this.bindKey = function(key, command, position) {
        if (typeof key == "object" && key) {
          if (position == void 0)
            position = key.position;
          key = key[this.platform];
        }
        if (!key)
          return;
        if (typeof command == "function")
          return this.addCommand({exec: command, bindKey: key, name: command.name || key});
        key.split("|").forEach(function(keyPart) {
          var chain = "";
          if (keyPart.indexOf(" ") != -1) {
            var parts = keyPart.split(/\s+/);
            keyPart = parts.pop();
            parts.forEach(function(keyPart2) {
              var binding2 = this.parseKeys(keyPart2);
              var id3 = KEY_MODS[binding2.hashId] + binding2.key;
              chain += (chain ? " " : "") + id3;
              this._addCommandToBinding(chain, "chainKeys");
            }, this);
            chain += " ";
          }
          var binding = this.parseKeys(keyPart);
          var id2 = KEY_MODS[binding.hashId] + binding.key;
          this._addCommandToBinding(chain + id2, command, position);
        }, this);
      };
      function getPosition(command) {
        return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
      }
      this._addCommandToBinding = function(keyId, command, position) {
        var ckb = this.commandKeyBinding, i;
        if (!command) {
          delete ckb[keyId];
        } else if (!ckb[keyId] || this.$singleCommand) {
          ckb[keyId] = command;
        } else {
          if (!Array.isArray(ckb[keyId])) {
            ckb[keyId] = [ckb[keyId]];
          } else if ((i = ckb[keyId].indexOf(command)) != -1) {
            ckb[keyId].splice(i, 1);
          }
          if (typeof position != "number") {
            position = getPosition(command);
          }
          var commands = ckb[keyId];
          for (i = 0; i < commands.length; i++) {
            var other = commands[i];
            var otherPos = getPosition(other);
            if (otherPos > position)
              break;
          }
          commands.splice(i, 0, command);
        }
      };
      this.addCommands = function(commands) {
        commands && Object.keys(commands).forEach(function(name) {
          var command = commands[name];
          if (!command)
            return;
          if (typeof command === "string")
            return this.bindKey(command, name);
          if (typeof command === "function")
            command = {exec: command};
          if (typeof command !== "object")
            return;
          if (!command.name)
            command.name = name;
          this.addCommand(command);
        }, this);
      };
      this.removeCommands = function(commands) {
        Object.keys(commands).forEach(function(name) {
          this.removeCommand(commands[name]);
        }, this);
      };
      this.bindKeys = function(keyList) {
        Object.keys(keyList).forEach(function(key) {
          this.bindKey(key, keyList[key]);
        }, this);
      };
      this._buildKeyHash = function(command) {
        this.bindKey(command.bindKey, command);
      };
      this.parseKeys = function(keys) {
        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x2) {
          return x2;
        });
        var key = parts.pop();
        var keyCode = keyUtil[key];
        if (keyUtil.FUNCTION_KEYS[keyCode])
          key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
        else if (!parts.length)
          return {key, hashId: -1};
        else if (parts.length == 1 && parts[0] == "shift")
          return {key: key.toUpperCase(), hashId: -1};
        var hashId = 0;
        for (var i = parts.length; i--; ) {
          var modifier = keyUtil.KEY_MODS[parts[i]];
          if (modifier == null) {
            if (typeof console != "undefined")
              console.error("invalid modifier " + parts[i] + " in " + keys);
            return false;
          }
          hashId |= modifier;
        }
        return {key, hashId};
      };
      this.findKeyCommand = function findKeyCommand(hashId, keyString) {
        var key = KEY_MODS[hashId] + keyString;
        return this.commandKeyBinding[key];
      };
      this.handleKeyboard = function(data, hashId, keyString, keyCode) {
        if (keyCode < 0)
          return;
        var key = KEY_MODS[hashId] + keyString;
        var command = this.commandKeyBinding[key];
        if (data.$keyChain) {
          data.$keyChain += " " + key;
          command = this.commandKeyBinding[data.$keyChain] || command;
        }
        if (command) {
          if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
            data.$keyChain = data.$keyChain || key;
            return {command: "null"};
          }
        }
        if (data.$keyChain) {
          if ((!hashId || hashId == 4) && keyString.length == 1)
            data.$keyChain = data.$keyChain.slice(0, -key.length - 1);
          else if (hashId == -1 || keyCode > 0)
            data.$keyChain = "";
        }
        return {command};
      };
      this.getStatusText = function(editor, data) {
        return data.$keyChain || "";
      };
    }).call(HashHandler.prototype);
    exports2.HashHandler = HashHandler;
    exports2.MultiHashHandler = MultiHashHandler;
  });
  ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var MultiHashHandler = require2("../keyboard/hash_handler").MultiHashHandler;
    var EventEmitter = require2("../lib/event_emitter").EventEmitter;
    var CommandManager = function(platform, commands) {
      MultiHashHandler.call(this, commands, platform);
      this.byName = this.commands;
      this.setDefaultHandler("exec", function(e2) {
        return e2.command.exec(e2.editor, e2.args || {});
      });
    };
    oop.inherits(CommandManager, MultiHashHandler);
    (function() {
      oop.implement(this, EventEmitter);
      this.exec = function(command, editor, args) {
        if (Array.isArray(command)) {
          for (var i = command.length; i--; ) {
            if (this.exec(command[i], editor, args))
              return true;
          }
          return false;
        }
        if (typeof command === "string")
          command = this.commands[command];
        if (!command)
          return false;
        if (editor && editor.$readOnly && !command.readOnly)
          return false;
        if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
          return false;
        var e2 = {editor, command, args};
        e2.returnValue = this._emit("exec", e2);
        this._signal("afterExec", e2);
        return e2.returnValue === false ? false : true;
      };
      this.toggleRecording = function(editor) {
        if (this.$inReplay)
          return;
        editor && editor._emit("changeStatus");
        if (this.recording) {
          this.macro.pop();
          this.off("exec", this.$addCommandToMacro);
          if (!this.macro.length)
            this.macro = this.oldMacro;
          return this.recording = false;
        }
        if (!this.$addCommandToMacro) {
          this.$addCommandToMacro = function(e2) {
            this.macro.push([e2.command, e2.args]);
          }.bind(this);
        }
        this.oldMacro = this.macro;
        this.macro = [];
        this.on("exec", this.$addCommandToMacro);
        return this.recording = true;
      };
      this.replay = function(editor) {
        if (this.$inReplay || !this.macro)
          return;
        if (this.recording)
          return this.toggleRecording(editor);
        try {
          this.$inReplay = true;
          this.macro.forEach(function(x2) {
            if (typeof x2 == "string")
              this.exec(x2, editor);
            else
              this.exec(x2[0], editor, x2[1]);
          }, this);
        } finally {
          this.$inReplay = false;
        }
      };
      this.trimMacro = function(m2) {
        return m2.map(function(x2) {
          if (typeof x2[0] != "string")
            x2[0] = x2[0].name;
          if (!x2[1])
            x2 = x2[0];
          return x2;
        });
      };
    }).call(CommandManager.prototype);
    exports2.CommandManager = CommandManager;
  });
  ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function(require2, exports2, module2) {
    var lang = require2("../lib/lang");
    var config = require2("../config");
    var Range = require2("../range").Range;
    function bindKey(win, mac) {
      return {win, mac};
    }
    exports2.commands = [
      {
        name: "showSettingsMenu",
        bindKey: bindKey("Ctrl-,", "Command-,"),
        exec: function(editor) {
          config.loadModule("ace/ext/settings_menu", function(module3) {
            module3.init(editor);
            editor.showSettingsMenu();
          });
        },
        readOnly: true
      },
      {
        name: "goToNextError",
        bindKey: bindKey("Alt-E", "F4"),
        exec: function(editor) {
          config.loadModule("./ext/error_marker", function(module3) {
            module3.showErrorMarker(editor, 1);
          });
        },
        scrollIntoView: "animate",
        readOnly: true
      },
      {
        name: "goToPreviousError",
        bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
        exec: function(editor) {
          config.loadModule("./ext/error_marker", function(module3) {
            module3.showErrorMarker(editor, -1);
          });
        },
        scrollIntoView: "animate",
        readOnly: true
      },
      {
        name: "selectall",
        description: "Select all",
        bindKey: bindKey("Ctrl-A", "Command-A"),
        exec: function(editor) {
          editor.selectAll();
        },
        readOnly: true
      },
      {
        name: "centerselection",
        description: "Center selection",
        bindKey: bindKey(null, "Ctrl-L"),
        exec: function(editor) {
          editor.centerSelection();
        },
        readOnly: true
      },
      {
        name: "gotoline",
        description: "Go to line...",
        bindKey: bindKey("Ctrl-L", "Command-L"),
        exec: function(editor, line) {
          if (typeof line === "number" && !isNaN(line))
            editor.gotoLine(line);
          editor.prompt({$type: "gotoLine"});
        },
        readOnly: true
      },
      {
        name: "fold",
        bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
        exec: function(editor) {
          editor.session.toggleFold(false);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "unfold",
        bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
        exec: function(editor) {
          editor.session.toggleFold(true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "toggleFoldWidget",
        bindKey: bindKey("F2", "F2"),
        exec: function(editor) {
          editor.session.toggleFoldWidget();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "toggleParentFoldWidget",
        bindKey: bindKey("Alt-F2", "Alt-F2"),
        exec: function(editor) {
          editor.session.toggleFoldWidget(true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "foldall",
        description: "Fold all",
        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
        exec: function(editor) {
          editor.session.foldAll();
        },
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "foldAllComments",
        description: "Fold all comments",
        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
        exec: function(editor) {
          editor.session.foldAllComments();
        },
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "foldOther",
        description: "Fold other",
        bindKey: bindKey("Alt-0", "Command-Option-0"),
        exec: function(editor) {
          editor.session.foldAll();
          editor.session.unfold(editor.selection.getAllRanges());
        },
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "unfoldall",
        description: "Unfold all",
        bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
        exec: function(editor) {
          editor.session.unfold();
        },
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "findnext",
        description: "Find next",
        bindKey: bindKey("Ctrl-K", "Command-G"),
        exec: function(editor) {
          editor.findNext();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "findprevious",
        description: "Find previous",
        bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
        exec: function(editor) {
          editor.findPrevious();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "selectOrFindNext",
        description: "Select or find next",
        bindKey: bindKey("Alt-K", "Ctrl-G"),
        exec: function(editor) {
          if (editor.selection.isEmpty())
            editor.selection.selectWord();
          else
            editor.findNext();
        },
        readOnly: true
      },
      {
        name: "selectOrFindPrevious",
        description: "Select or find previous",
        bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
        exec: function(editor) {
          if (editor.selection.isEmpty())
            editor.selection.selectWord();
          else
            editor.findPrevious();
        },
        readOnly: true
      },
      {
        name: "find",
        description: "Find",
        bindKey: bindKey("Ctrl-F", "Command-F"),
        exec: function(editor) {
          config.loadModule("ace/ext/searchbox", function(e2) {
            e2.Search(editor);
          });
        },
        readOnly: true
      },
      {
        name: "overwrite",
        description: "Overwrite",
        bindKey: "Insert",
        exec: function(editor) {
          editor.toggleOverwrite();
        },
        readOnly: true
      },
      {
        name: "selecttostart",
        description: "Select to start",
        bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
        exec: function(editor) {
          editor.getSelection().selectFileStart();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      },
      {
        name: "gotostart",
        description: "Go to start",
        bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
        exec: function(editor) {
          editor.navigateFileStart();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      },
      {
        name: "selectup",
        description: "Select up",
        bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
        exec: function(editor) {
          editor.getSelection().selectUp();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "golineup",
        description: "Go line up",
        bindKey: bindKey("Up", "Up|Ctrl-P"),
        exec: function(editor, args) {
          editor.navigateUp(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selecttoend",
        description: "Select to end",
        bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
        exec: function(editor) {
          editor.getSelection().selectFileEnd();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      },
      {
        name: "gotoend",
        description: "Go to end",
        bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
        exec: function(editor) {
          editor.navigateFileEnd();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      },
      {
        name: "selectdown",
        description: "Select down",
        bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
        exec: function(editor) {
          editor.getSelection().selectDown();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "golinedown",
        description: "Go line down",
        bindKey: bindKey("Down", "Down|Ctrl-N"),
        exec: function(editor, args) {
          editor.navigateDown(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selectwordleft",
        description: "Select word left",
        bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
        exec: function(editor) {
          editor.getSelection().selectWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "gotowordleft",
        description: "Go to word left",
        bindKey: bindKey("Ctrl-Left", "Option-Left"),
        exec: function(editor) {
          editor.navigateWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selecttolinestart",
        description: "Select to line start",
        bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
        exec: function(editor) {
          editor.getSelection().selectLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "gotolinestart",
        description: "Go to line start",
        bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
        exec: function(editor) {
          editor.navigateLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selectleft",
        description: "Select left",
        bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
        exec: function(editor) {
          editor.getSelection().selectLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "gotoleft",
        description: "Go to left",
        bindKey: bindKey("Left", "Left|Ctrl-B"),
        exec: function(editor, args) {
          editor.navigateLeft(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selectwordright",
        description: "Select word right",
        bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
        exec: function(editor) {
          editor.getSelection().selectWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "gotowordright",
        description: "Go to word right",
        bindKey: bindKey("Ctrl-Right", "Option-Right"),
        exec: function(editor) {
          editor.navigateWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selecttolineend",
        description: "Select to line end",
        bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
        exec: function(editor) {
          editor.getSelection().selectLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "gotolineend",
        description: "Go to line end",
        bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
        exec: function(editor) {
          editor.navigateLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selectright",
        description: "Select right",
        bindKey: bindKey("Shift-Right", "Shift-Right"),
        exec: function(editor) {
          editor.getSelection().selectRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "gotoright",
        description: "Go to right",
        bindKey: bindKey("Right", "Right|Ctrl-F"),
        exec: function(editor, args) {
          editor.navigateRight(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selectpagedown",
        description: "Select page down",
        bindKey: "Shift-PageDown",
        exec: function(editor) {
          editor.selectPageDown();
        },
        readOnly: true
      },
      {
        name: "pagedown",
        description: "Page down",
        bindKey: bindKey(null, "Option-PageDown"),
        exec: function(editor) {
          editor.scrollPageDown();
        },
        readOnly: true
      },
      {
        name: "gotopagedown",
        description: "Go to page down",
        bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
        exec: function(editor) {
          editor.gotoPageDown();
        },
        readOnly: true
      },
      {
        name: "selectpageup",
        description: "Select page up",
        bindKey: "Shift-PageUp",
        exec: function(editor) {
          editor.selectPageUp();
        },
        readOnly: true
      },
      {
        name: "pageup",
        description: "Page up",
        bindKey: bindKey(null, "Option-PageUp"),
        exec: function(editor) {
          editor.scrollPageUp();
        },
        readOnly: true
      },
      {
        name: "gotopageup",
        description: "Go to page up",
        bindKey: "PageUp",
        exec: function(editor) {
          editor.gotoPageUp();
        },
        readOnly: true
      },
      {
        name: "scrollup",
        description: "Scroll up",
        bindKey: bindKey("Ctrl-Up", null),
        exec: function(e2) {
          e2.renderer.scrollBy(0, -2 * e2.renderer.layerConfig.lineHeight);
        },
        readOnly: true
      },
      {
        name: "scrolldown",
        description: "Scroll down",
        bindKey: bindKey("Ctrl-Down", null),
        exec: function(e2) {
          e2.renderer.scrollBy(0, 2 * e2.renderer.layerConfig.lineHeight);
        },
        readOnly: true
      },
      {
        name: "selectlinestart",
        description: "Select line start",
        bindKey: "Shift-Home",
        exec: function(editor) {
          editor.getSelection().selectLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selectlineend",
        description: "Select line end",
        bindKey: "Shift-End",
        exec: function(editor) {
          editor.getSelection().selectLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "togglerecording",
        description: "Toggle recording",
        bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
        exec: function(editor) {
          editor.commands.toggleRecording(editor);
        },
        readOnly: true
      },
      {
        name: "replaymacro",
        description: "Replay macro",
        bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
        exec: function(editor) {
          editor.commands.replay(editor);
        },
        readOnly: true
      },
      {
        name: "jumptomatching",
        description: "Jump to matching",
        bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
        exec: function(editor) {
          editor.jumpToMatching();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
      },
      {
        name: "selecttomatching",
        description: "Select to matching",
        bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
        exec: function(editor) {
          editor.jumpToMatching(true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
      },
      {
        name: "expandToMatching",
        description: "Expand to matching",
        bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
        exec: function(editor) {
          editor.jumpToMatching(true, true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
      },
      {
        name: "passKeysToBrowser",
        description: "Pass keys to browser",
        bindKey: bindKey(null, null),
        exec: function() {
        },
        passEvent: true,
        readOnly: true
      },
      {
        name: "copy",
        description: "Copy",
        exec: function(editor) {
        },
        readOnly: true
      },
      {
        name: "cut",
        description: "Cut",
        exec: function(editor) {
          var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
          var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
          editor._emit("cut", range);
          if (!range.isEmpty())
            editor.session.remove(range);
          editor.clearSelection();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      },
      {
        name: "paste",
        description: "Paste",
        exec: function(editor, args) {
          editor.$handlePaste(args);
        },
        scrollIntoView: "cursor"
      },
      {
        name: "removeline",
        description: "Remove line",
        bindKey: bindKey("Ctrl-D", "Command-D"),
        exec: function(editor) {
          editor.removeLines();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEachLine"
      },
      {
        name: "duplicateSelection",
        description: "Duplicate selection",
        bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
        exec: function(editor) {
          editor.duplicateSelection();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      },
      {
        name: "sortlines",
        description: "Sort lines",
        bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
        exec: function(editor) {
          editor.sortLines();
        },
        scrollIntoView: "selection",
        multiSelectAction: "forEachLine"
      },
      {
        name: "togglecomment",
        description: "Toggle comment",
        bindKey: bindKey("Ctrl-/", "Command-/"),
        exec: function(editor) {
          editor.toggleCommentLines();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      },
      {
        name: "toggleBlockComment",
        description: "Toggle block comment",
        bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
        exec: function(editor) {
          editor.toggleBlockComment();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      },
      {
        name: "modifyNumberUp",
        description: "Modify number up",
        bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
        exec: function(editor) {
          editor.modifyNumber(1);
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      },
      {
        name: "modifyNumberDown",
        description: "Modify number down",
        bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
        exec: function(editor) {
          editor.modifyNumber(-1);
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      },
      {
        name: "replace",
        description: "Replace",
        bindKey: bindKey("Ctrl-H", "Command-Option-F"),
        exec: function(editor) {
          config.loadModule("ace/ext/searchbox", function(e2) {
            e2.Search(editor, true);
          });
        }
      },
      {
        name: "undo",
        description: "Undo",
        bindKey: bindKey("Ctrl-Z", "Command-Z"),
        exec: function(editor) {
          editor.undo();
        }
      },
      {
        name: "redo",
        description: "Redo",
        bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
        exec: function(editor) {
          editor.redo();
        }
      },
      {
        name: "copylinesup",
        description: "Copy lines up",
        bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
        exec: function(editor) {
          editor.copyLinesUp();
        },
        scrollIntoView: "cursor"
      },
      {
        name: "movelinesup",
        description: "Move lines up",
        bindKey: bindKey("Alt-Up", "Option-Up"),
        exec: function(editor) {
          editor.moveLinesUp();
        },
        scrollIntoView: "cursor"
      },
      {
        name: "copylinesdown",
        description: "Copy lines down",
        bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
        exec: function(editor) {
          editor.copyLinesDown();
        },
        scrollIntoView: "cursor"
      },
      {
        name: "movelinesdown",
        description: "Move lines down",
        bindKey: bindKey("Alt-Down", "Option-Down"),
        exec: function(editor) {
          editor.moveLinesDown();
        },
        scrollIntoView: "cursor"
      },
      {
        name: "del",
        description: "Delete",
        bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
        exec: function(editor) {
          editor.remove("right");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "backspace",
        description: "Backspace",
        bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
        exec: function(editor) {
          editor.remove("left");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "cut_or_delete",
        description: "Cut or delete",
        bindKey: bindKey("Shift-Delete", null),
        exec: function(editor) {
          if (editor.selection.isEmpty()) {
            editor.remove("left");
          } else {
            return false;
          }
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removetolinestart",
        description: "Remove to line start",
        bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
        exec: function(editor) {
          editor.removeToLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removetolineend",
        description: "Remove to line end",
        bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
        exec: function(editor) {
          editor.removeToLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removetolinestarthard",
        description: "Remove to line start hard",
        bindKey: bindKey("Ctrl-Shift-Backspace", null),
        exec: function(editor) {
          var range = editor.selection.getRange();
          range.start.column = 0;
          editor.session.remove(range);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removetolineendhard",
        description: "Remove to line end hard",
        bindKey: bindKey("Ctrl-Shift-Delete", null),
        exec: function(editor) {
          var range = editor.selection.getRange();
          range.end.column = Number.MAX_VALUE;
          editor.session.remove(range);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removewordleft",
        description: "Remove word left",
        bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
        exec: function(editor) {
          editor.removeWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removewordright",
        description: "Remove word right",
        bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
        exec: function(editor) {
          editor.removeWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "outdent",
        description: "Outdent",
        bindKey: bindKey("Shift-Tab", "Shift-Tab"),
        exec: function(editor) {
          editor.blockOutdent();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      },
      {
        name: "indent",
        description: "Indent",
        bindKey: bindKey("Tab", "Tab"),
        exec: function(editor) {
          editor.indent();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      },
      {
        name: "blockoutdent",
        description: "Block outdent",
        bindKey: bindKey("Ctrl-[", "Ctrl-["),
        exec: function(editor) {
          editor.blockOutdent();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      },
      {
        name: "blockindent",
        description: "Block indent",
        bindKey: bindKey("Ctrl-]", "Ctrl-]"),
        exec: function(editor) {
          editor.blockIndent();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      },
      {
        name: "insertstring",
        description: "Insert string",
        exec: function(editor, str2) {
          editor.insert(str2);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "inserttext",
        description: "Insert text",
        exec: function(editor, args) {
          editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "splitline",
        description: "Split line",
        bindKey: bindKey(null, "Ctrl-O"),
        exec: function(editor) {
          editor.splitLine();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "transposeletters",
        description: "Transpose letters",
        bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
        exec: function(editor) {
          editor.transposeLetters();
        },
        multiSelectAction: function(editor) {
          editor.transposeSelections(1);
        },
        scrollIntoView: "cursor"
      },
      {
        name: "touppercase",
        description: "To uppercase",
        bindKey: bindKey("Ctrl-U", "Ctrl-U"),
        exec: function(editor) {
          editor.toUpperCase();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "tolowercase",
        description: "To lowercase",
        bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
        exec: function(editor) {
          editor.toLowerCase();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "autoindent",
        description: "Auto Indent",
        bindKey: bindKey(null, null),
        exec: function(editor) {
          editor.autoIndent();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "animate"
      },
      {
        name: "expandtoline",
        description: "Expand to line",
        bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
        exec: function(editor) {
          var range = editor.selection.getRange();
          range.start.column = range.end.column = 0;
          range.end.row++;
          editor.selection.setRange(range, false);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "joinlines",
        description: "Join lines",
        bindKey: bindKey(null, null),
        exec: function(editor) {
          var isBackwards = editor.selection.isBackwards();
          var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
          var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
          var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
          var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
          var selectedCount = selectedText.replace(/\n\s*/, " ").length;
          var insertLine = editor.session.doc.getLine(selectionStart.row);
          for (var i2 = selectionStart.row + 1; i2 <= selectionEnd.row + 1; i2++) {
            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i2)));
            if (curLine.length !== 0) {
              curLine = " " + curLine;
            }
            insertLine += curLine;
          }
          if (selectionEnd.row + 1 < editor.session.doc.getLength() - 1) {
            insertLine += editor.session.doc.getNewLineCharacter();
          }
          editor.clearSelection();
          editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
          if (selectedCount > 0) {
            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
          } else {
            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
          }
        },
        multiSelectAction: "forEach",
        readOnly: true
      },
      {
        name: "invertSelection",
        description: "Invert selection",
        bindKey: bindKey(null, null),
        exec: function(editor) {
          var endRow = editor.session.doc.getLength() - 1;
          var endCol = editor.session.doc.getLine(endRow).length;
          var ranges = editor.selection.rangeList.ranges;
          var newRanges = [];
          if (ranges.length < 1) {
            ranges = [editor.selection.getRange()];
          }
          for (var i2 = 0; i2 < ranges.length; i2++) {
            if (i2 == ranges.length - 1) {
              if (!(ranges[i2].end.row === endRow && ranges[i2].end.column === endCol)) {
                newRanges.push(new Range(ranges[i2].end.row, ranges[i2].end.column, endRow, endCol));
              }
            }
            if (i2 === 0) {
              if (!(ranges[i2].start.row === 0 && ranges[i2].start.column === 0)) {
                newRanges.push(new Range(0, 0, ranges[i2].start.row, ranges[i2].start.column));
              }
            } else {
              newRanges.push(new Range(ranges[i2 - 1].end.row, ranges[i2 - 1].end.column, ranges[i2].start.row, ranges[i2].start.column));
            }
          }
          editor.exitMultiSelectMode();
          editor.clearSelection();
          for (var i2 = 0; i2 < newRanges.length; i2++) {
            editor.selection.addRange(newRanges[i2], false);
          }
        },
        readOnly: true,
        scrollIntoView: "none"
      },
      {
        name: "addLineAfter",
        exec: function(editor) {
          editor.selection.clearSelection();
          editor.navigateLineEnd();
          editor.insert("\n");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "addLineBefore",
        exec: function(editor) {
          editor.selection.clearSelection();
          var cursor = editor.getCursorPosition();
          editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
          editor.insert("\n");
          if (cursor.row === 0)
            editor.navigateUp();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "openCommandPallete",
        description: "Open command pallete",
        bindKey: bindKey("F1", "F1"),
        exec: function(editor) {
          editor.prompt({$type: "commands"});
        },
        readOnly: true
      },
      {
        name: "modeSelect",
        description: "Change language mode...",
        bindKey: bindKey(null, null),
        exec: function(editor) {
          editor.prompt({$type: "modes"});
        },
        readOnly: true
      }
    ];
    for (var i = 1; i < 9; i++) {
      exports2.commands.push({
        name: "foldToLevel" + i,
        description: "Fold To Level " + i,
        level: i,
        exec: function(editor) {
          editor.session.foldToLevel(this.level);
        },
        scrollIntoView: "center",
        readOnly: true
      });
    }
  });
  ace.define("ace/editor", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator", "ace/clipboard"], function(require2, exports2, module2) {
    require2("./lib/fixoldbrowsers");
    var oop = require2("./lib/oop");
    var dom = require2("./lib/dom");
    var lang = require2("./lib/lang");
    var useragent = require2("./lib/useragent");
    var TextInput = require2("./keyboard/textinput").TextInput;
    var MouseHandler = require2("./mouse/mouse_handler").MouseHandler;
    var FoldHandler = require2("./mouse/fold_handler").FoldHandler;
    var KeyBinding = require2("./keyboard/keybinding").KeyBinding;
    var EditSession = require2("./edit_session").EditSession;
    var Search = require2("./search").Search;
    var Range = require2("./range").Range;
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var CommandManager = require2("./commands/command_manager").CommandManager;
    var defaultCommands = require2("./commands/default_commands").commands;
    var config = require2("./config");
    var TokenIterator = require2("./token_iterator").TokenIterator;
    var clipboard = require2("./clipboard");
    var Editor = function(renderer, session, options) {
      this.$toDestroy = [];
      var container = renderer.getContainerElement();
      this.container = container;
      this.renderer = renderer;
      this.id = "editor" + ++Editor.$uid;
      this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
      if (typeof document == "object") {
        this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
        this.renderer.textarea = this.textInput.getElement();
        this.$mouseHandler = new MouseHandler(this);
        new FoldHandler(this);
      }
      this.keyBinding = new KeyBinding(this);
      this.$search = new Search().set({
        wrap: true
      });
      this.$historyTracker = this.$historyTracker.bind(this);
      this.commands.on("exec", this.$historyTracker);
      this.$initOperationListeners();
      this._$emitInputEvent = lang.delayedCall(function() {
        this._signal("input", {});
        if (this.session && this.session.bgTokenizer)
          this.session.bgTokenizer.scheduleStart();
      }.bind(this));
      this.on("change", function(_, _self) {
        _self._$emitInputEvent.schedule(31);
      });
      this.setSession(session || options && options.session || new EditSession(""));
      config.resetOptions(this);
      if (options)
        this.setOptions(options);
      config._signal("editor", this);
    };
    Editor.$uid = 0;
    (function() {
      oop.implement(this, EventEmitter);
      this.$initOperationListeners = function() {
        this.commands.on("exec", this.startOperation.bind(this), true);
        this.commands.on("afterExec", this.endOperation.bind(this), true);
        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
        this.on("change", function() {
          if (!this.curOp) {
            this.startOperation();
            this.curOp.selectionBefore = this.$lastSel;
          }
          this.curOp.docChanged = true;
        }.bind(this), true);
        this.on("changeSelection", function() {
          if (!this.curOp) {
            this.startOperation();
            this.curOp.selectionBefore = this.$lastSel;
          }
          this.curOp.selectionChanged = true;
        }.bind(this), true);
      };
      this.curOp = null;
      this.prevOp = {};
      this.startOperation = function(commandEvent) {
        if (this.curOp) {
          if (!commandEvent || this.curOp.command)
            return;
          this.prevOp = this.curOp;
        }
        if (!commandEvent) {
          this.previousCommand = null;
          commandEvent = {};
        }
        this.$opResetTimer.schedule();
        this.curOp = this.session.curOp = {
          command: commandEvent.command || {},
          args: commandEvent.args,
          scrollTop: this.renderer.scrollTop
        };
        this.curOp.selectionBefore = this.selection.toJSON();
      };
      this.endOperation = function(e2) {
        if (this.curOp && this.session) {
          if (e2 && e2.returnValue === false || !this.session)
            return this.curOp = null;
          if (e2 == true && this.curOp.command && this.curOp.command.name == "mouse")
            return;
          this._signal("beforeEndOperation");
          if (!this.curOp)
            return;
          var command = this.curOp.command;
          var scrollIntoView = command && command.scrollIntoView;
          if (scrollIntoView) {
            switch (scrollIntoView) {
              case "center-animate":
                scrollIntoView = "animate";
              case "center":
                this.renderer.scrollCursorIntoView(null, 0.5);
                break;
              case "animate":
              case "cursor":
                this.renderer.scrollCursorIntoView();
                break;
              case "selectionPart":
                var range = this.selection.getRange();
                var config2 = this.renderer.layerConfig;
                if (range.start.row >= config2.lastRow || range.end.row <= config2.firstRow) {
                  this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                }
                break;
            }
            if (scrollIntoView == "animate")
              this.renderer.animateScrolling(this.curOp.scrollTop);
          }
          var sel = this.selection.toJSON();
          this.curOp.selectionAfter = sel;
          this.$lastSel = this.selection.toJSON();
          this.session.getUndoManager().addSelection(sel);
          this.prevOp = this.curOp;
          this.curOp = null;
        }
      };
      this.$mergeableCommands = ["backspace", "del", "insertstring"];
      this.$historyTracker = function(e2) {
        if (!this.$mergeUndoDeltas)
          return;
        var prev = this.prevOp;
        var mergeableCommands = this.$mergeableCommands;
        var shouldMerge = prev.command && e2.command.name == prev.command.name;
        if (e2.command.name == "insertstring") {
          var text = e2.args;
          if (this.mergeNextCommand === void 0)
            this.mergeNextCommand = true;
          shouldMerge = shouldMerge && this.mergeNextCommand && (!/\s/.test(text) || /\s/.test(prev.args));
          this.mergeNextCommand = true;
        } else {
          shouldMerge = shouldMerge && mergeableCommands.indexOf(e2.command.name) !== -1;
        }
        if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2e3) {
          shouldMerge = false;
        }
        if (shouldMerge)
          this.session.mergeUndoDeltas = true;
        else if (mergeableCommands.indexOf(e2.command.name) !== -1)
          this.sequenceStartTime = Date.now();
      };
      this.setKeyboardHandler = function(keyboardHandler, cb2) {
        if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
          this.$keybindingId = keyboardHandler;
          var _self = this;
          config.loadModule(["keybinding", keyboardHandler], function(module3) {
            if (_self.$keybindingId == keyboardHandler)
              _self.keyBinding.setKeyboardHandler(module3 && module3.handler);
            cb2 && cb2();
          });
        } else {
          this.$keybindingId = null;
          this.keyBinding.setKeyboardHandler(keyboardHandler);
          cb2 && cb2();
        }
      };
      this.getKeyboardHandler = function() {
        return this.keyBinding.getKeyboardHandler();
      };
      this.setSession = function(session) {
        if (this.session == session)
          return;
        if (this.curOp)
          this.endOperation();
        this.curOp = {};
        var oldSession = this.session;
        if (oldSession) {
          this.session.off("change", this.$onDocumentChange);
          this.session.off("changeMode", this.$onChangeMode);
          this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
          this.session.off("changeTabSize", this.$onChangeTabSize);
          this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
          this.session.off("changeWrapMode", this.$onChangeWrapMode);
          this.session.off("changeFold", this.$onChangeFold);
          this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
          this.session.off("changeBackMarker", this.$onChangeBackMarker);
          this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
          this.session.off("changeAnnotation", this.$onChangeAnnotation);
          this.session.off("changeOverwrite", this.$onCursorChange);
          this.session.off("changeScrollTop", this.$onScrollTopChange);
          this.session.off("changeScrollLeft", this.$onScrollLeftChange);
          var selection = this.session.getSelection();
          selection.off("changeCursor", this.$onCursorChange);
          selection.off("changeSelection", this.$onSelectionChange);
        }
        this.session = session;
        if (session) {
          this.$onDocumentChange = this.onDocumentChange.bind(this);
          session.on("change", this.$onDocumentChange);
          this.renderer.setSession(session);
          this.$onChangeMode = this.onChangeMode.bind(this);
          session.on("changeMode", this.$onChangeMode);
          this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
          session.on("tokenizerUpdate", this.$onTokenizerUpdate);
          this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
          session.on("changeTabSize", this.$onChangeTabSize);
          this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
          session.on("changeWrapLimit", this.$onChangeWrapLimit);
          this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
          session.on("changeWrapMode", this.$onChangeWrapMode);
          this.$onChangeFold = this.onChangeFold.bind(this);
          session.on("changeFold", this.$onChangeFold);
          this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
          this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
          this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
          this.session.on("changeBackMarker", this.$onChangeBackMarker);
          this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
          this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
          this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
          this.session.on("changeAnnotation", this.$onChangeAnnotation);
          this.$onCursorChange = this.onCursorChange.bind(this);
          this.session.on("changeOverwrite", this.$onCursorChange);
          this.$onScrollTopChange = this.onScrollTopChange.bind(this);
          this.session.on("changeScrollTop", this.$onScrollTopChange);
          this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
          this.session.on("changeScrollLeft", this.$onScrollLeftChange);
          this.selection = session.getSelection();
          this.selection.on("changeCursor", this.$onCursorChange);
          this.$onSelectionChange = this.onSelectionChange.bind(this);
          this.selection.on("changeSelection", this.$onSelectionChange);
          this.onChangeMode();
          this.onCursorChange();
          this.onScrollTopChange();
          this.onScrollLeftChange();
          this.onSelectionChange();
          this.onChangeFrontMarker();
          this.onChangeBackMarker();
          this.onChangeBreakpoint();
          this.onChangeAnnotation();
          this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
          this.renderer.updateFull();
        } else {
          this.selection = null;
          this.renderer.setSession(session);
        }
        this._signal("changeSession", {
          session,
          oldSession
        });
        this.curOp = null;
        oldSession && oldSession._signal("changeEditor", {oldEditor: this});
        session && session._signal("changeEditor", {editor: this});
        if (session && session.bgTokenizer)
          session.bgTokenizer.scheduleStart();
      };
      this.getSession = function() {
        return this.session;
      };
      this.setValue = function(val, cursorPos) {
        this.session.doc.setValue(val);
        if (!cursorPos)
          this.selectAll();
        else if (cursorPos == 1)
          this.navigateFileEnd();
        else if (cursorPos == -1)
          this.navigateFileStart();
        return val;
      };
      this.getValue = function() {
        return this.session.getValue();
      };
      this.getSelection = function() {
        return this.selection;
      };
      this.resize = function(force) {
        this.renderer.onResize(force);
      };
      this.setTheme = function(theme, cb2) {
        this.renderer.setTheme(theme, cb2);
      };
      this.getTheme = function() {
        return this.renderer.getTheme();
      };
      this.setStyle = function(style) {
        this.renderer.setStyle(style);
      };
      this.unsetStyle = function(style) {
        this.renderer.unsetStyle(style);
      };
      this.getFontSize = function() {
        return this.getOption("fontSize") || dom.computedStyle(this.container).fontSize;
      };
      this.setFontSize = function(size) {
        this.setOption("fontSize", size);
      };
      this.$highlightBrackets = function() {
        if (this.$highlightPending) {
          return;
        }
        var self2 = this;
        this.$highlightPending = true;
        setTimeout(function() {
          self2.$highlightPending = false;
          var session = self2.session;
          if (!session || !session.bgTokenizer)
            return;
          if (session.$bracketHighlight) {
            session.$bracketHighlight.markerIds.forEach(function(id2) {
              session.removeMarker(id2);
            });
            session.$bracketHighlight = null;
          }
          var ranges = session.getMatchingBracketRanges(self2.getCursorPosition());
          if (!ranges && session.$mode.getMatching)
            ranges = session.$mode.getMatching(self2.session);
          if (!ranges)
            return;
          var markerType = "ace_bracket";
          if (!Array.isArray(ranges)) {
            ranges = [ranges];
          } else if (ranges.length == 1) {
            markerType = "ace_error_bracket";
          }
          if (ranges.length == 2) {
            if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
              ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
            else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
              ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
          }
          session.$bracketHighlight = {
            ranges,
            markerIds: ranges.map(function(range) {
              return session.addMarker(range, markerType, "text");
            })
          };
        }, 50);
      };
      this.$highlightTags = function() {
        if (this.$highlightTagPending)
          return;
        var self2 = this;
        this.$highlightTagPending = true;
        setTimeout(function() {
          self2.$highlightTagPending = false;
          var session = self2.session;
          if (!session || !session.bgTokenizer)
            return;
          var pos = self2.getCursorPosition();
          var iterator = new TokenIterator(self2.session, pos.row, pos.column);
          var token = iterator.getCurrentToken();
          if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
            session.removeMarker(session.$tagHighlight);
            session.$tagHighlight = null;
            return;
          }
          if (token.type.indexOf("tag-open") !== -1) {
            token = iterator.stepForward();
            if (!token)
              return;
          }
          var tag = token.value;
          var currentTag = token.value;
          var depth = 0;
          var prevToken = iterator.stepBackward();
          if (prevToken.value === "<") {
            do {
              prevToken = token;
              token = iterator.stepForward();
              if (token) {
                if (token.type.indexOf("tag-name") !== -1) {
                  currentTag = token.value;
                  if (tag === currentTag) {
                    if (prevToken.value === "<") {
                      depth++;
                    } else if (prevToken.value === "</") {
                      depth--;
                    }
                  }
                } else if (tag === currentTag && token.value === "/>") {
                  depth--;
                }
              }
            } while (token && depth >= 0);
          } else {
            do {
              token = prevToken;
              prevToken = iterator.stepBackward();
              if (token) {
                if (token.type.indexOf("tag-name") !== -1) {
                  if (tag === token.value) {
                    if (prevToken.value === "<") {
                      depth++;
                    } else if (prevToken.value === "</") {
                      depth--;
                    }
                  }
                } else if (token.value === "/>") {
                  var stepCount = 0;
                  var tmpToken = prevToken;
                  while (tmpToken) {
                    if (tmpToken.type.indexOf("tag-name") !== -1 && tmpToken.value === tag) {
                      depth--;
                      break;
                    } else if (tmpToken.value === "<") {
                      break;
                    }
                    tmpToken = iterator.stepBackward();
                    stepCount++;
                  }
                  for (var i = 0; i < stepCount; i++) {
                    iterator.stepForward();
                  }
                }
              }
            } while (prevToken && depth <= 0);
            iterator.stepForward();
          }
          if (!token) {
            session.removeMarker(session.$tagHighlight);
            session.$tagHighlight = null;
            return;
          }
          var row = iterator.getCurrentTokenRow();
          var column = iterator.getCurrentTokenColumn();
          var range = new Range(row, column, row, column + token.value.length);
          var sbm = session.$backMarkers[session.$tagHighlight];
          if (session.$tagHighlight && sbm != void 0 && range.compareRange(sbm.range) !== 0) {
            session.removeMarker(session.$tagHighlight);
            session.$tagHighlight = null;
          }
          if (!session.$tagHighlight)
            session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
        }, 50);
      };
      this.focus = function() {
        var _self = this;
        setTimeout(function() {
          if (!_self.isFocused())
            _self.textInput.focus();
        });
        this.textInput.focus();
      };
      this.isFocused = function() {
        return this.textInput.isFocused();
      };
      this.blur = function() {
        this.textInput.blur();
      };
      this.onFocus = function(e2) {
        if (this.$isFocused)
          return;
        this.$isFocused = true;
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this._emit("focus", e2);
      };
      this.onBlur = function(e2) {
        if (!this.$isFocused)
          return;
        this.$isFocused = false;
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this._emit("blur", e2);
      };
      this.$cursorChange = function() {
        this.renderer.updateCursor();
        this.$highlightBrackets();
        this.$highlightTags();
        this.$updateHighlightActiveLine();
      };
      this.onDocumentChange = function(delta) {
        var wrap = this.session.$useWrapMode;
        var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
        this.renderer.updateLines(delta.start.row, lastRow, wrap);
        this._signal("change", delta);
        this.$cursorChange();
      };
      this.onTokenizerUpdate = function(e2) {
        var rows = e2.data;
        this.renderer.updateLines(rows.first, rows.last);
      };
      this.onScrollTopChange = function() {
        this.renderer.scrollToY(this.session.getScrollTop());
      };
      this.onScrollLeftChange = function() {
        this.renderer.scrollToX(this.session.getScrollLeft());
      };
      this.onCursorChange = function() {
        this.$cursorChange();
        this._signal("changeSelection");
      };
      this.$updateHighlightActiveLine = function() {
        var session = this.getSession();
        var highlight;
        if (this.$highlightActiveLine) {
          if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
            highlight = this.getCursorPosition();
          if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
            highlight = false;
          if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
            highlight = false;
        }
        if (session.$highlightLineMarker && !highlight) {
          session.removeMarker(session.$highlightLineMarker.id);
          session.$highlightLineMarker = null;
        } else if (!session.$highlightLineMarker && highlight) {
          var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
          range.id = session.addMarker(range, "ace_active-line", "screenLine");
          session.$highlightLineMarker = range;
        } else if (highlight) {
          session.$highlightLineMarker.start.row = highlight.row;
          session.$highlightLineMarker.end.row = highlight.row;
          session.$highlightLineMarker.start.column = highlight.column;
          session._signal("changeBackMarker");
        }
      };
      this.onSelectionChange = function(e2) {
        var session = this.session;
        if (session.$selectionMarker) {
          session.removeMarker(session.$selectionMarker);
        }
        session.$selectionMarker = null;
        if (!this.selection.isEmpty()) {
          var range = this.selection.getRange();
          var style = this.getSelectionStyle();
          session.$selectionMarker = session.addMarker(range, "ace_selection", style);
        } else {
          this.$updateHighlightActiveLine();
        }
        var re2 = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
        this.session.highlight(re2);
        this._signal("changeSelection");
      };
      this.$getSelectionHighLightRegexp = function() {
        var session = this.session;
        var selection = this.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
          return;
        var startColumn = selection.start.column;
        var endColumn = selection.end.column;
        var line = session.getLine(selection.start.row);
        var needle = line.substring(startColumn, endColumn);
        if (needle.length > 5e3 || !/[\w\d]/.test(needle))
          return;
        var re2 = this.$search.$assembleRegExp({
          wholeWord: true,
          caseSensitive: true,
          needle
        });
        var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
        if (!re2.test(wordWithBoundary))
          return;
        return re2;
      };
      this.onChangeFrontMarker = function() {
        this.renderer.updateFrontMarkers();
      };
      this.onChangeBackMarker = function() {
        this.renderer.updateBackMarkers();
      };
      this.onChangeBreakpoint = function() {
        this.renderer.updateBreakpoints();
      };
      this.onChangeAnnotation = function() {
        this.renderer.setAnnotations(this.session.getAnnotations());
      };
      this.onChangeMode = function(e2) {
        this.renderer.updateText();
        this._emit("changeMode", e2);
      };
      this.onChangeWrapLimit = function() {
        this.renderer.updateFull();
      };
      this.onChangeWrapMode = function() {
        this.renderer.onResize(true);
      };
      this.onChangeFold = function() {
        this.$updateHighlightActiveLine();
        this.renderer.updateFull();
      };
      this.getSelectedText = function() {
        return this.session.getTextRange(this.getSelectionRange());
      };
      this.getCopyText = function() {
        var text = this.getSelectedText();
        var nl = this.session.doc.getNewLineCharacter();
        var copyLine = false;
        if (!text && this.$copyWithEmptySelection) {
          copyLine = true;
          var ranges = this.selection.getAllRanges();
          for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (i && ranges[i - 1].start.row == range.start.row)
              continue;
            text += this.session.getLine(range.start.row) + nl;
          }
        }
        var e2 = {text};
        this._signal("copy", e2);
        clipboard.lineMode = copyLine ? e2.text : "";
        return e2.text;
      };
      this.onCopy = function() {
        this.commands.exec("copy", this);
      };
      this.onCut = function() {
        this.commands.exec("cut", this);
      };
      this.onPaste = function(text, event) {
        var e2 = {text, event};
        this.commands.exec("paste", this, e2);
      };
      this.$handlePaste = function(e2) {
        if (typeof e2 == "string")
          e2 = {text: e2};
        this._signal("paste", e2);
        var text = e2.text;
        var lineMode = text == clipboard.lineMode;
        var session = this.session;
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
          if (lineMode)
            session.insert({row: this.selection.lead.row, column: 0}, text);
          else
            this.insert(text);
        } else if (lineMode) {
          this.selection.rangeList.ranges.forEach(function(range2) {
            session.insert({row: range2.start.row, column: 0}, text);
          });
        } else {
          var lines = text.split(/\r\n|\r|\n/);
          var ranges = this.selection.rangeList.ranges;
          var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
          if (lines.length != ranges.length || isFullLine)
            return this.commands.exec("insertstring", this, text);
          for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.isEmpty())
              session.remove(range);
            session.insert(range.start, lines[i]);
          }
        }
      };
      this.execCommand = function(command, args) {
        return this.commands.exec(command, this, args);
      };
      this.insert = function(text, pasted) {
        var session = this.session;
        var mode = session.getMode();
        var cursor = this.getCursorPosition();
        if (this.getBehavioursEnabled() && !pasted) {
          var transform = mode.transformAction(session.getState(cursor.row), "insertion", this, session, text);
          if (transform) {
            if (text !== transform.text) {
              if (!this.inVirtualSelectionMode) {
                this.session.mergeUndoDeltas = false;
                this.mergeNextCommand = false;
              }
            }
            text = transform.text;
          }
        }
        if (text == "	")
          text = this.session.getTabString();
        if (!this.selection.isEmpty()) {
          var range = this.getSelectionRange();
          cursor = this.session.remove(range);
          this.clearSelection();
        } else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
          var range = new Range.fromPoints(cursor, cursor);
          range.end.column += text.length;
          this.session.remove(range);
        }
        if (text == "\n" || text == "\r\n") {
          var line = session.getLine(cursor.row);
          if (cursor.column > line.search(/\S|$/)) {
            var d2 = line.substr(cursor.column).search(/\S|$/);
            session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d2);
          }
        }
        this.clearSelection();
        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var line = session.getLine(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, line, text);
        session.insert(cursor, text);
        if (transform && transform.selection) {
          if (transform.selection.length == 2) {
            this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
          } else {
            this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
          }
        }
        if (this.$enableAutoIndent) {
          if (session.getDocument().isNewLine(text)) {
            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
            session.insert({row: cursor.row + 1, column: 0}, lineIndent);
          }
          if (shouldOutdent)
            mode.autoOutdent(lineState, session, cursor.row);
        }
      };
      this.autoIndent = function() {
        var session = this.session;
        var mode = session.getMode();
        var startRow, endRow;
        if (this.selection.isEmpty()) {
          startRow = 0;
          endRow = session.doc.getLength() - 1;
        } else {
          var selectedRange = this.getSelectionRange();
          startRow = selectedRange.start.row;
          endRow = selectedRange.end.row;
        }
        var prevLineState = "";
        var prevLine = "";
        var lineIndent = "";
        var line, currIndent, range;
        var tab = session.getTabString();
        for (var row = startRow; row <= endRow; row++) {
          if (row > 0) {
            prevLineState = session.getState(row - 1);
            prevLine = session.getLine(row - 1);
            lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
          }
          line = session.getLine(row);
          currIndent = mode.$getIndent(line);
          if (lineIndent !== currIndent) {
            if (currIndent.length > 0) {
              range = new Range(row, 0, row, currIndent.length);
              session.remove(range);
            }
            if (lineIndent.length > 0) {
              session.insert({row, column: 0}, lineIndent);
            }
          }
          mode.autoOutdent(prevLineState, session, row);
        }
      };
      this.onTextInput = function(text, composition) {
        if (!composition)
          return this.keyBinding.onTextInput(text);
        this.startOperation({command: {name: "insertstring"}});
        var applyComposition = this.applyComposition.bind(this, text, composition);
        if (this.selection.rangeCount)
          this.forEachSelection(applyComposition);
        else
          applyComposition();
        this.endOperation();
      };
      this.applyComposition = function(text, composition) {
        if (composition.extendLeft || composition.extendRight) {
          var r2 = this.selection.getRange();
          r2.start.column -= composition.extendLeft;
          r2.end.column += composition.extendRight;
          if (r2.start.column < 0) {
            r2.start.row--;
            r2.start.column += this.session.getLine(r2.start.row).length + 1;
          }
          this.selection.setRange(r2);
          if (!text && !r2.isEmpty())
            this.remove();
        }
        if (text || !this.selection.isEmpty())
          this.insert(text, true);
        if (composition.restoreStart || composition.restoreEnd) {
          var r2 = this.selection.getRange();
          r2.start.column -= composition.restoreStart;
          r2.end.column -= composition.restoreEnd;
          this.selection.setRange(r2);
        }
      };
      this.onCommandKey = function(e2, hashId, keyCode) {
        return this.keyBinding.onCommandKey(e2, hashId, keyCode);
      };
      this.setOverwrite = function(overwrite) {
        this.session.setOverwrite(overwrite);
      };
      this.getOverwrite = function() {
        return this.session.getOverwrite();
      };
      this.toggleOverwrite = function() {
        this.session.toggleOverwrite();
      };
      this.setScrollSpeed = function(speed) {
        this.setOption("scrollSpeed", speed);
      };
      this.getScrollSpeed = function() {
        return this.getOption("scrollSpeed");
      };
      this.setDragDelay = function(dragDelay) {
        this.setOption("dragDelay", dragDelay);
      };
      this.getDragDelay = function() {
        return this.getOption("dragDelay");
      };
      this.setSelectionStyle = function(val) {
        this.setOption("selectionStyle", val);
      };
      this.getSelectionStyle = function() {
        return this.getOption("selectionStyle");
      };
      this.setHighlightActiveLine = function(shouldHighlight) {
        this.setOption("highlightActiveLine", shouldHighlight);
      };
      this.getHighlightActiveLine = function() {
        return this.getOption("highlightActiveLine");
      };
      this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
      };
      this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
      };
      this.setHighlightSelectedWord = function(shouldHighlight) {
        this.setOption("highlightSelectedWord", shouldHighlight);
      };
      this.getHighlightSelectedWord = function() {
        return this.$highlightSelectedWord;
      };
      this.setAnimatedScroll = function(shouldAnimate) {
        this.renderer.setAnimatedScroll(shouldAnimate);
      };
      this.getAnimatedScroll = function() {
        return this.renderer.getAnimatedScroll();
      };
      this.setShowInvisibles = function(showInvisibles) {
        this.renderer.setShowInvisibles(showInvisibles);
      };
      this.getShowInvisibles = function() {
        return this.renderer.getShowInvisibles();
      };
      this.setDisplayIndentGuides = function(display) {
        this.renderer.setDisplayIndentGuides(display);
      };
      this.getDisplayIndentGuides = function() {
        return this.renderer.getDisplayIndentGuides();
      };
      this.setShowPrintMargin = function(showPrintMargin) {
        this.renderer.setShowPrintMargin(showPrintMargin);
      };
      this.getShowPrintMargin = function() {
        return this.renderer.getShowPrintMargin();
      };
      this.setPrintMarginColumn = function(showPrintMargin) {
        this.renderer.setPrintMarginColumn(showPrintMargin);
      };
      this.getPrintMarginColumn = function() {
        return this.renderer.getPrintMarginColumn();
      };
      this.setReadOnly = function(readOnly) {
        this.setOption("readOnly", readOnly);
      };
      this.getReadOnly = function() {
        return this.getOption("readOnly");
      };
      this.setBehavioursEnabled = function(enabled) {
        this.setOption("behavioursEnabled", enabled);
      };
      this.getBehavioursEnabled = function() {
        return this.getOption("behavioursEnabled");
      };
      this.setWrapBehavioursEnabled = function(enabled) {
        this.setOption("wrapBehavioursEnabled", enabled);
      };
      this.getWrapBehavioursEnabled = function() {
        return this.getOption("wrapBehavioursEnabled");
      };
      this.setShowFoldWidgets = function(show) {
        this.setOption("showFoldWidgets", show);
      };
      this.getShowFoldWidgets = function() {
        return this.getOption("showFoldWidgets");
      };
      this.setFadeFoldWidgets = function(fade) {
        this.setOption("fadeFoldWidgets", fade);
      };
      this.getFadeFoldWidgets = function() {
        return this.getOption("fadeFoldWidgets");
      };
      this.remove = function(dir) {
        if (this.selection.isEmpty()) {
          if (dir == "left")
            this.selection.selectLeft();
          else
            this.selection.selectRight();
        }
        var range = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
          var session = this.session;
          var state = session.getState(range.start.row);
          var new_range = session.getMode().transformAction(state, "deletion", this, session, range);
          if (range.end.column === 0) {
            var text = session.getTextRange(range);
            if (text[text.length - 1] == "\n") {
              var line = session.getLine(range.end.row);
              if (/^\s+$/.test(line)) {
                range.end.column = line.length;
              }
            }
          }
          if (new_range)
            range = new_range;
        }
        this.session.remove(range);
        this.clearSelection();
      };
      this.removeWordRight = function() {
        if (this.selection.isEmpty())
          this.selection.selectWordRight();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
      };
      this.removeWordLeft = function() {
        if (this.selection.isEmpty())
          this.selection.selectWordLeft();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
      };
      this.removeToLineStart = function() {
        if (this.selection.isEmpty())
          this.selection.selectLineStart();
        if (this.selection.isEmpty())
          this.selection.selectLeft();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
      };
      this.removeToLineEnd = function() {
        if (this.selection.isEmpty())
          this.selection.selectLineEnd();
        var range = this.getSelectionRange();
        if (range.start.column == range.end.column && range.start.row == range.end.row) {
          range.end.column = 0;
          range.end.row++;
        }
        this.session.remove(range);
        this.clearSelection();
      };
      this.splitLine = function() {
        if (!this.selection.isEmpty()) {
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        }
        var cursor = this.getCursorPosition();
        this.insert("\n");
        this.moveCursorToPosition(cursor);
      };
      this.transposeLetters = function() {
        if (!this.selection.isEmpty()) {
          return;
        }
        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
          return;
        var line = this.session.getLine(cursor.row);
        var swap, range;
        if (column < line.length) {
          swap = line.charAt(column) + line.charAt(column - 1);
          range = new Range(cursor.row, column - 1, cursor.row, column + 1);
        } else {
          swap = line.charAt(column - 1) + line.charAt(column - 2);
          range = new Range(cursor.row, column - 2, cursor.row, column);
        }
        this.session.replace(range, swap);
        this.session.selection.moveToPosition(range.end);
      };
      this.toLowerCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
          this.selection.selectWord();
        }
        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
      };
      this.toUpperCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
          this.selection.selectWord();
        }
        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
      };
      this.indent = function() {
        var session = this.session;
        var range = this.getSelectionRange();
        if (range.start.row < range.end.row) {
          var rows = this.$getSelectedRows();
          session.indentRows(rows.first, rows.last, "	");
          return;
        } else if (range.start.column < range.end.column) {
          var text = session.getTextRange(range);
          if (!/^\s+$/.test(text)) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "	");
            return;
          }
        }
        var line = session.getLine(range.start.row);
        var position = range.start;
        var size = session.getTabSize();
        var column = session.documentToScreenColumn(position.row, position.column);
        if (this.session.getUseSoftTabs()) {
          var count = size - column % size;
          var indentString2 = lang.stringRepeat(" ", count);
        } else {
          var count = column % size;
          while (line[range.start.column - 1] == " " && count) {
            range.start.column--;
            count--;
          }
          this.selection.setSelectionRange(range);
          indentString2 = "	";
        }
        return this.insert(indentString2);
      };
      this.blockIndent = function() {
        var rows = this.$getSelectedRows();
        this.session.indentRows(rows.first, rows.last, "	");
      };
      this.blockOutdent = function() {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
      };
      this.sortLines = function() {
        var rows = this.$getSelectedRows();
        var session = this.session;
        var lines = [];
        for (var i = rows.first; i <= rows.last; i++)
          lines.push(session.getLine(i));
        lines.sort(function(a, b2) {
          if (a.toLowerCase() < b2.toLowerCase())
            return -1;
          if (a.toLowerCase() > b2.toLowerCase())
            return 1;
          return 0;
        });
        var deleteRange = new Range(0, 0, 0, 0);
        for (var i = rows.first; i <= rows.last; i++) {
          var line = session.getLine(i);
          deleteRange.start.row = i;
          deleteRange.end.row = i;
          deleteRange.end.column = line.length;
          session.replace(deleteRange, lines[i - rows.first]);
        }
      };
      this.toggleCommentLines = function() {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
      };
      this.toggleBlockComment = function() {
        var cursor = this.getCursorPosition();
        var state = this.session.getState(cursor.row);
        var range = this.getSelectionRange();
        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
      };
      this.getNumberAt = function(row, column) {
        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
        _numberRx.lastIndex = 0;
        var s = this.session.getLine(row);
        while (_numberRx.lastIndex < column) {
          var m2 = _numberRx.exec(s);
          if (m2.index <= column && m2.index + m2[0].length >= column) {
            var number = {
              value: m2[0],
              start: m2.index,
              end: m2.index + m2[0].length
            };
            return number;
          }
        }
        return null;
      };
      this.modifyNumber = function(amount) {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        var charRange = new Range(row, column - 1, row, column);
        var c2 = this.session.getTextRange(charRange);
        if (!isNaN(parseFloat(c2)) && isFinite(c2)) {
          var nr = this.getNumberAt(row, column);
          if (nr) {
            var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
            var decimals = nr.start + nr.value.length - fp;
            var t2 = parseFloat(nr.value);
            t2 *= Math.pow(10, decimals);
            if (fp !== nr.end && column < fp) {
              amount *= Math.pow(10, nr.end - column - 1);
            } else {
              amount *= Math.pow(10, nr.end - column);
            }
            t2 += amount;
            t2 /= Math.pow(10, decimals);
            var nnr = t2.toFixed(decimals);
            var replaceRange = new Range(row, nr.start, row, nr.end);
            this.session.replace(replaceRange, nnr);
            this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
          }
        } else {
          this.toggleWord();
        }
      };
      this.$toggleWordPairs = [
        ["first", "last"],
        ["true", "false"],
        ["yes", "no"],
        ["width", "height"],
        ["top", "bottom"],
        ["right", "left"],
        ["on", "off"],
        ["x", "y"],
        ["get", "set"],
        ["max", "min"],
        ["horizontal", "vertical"],
        ["show", "hide"],
        ["add", "remove"],
        ["up", "down"],
        ["before", "after"],
        ["even", "odd"],
        ["in", "out"],
        ["inside", "outside"],
        ["next", "previous"],
        ["increase", "decrease"],
        ["attach", "detach"],
        ["&&", "||"],
        ["==", "!="]
      ];
      this.toggleWord = function() {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        this.selection.selectWord();
        var currentState = this.getSelectedText();
        var currWordStart = this.selection.getWordRange().start.column;
        var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, "$1 ").split(/\s/);
        var delta = column - currWordStart - 1;
        if (delta < 0)
          delta = 0;
        var curLength = 0, itLength = 0;
        var that = this;
        if (currentState.match(/[A-Za-z0-9_]+/)) {
          wordParts.forEach(function(item2, i2) {
            itLength = curLength + item2.length;
            if (delta >= curLength && delta <= itLength) {
              currentState = item2;
              that.selection.clearSelection();
              that.moveCursorTo(row, curLength + currWordStart);
              that.selection.selectTo(row, itLength + currWordStart);
            }
            curLength = itLength;
          });
        }
        var wordPairs = this.$toggleWordPairs;
        var reg;
        for (var i = 0; i < wordPairs.length; i++) {
          var item = wordPairs[i];
          for (var j = 0; j <= 1; j++) {
            var negate = +!j;
            var firstCondition = currentState.match(new RegExp("^\\s?_?(" + lang.escapeRegExp(item[j]) + ")\\s?$", "i"));
            if (firstCondition) {
              var secondCondition = currentState.match(new RegExp("([_]|^|\\s)(" + lang.escapeRegExp(firstCondition[1]) + ")($|\\s)", "g"));
              if (secondCondition) {
                reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), "i"), function(result) {
                  var res = item[negate];
                  if (result.toUpperCase() == result) {
                    res = res.toUpperCase();
                  } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                    res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
                  }
                  return res;
                });
                this.insert(reg);
                reg = "";
              }
            }
          }
        }
      };
      this.removeLines = function() {
        var rows = this.$getSelectedRows();
        this.session.removeFullLines(rows.first, rows.last);
        this.clearSelection();
      };
      this.duplicateSelection = function() {
        var sel = this.selection;
        var doc = this.session;
        var range = sel.getRange();
        var reverse = sel.isBackwards();
        if (range.isEmpty()) {
          var row = range.start.row;
          doc.duplicateLines(row, row);
        } else {
          var point = reverse ? range.start : range.end;
          var endPoint = doc.insert(point, doc.getTextRange(range), false);
          range.start = point;
          range.end = endPoint;
          sel.setSelectionRange(range, reverse);
        }
      };
      this.moveLinesDown = function() {
        this.$moveLines(1, false);
      };
      this.moveLinesUp = function() {
        this.$moveLines(-1, false);
      };
      this.moveText = function(range, toPosition, copy) {
        return this.session.moveText(range, toPosition, copy);
      };
      this.copyLinesUp = function() {
        this.$moveLines(-1, true);
      };
      this.copyLinesDown = function() {
        this.$moveLines(1, true);
      };
      this.$moveLines = function(dir, copy) {
        var rows, moved;
        var selection = this.selection;
        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
          var range = selection.toOrientedRange();
          rows = this.$getSelectedRows(range);
          moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
          if (copy && dir == -1)
            moved = 0;
          range.moveBy(moved, 0);
          selection.fromOrientedRange(range);
        } else {
          var ranges = selection.rangeList.ranges;
          selection.rangeList.detach(this.session);
          this.inVirtualSelectionMode = true;
          var diff2 = 0;
          var totalDiff = 0;
          var l2 = ranges.length;
          for (var i = 0; i < l2; i++) {
            var rangeIndex = i;
            ranges[i].moveBy(diff2, 0);
            rows = this.$getSelectedRows(ranges[i]);
            var first = rows.first;
            var last = rows.last;
            while (++i < l2) {
              if (totalDiff)
                ranges[i].moveBy(totalDiff, 0);
              var subRows = this.$getSelectedRows(ranges[i]);
              if (copy && subRows.first != last)
                break;
              else if (!copy && subRows.first > last + 1)
                break;
              last = subRows.last;
            }
            i--;
            diff2 = this.session.$moveLines(first, last, copy ? 0 : dir);
            if (copy && dir == -1)
              rangeIndex = i + 1;
            while (rangeIndex <= i) {
              ranges[rangeIndex].moveBy(diff2, 0);
              rangeIndex++;
            }
            if (!copy)
              diff2 = 0;
            totalDiff += diff2;
          }
          selection.fromOrientedRange(selection.ranges[0]);
          selection.rangeList.attach(this.session);
          this.inVirtualSelectionMode = false;
        }
      };
      this.$getSelectedRows = function(range) {
        range = (range || this.getSelectionRange()).collapseRows();
        return {
          first: this.session.getRowFoldStart(range.start.row),
          last: this.session.getRowFoldEnd(range.end.row)
        };
      };
      this.onCompositionStart = function(compositionState) {
        this.renderer.showComposition(compositionState);
      };
      this.onCompositionUpdate = function(text) {
        this.renderer.setCompositionText(text);
      };
      this.onCompositionEnd = function() {
        this.renderer.hideComposition();
      };
      this.getFirstVisibleRow = function() {
        return this.renderer.getFirstVisibleRow();
      };
      this.getLastVisibleRow = function() {
        return this.renderer.getLastVisibleRow();
      };
      this.isRowVisible = function(row) {
        return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
      };
      this.isRowFullyVisible = function(row) {
        return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
      };
      this.$getVisibleRowCount = function() {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
      };
      this.$moveByPage = function(dir, select) {
        var renderer = this.renderer;
        var config2 = this.renderer.layerConfig;
        var rows = dir * Math.floor(config2.height / config2.lineHeight);
        if (select === true) {
          this.selection.$moveSelection(function() {
            this.moveCursorBy(rows, 0);
          });
        } else if (select === false) {
          this.selection.moveCursorBy(rows, 0);
          this.selection.clearSelection();
        }
        var scrollTop = renderer.scrollTop;
        renderer.scrollBy(0, rows * config2.lineHeight);
        if (select != null)
          renderer.scrollCursorIntoView(null, 0.5);
        renderer.animateScrolling(scrollTop);
      };
      this.selectPageDown = function() {
        this.$moveByPage(1, true);
      };
      this.selectPageUp = function() {
        this.$moveByPage(-1, true);
      };
      this.gotoPageDown = function() {
        this.$moveByPage(1, false);
      };
      this.gotoPageUp = function() {
        this.$moveByPage(-1, false);
      };
      this.scrollPageDown = function() {
        this.$moveByPage(1);
      };
      this.scrollPageUp = function() {
        this.$moveByPage(-1);
      };
      this.scrollToRow = function(row) {
        this.renderer.scrollToRow(row);
      };
      this.scrollToLine = function(line, center, animate, callback) {
        this.renderer.scrollToLine(line, center, animate, callback);
      };
      this.centerSelection = function() {
        var range = this.getSelectionRange();
        var pos = {
          row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
          column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
        this.renderer.alignCursor(pos, 0.5);
      };
      this.getCursorPosition = function() {
        return this.selection.getCursor();
      };
      this.getCursorPositionScreen = function() {
        return this.session.documentToScreenPosition(this.getCursorPosition());
      };
      this.getSelectionRange = function() {
        return this.selection.getRange();
      };
      this.selectAll = function() {
        this.selection.selectAll();
      };
      this.clearSelection = function() {
        this.selection.clearSelection();
      };
      this.moveCursorTo = function(row, column) {
        this.selection.moveCursorTo(row, column);
      };
      this.moveCursorToPosition = function(pos) {
        this.selection.moveCursorToPosition(pos);
      };
      this.jumpToMatching = function(select, expand) {
        var cursor = this.getCursorPosition();
        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
        var prevToken = iterator.getCurrentToken();
        var token = prevToken || iterator.stepForward();
        if (!token)
          return;
        var matchType;
        var found = false;
        var depth = {};
        var i = cursor.column - token.start;
        var bracketType;
        var brackets = {
          ")": "(",
          "(": "(",
          "]": "[",
          "[": "[",
          "{": "{",
          "}": "{"
        };
        do {
          if (token.value.match(/[{}()\[\]]/g)) {
            for (; i < token.value.length && !found; i++) {
              if (!brackets[token.value[i]]) {
                continue;
              }
              bracketType = brackets[token.value[i]] + "." + token.type.replace("rparen", "lparen");
              if (isNaN(depth[bracketType])) {
                depth[bracketType] = 0;
              }
              switch (token.value[i]) {
                case "(":
                case "[":
                case "{":
                  depth[bracketType]++;
                  break;
                case ")":
                case "]":
                case "}":
                  depth[bracketType]--;
                  if (depth[bracketType] === -1) {
                    matchType = "bracket";
                    found = true;
                  }
                  break;
              }
            }
          } else if (token.type.indexOf("tag-name") !== -1) {
            if (isNaN(depth[token.value])) {
              depth[token.value] = 0;
            }
            if (prevToken.value === "<") {
              depth[token.value]++;
            } else if (prevToken.value === "</") {
              depth[token.value]--;
            }
            if (depth[token.value] === -1) {
              matchType = "tag";
              found = true;
            }
          }
          if (!found) {
            prevToken = token;
            token = iterator.stepForward();
            i = 0;
          }
        } while (token && !found);
        if (!matchType)
          return;
        var range, pos;
        if (matchType === "bracket") {
          range = this.session.getBracketRange(cursor);
          if (!range) {
            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
            pos = range.start;
            if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
              range = this.session.getBracketRange(pos);
          }
        } else if (matchType === "tag") {
          if (token && token.type.indexOf("tag-name") !== -1)
            var tag = token.value;
          else
            return;
          range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
          if (range.compare(cursor.row, cursor.column) === 0) {
            found = false;
            do {
              token = prevToken;
              prevToken = iterator.stepBackward();
              if (prevToken) {
                if (prevToken.type.indexOf("tag-close") !== -1) {
                  range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                }
                if (token.value === tag && token.type.indexOf("tag-name") !== -1) {
                  if (prevToken.value === "<") {
                    depth[tag]++;
                  } else if (prevToken.value === "</") {
                    depth[tag]--;
                  }
                  if (depth[tag] === 0)
                    found = true;
                }
              }
            } while (prevToken && !found);
          }
          if (token && token.type.indexOf("tag-name")) {
            pos = range.start;
            if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
              pos = range.end;
          }
        }
        pos = range && range.cursor || pos;
        if (pos) {
          if (select) {
            if (range && expand) {
              this.selection.setRange(range);
            } else if (range && range.isEqual(this.getSelectionRange())) {
              this.clearSelection();
            } else {
              this.selection.selectTo(pos.row, pos.column);
            }
          } else {
            this.selection.moveTo(pos.row, pos.column);
          }
        }
      };
      this.gotoLine = function(lineNumber, column, animate) {
        this.selection.clearSelection();
        this.session.unfold({row: lineNumber - 1, column: column || 0});
        this.exitMultiSelectMode && this.exitMultiSelectMode();
        this.moveCursorTo(lineNumber - 1, column || 0);
        if (!this.isRowFullyVisible(lineNumber - 1))
          this.scrollToLine(lineNumber - 1, true, animate);
      };
      this.navigateTo = function(row, column) {
        this.selection.moveTo(row, column);
      };
      this.navigateUp = function(times) {
        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
          var selectionStart = this.selection.anchor.getPosition();
          return this.moveCursorToPosition(selectionStart);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(-times || -1, 0);
      };
      this.navigateDown = function(times) {
        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
          var selectionEnd = this.selection.anchor.getPosition();
          return this.moveCursorToPosition(selectionEnd);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(times || 1, 0);
      };
      this.navigateLeft = function(times) {
        if (!this.selection.isEmpty()) {
          var selectionStart = this.getSelectionRange().start;
          this.moveCursorToPosition(selectionStart);
        } else {
          times = times || 1;
          while (times--) {
            this.selection.moveCursorLeft();
          }
        }
        this.clearSelection();
      };
      this.navigateRight = function(times) {
        if (!this.selection.isEmpty()) {
          var selectionEnd = this.getSelectionRange().end;
          this.moveCursorToPosition(selectionEnd);
        } else {
          times = times || 1;
          while (times--) {
            this.selection.moveCursorRight();
          }
        }
        this.clearSelection();
      };
      this.navigateLineStart = function() {
        this.selection.moveCursorLineStart();
        this.clearSelection();
      };
      this.navigateLineEnd = function() {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
      };
      this.navigateFileEnd = function() {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
      };
      this.navigateFileStart = function() {
        this.selection.moveCursorFileStart();
        this.clearSelection();
      };
      this.navigateWordRight = function() {
        this.selection.moveCursorWordRight();
        this.clearSelection();
      };
      this.navigateWordLeft = function() {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
      };
      this.replace = function(replacement, options) {
        if (options)
          this.$search.set(options);
        var range = this.$search.find(this.session);
        var replaced = 0;
        if (!range)
          return replaced;
        if (this.$tryReplace(range, replacement)) {
          replaced = 1;
        }
        this.selection.setSelectionRange(range);
        this.renderer.scrollSelectionIntoView(range.start, range.end);
        return replaced;
      };
      this.replaceAll = function(replacement, options) {
        if (options) {
          this.$search.set(options);
        }
        var ranges = this.$search.findAll(this.session);
        var replaced = 0;
        if (!ranges.length)
          return replaced;
        var selection = this.getSelectionRange();
        this.selection.moveTo(0, 0);
        for (var i = ranges.length - 1; i >= 0; --i) {
          if (this.$tryReplace(ranges[i], replacement)) {
            replaced++;
          }
        }
        this.selection.setSelectionRange(selection);
        return replaced;
      };
      this.$tryReplace = function(range, replacement) {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
          range.end = this.session.replace(range, replacement);
          return range;
        } else {
          return null;
        }
      };
      this.getLastSearchOptions = function() {
        return this.$search.getOptions();
      };
      this.find = function(needle, options, animate) {
        if (!options)
          options = {};
        if (typeof needle == "string" || needle instanceof RegExp)
          options.needle = needle;
        else if (typeof needle == "object")
          oop.mixin(options, needle);
        var range = this.selection.getRange();
        if (options.needle == null) {
          needle = this.session.getTextRange(range) || this.$search.$options.needle;
          if (!needle) {
            range = this.session.getWordRange(range.start.row, range.start.column);
            needle = this.session.getTextRange(range);
          }
          this.$search.set({needle});
        }
        this.$search.set(options);
        if (!options.start)
          this.$search.set({start: range});
        var newRange = this.$search.find(this.session);
        if (options.preventScroll)
          return newRange;
        if (newRange) {
          this.revealRange(newRange, animate);
          return newRange;
        }
        if (options.backwards)
          range.start = range.end;
        else
          range.end = range.start;
        this.selection.setRange(range);
      };
      this.findNext = function(options, animate) {
        this.find({skipCurrent: true, backwards: false}, options, animate);
      };
      this.findPrevious = function(options, animate) {
        this.find(options, {skipCurrent: true, backwards: true}, animate);
      };
      this.revealRange = function(range, animate) {
        this.session.unfold(range);
        this.selection.setSelectionRange(range);
        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate !== false)
          this.renderer.animateScrolling(scrollTop);
      };
      this.undo = function() {
        this.session.getUndoManager().undo(this.session);
        this.renderer.scrollCursorIntoView(null, 0.5);
      };
      this.redo = function() {
        this.session.getUndoManager().redo(this.session);
        this.renderer.scrollCursorIntoView(null, 0.5);
      };
      this.destroy = function() {
        if (this.$toDestroy) {
          this.$toDestroy.forEach(function(el) {
            el.destroy();
          });
          this.$toDestroy = null;
        }
        if (this.$mouseHandler)
          this.$mouseHandler.destroy();
        this.renderer.destroy();
        this._signal("destroy", this);
        if (this.session)
          this.session.destroy();
        if (this._$emitInputEvent)
          this._$emitInputEvent.cancel();
        this.removeAllListeners();
      };
      this.setAutoScrollEditorIntoView = function(enable) {
        if (!enable)
          return;
        var rect;
        var self2 = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
          this.$scrollAnchor = document.createElement("div");
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = "position:absolute";
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on("changeSelection", function() {
          shouldScroll = true;
        });
        var onBeforeRender = this.renderer.on("beforeRender", function() {
          if (shouldScroll)
            rect = self2.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on("afterRender", function() {
          if (shouldScroll && rect && (self2.isFocused() || self2.searchBox && self2.searchBox.isFocused())) {
            var renderer = self2.renderer;
            var pos = renderer.$cursorLayer.$pixelPos;
            var config2 = renderer.layerConfig;
            var top = pos.top - config2.offset;
            if (pos.top >= 0 && top + rect.top < 0) {
              shouldScroll = true;
            } else if (pos.top < config2.height && pos.top + rect.top + config2.lineHeight > window.innerHeight) {
              shouldScroll = false;
            } else {
              shouldScroll = null;
            }
            if (shouldScroll != null) {
              scrollAnchor.style.top = top + "px";
              scrollAnchor.style.left = pos.left + "px";
              scrollAnchor.style.height = config2.lineHeight + "px";
              scrollAnchor.scrollIntoView(shouldScroll);
            }
            shouldScroll = rect = null;
          }
        });
        this.setAutoScrollEditorIntoView = function(enable2) {
          if (enable2)
            return;
          delete this.setAutoScrollEditorIntoView;
          this.off("changeSelection", onChangeSelection);
          this.renderer.off("afterRender", onAfterRender);
          this.renderer.off("beforeRender", onBeforeRender);
        };
      };
      this.$resetCursorStyle = function() {
        var style = this.$cursorStyle || "ace";
        var cursorLayer = this.renderer.$cursorLayer;
        if (!cursorLayer)
          return;
        cursorLayer.setSmoothBlinking(/smooth/.test(style));
        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
      };
      this.prompt = function(message, options, callback) {
        var editor = this;
        config.loadModule("./ext/prompt", function(module3) {
          module3.prompt(editor, message, options, callback);
        });
      };
    }).call(Editor.prototype);
    config.defineOptions(Editor.prototype, "editor", {
      selectionStyle: {
        set: function(style) {
          this.onSelectionChange();
          this._signal("changeSelectionStyle", {data: style});
        },
        initialValue: "line"
      },
      highlightActiveLine: {
        set: function() {
          this.$updateHighlightActiveLine();
        },
        initialValue: true
      },
      highlightSelectedWord: {
        set: function(shouldHighlight) {
          this.$onSelectionChange();
        },
        initialValue: true
      },
      readOnly: {
        set: function(readOnly) {
          this.textInput.setReadOnly(readOnly);
          this.$resetCursorStyle();
        },
        initialValue: false
      },
      copyWithEmptySelection: {
        set: function(value) {
          this.textInput.setCopyWithEmptySelection(value);
        },
        initialValue: false
      },
      cursorStyle: {
        set: function(val) {
          this.$resetCursorStyle();
        },
        values: ["ace", "slim", "smooth", "wide"],
        initialValue: "ace"
      },
      mergeUndoDeltas: {
        values: [false, true, "always"],
        initialValue: true
      },
      behavioursEnabled: {initialValue: true},
      wrapBehavioursEnabled: {initialValue: true},
      enableAutoIndent: {initialValue: true},
      autoScrollEditorIntoView: {
        set: function(val) {
          this.setAutoScrollEditorIntoView(val);
        }
      },
      keyboardHandler: {
        set: function(val) {
          this.setKeyboardHandler(val);
        },
        get: function() {
          return this.$keybindingId;
        },
        handlesSet: true
      },
      value: {
        set: function(val) {
          this.session.setValue(val);
        },
        get: function() {
          return this.getValue();
        },
        handlesSet: true,
        hidden: true
      },
      session: {
        set: function(val) {
          this.setSession(val);
        },
        get: function() {
          return this.session;
        },
        handlesSet: true,
        hidden: true
      },
      showLineNumbers: {
        set: function(show) {
          this.renderer.$gutterLayer.setShowLineNumbers(show);
          this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
          if (show && this.$relativeLineNumbers)
            relativeNumberRenderer.attach(this);
          else
            relativeNumberRenderer.detach(this);
        },
        initialValue: true
      },
      relativeLineNumbers: {
        set: function(value) {
          if (this.$showLineNumbers && value)
            relativeNumberRenderer.attach(this);
          else
            relativeNumberRenderer.detach(this);
        }
      },
      placeholder: {
        set: function(message) {
          if (!this.$updatePlaceholder) {
            this.$updatePlaceholder = function() {
              var value = this.session && (this.renderer.$composition || this.getValue());
              if (value && this.renderer.placeholderNode) {
                this.renderer.off("afterRender", this.$updatePlaceholder);
                dom.removeCssClass(this.container, "ace_hasPlaceholder");
                this.renderer.placeholderNode.remove();
                this.renderer.placeholderNode = null;
              } else if (!value && !this.renderer.placeholderNode) {
                this.renderer.on("afterRender", this.$updatePlaceholder);
                dom.addCssClass(this.container, "ace_hasPlaceholder");
                var el = dom.createElement("div");
                el.className = "ace_placeholder";
                el.textContent = this.$placeholder || "";
                this.renderer.placeholderNode = el;
                this.renderer.content.appendChild(this.renderer.placeholderNode);
              } else if (!value && this.renderer.placeholderNode) {
                this.renderer.placeholderNode.textContent = this.$placeholder || "";
              }
            }.bind(this);
            this.on("input", this.$updatePlaceholder);
          }
          this.$updatePlaceholder();
        }
      },
      hScrollBarAlwaysVisible: "renderer",
      vScrollBarAlwaysVisible: "renderer",
      highlightGutterLine: "renderer",
      animatedScroll: "renderer",
      showInvisibles: "renderer",
      showPrintMargin: "renderer",
      printMarginColumn: "renderer",
      printMargin: "renderer",
      fadeFoldWidgets: "renderer",
      showFoldWidgets: "renderer",
      displayIndentGuides: "renderer",
      showGutter: "renderer",
      fontSize: "renderer",
      fontFamily: "renderer",
      maxLines: "renderer",
      minLines: "renderer",
      scrollPastEnd: "renderer",
      fixedWidthGutter: "renderer",
      theme: "renderer",
      hasCssTransforms: "renderer",
      maxPixelHeight: "renderer",
      useTextareaForIME: "renderer",
      scrollSpeed: "$mouseHandler",
      dragDelay: "$mouseHandler",
      dragEnabled: "$mouseHandler",
      focusTimeout: "$mouseHandler",
      tooltipFollowsMouse: "$mouseHandler",
      firstLineNumber: "session",
      overwrite: "session",
      newLineMode: "session",
      useWorker: "session",
      useSoftTabs: "session",
      navigateWithinSoftTabs: "session",
      tabSize: "session",
      wrap: "session",
      indentedSoftWrap: "session",
      foldStyle: "session",
      mode: "session"
    });
    var relativeNumberRenderer = {
      getText: function(session, row) {
        return (Math.abs(session.selection.lead.row - row) || row + 1 + (row < 9 ? "" : "")) + "";
      },
      getWidth: function(session, lastLineNumber, config2) {
        return Math.max(lastLineNumber.toString().length, (config2.lastRow + 1).toString().length, 2) * config2.characterWidth;
      },
      update: function(e2, editor) {
        editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
      },
      attach: function(editor) {
        editor.renderer.$gutterLayer.$renderer = this;
        editor.on("changeSelection", this.update);
        this.update(null, editor);
      },
      detach: function(editor) {
        if (editor.renderer.$gutterLayer.$renderer == this)
          editor.renderer.$gutterLayer.$renderer = null;
        editor.off("changeSelection", this.update);
        this.update(null, editor);
      }
    };
    exports2.Editor = Editor;
  });
  ace.define("ace/undomanager", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var UndoManager = function() {
      this.$maxRev = 0;
      this.$fromUndo = false;
      this.reset();
    };
    (function() {
      this.addSession = function(session) {
        this.$session = session;
      };
      this.add = function(delta, allowMerge, session) {
        if (this.$fromUndo)
          return;
        if (delta == this.$lastDelta)
          return;
        if (!this.$keepRedoStack)
          this.$redoStack.length = 0;
        if (allowMerge === false || !this.lastDeltas) {
          this.lastDeltas = [];
          this.$undoStack.push(this.lastDeltas);
          delta.id = this.$rev = ++this.$maxRev;
        }
        if (delta.action == "remove" || delta.action == "insert")
          this.$lastDelta = delta;
        this.lastDeltas.push(delta);
      };
      this.addSelection = function(selection, rev) {
        this.selections.push({
          value: selection,
          rev: rev || this.$rev
        });
      };
      this.startNewGroup = function() {
        this.lastDeltas = null;
        return this.$rev;
      };
      this.markIgnored = function(from, to) {
        if (to == null)
          to = this.$rev + 1;
        var stack = this.$undoStack;
        for (var i = stack.length; i--; ) {
          var delta = stack[i][0];
          if (delta.id <= from)
            break;
          if (delta.id < to)
            delta.ignore = true;
        }
        this.lastDeltas = null;
      };
      this.getSelection = function(rev, after) {
        var stack = this.selections;
        for (var i = stack.length; i--; ) {
          var selection = stack[i];
          if (selection.rev < rev) {
            if (after)
              selection = stack[i + 1];
            return selection;
          }
        }
      };
      this.getRevision = function() {
        return this.$rev;
      };
      this.getDeltas = function(from, to) {
        if (to == null)
          to = this.$rev + 1;
        var stack = this.$undoStack;
        var end = null, start = 0;
        for (var i = stack.length; i--; ) {
          var delta = stack[i][0];
          if (delta.id < to && !end)
            end = i + 1;
          if (delta.id <= from) {
            start = i + 1;
            break;
          }
        }
        return stack.slice(start, end);
      };
      this.getChangedRanges = function(from, to) {
        if (to == null)
          to = this.$rev + 1;
      };
      this.getChangedLines = function(from, to) {
        if (to == null)
          to = this.$rev + 1;
      };
      this.undo = function(session, dontSelect) {
        this.lastDeltas = null;
        var stack = this.$undoStack;
        if (!rearrangeUndoStack(stack, stack.length))
          return;
        if (!session)
          session = this.$session;
        if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
          this.$redoStack = [];
        this.$fromUndo = true;
        var deltaSet = stack.pop();
        var undoSelectionRange = null;
        if (deltaSet) {
          undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
          this.$redoStack.push(deltaSet);
          this.$syncRev();
        }
        this.$fromUndo = false;
        return undoSelectionRange;
      };
      this.redo = function(session, dontSelect) {
        this.lastDeltas = null;
        if (!session)
          session = this.$session;
        this.$fromUndo = true;
        if (this.$redoStackBaseRev != this.$rev) {
          var diff2 = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
          rebaseRedoStack(this.$redoStack, diff2);
          this.$redoStackBaseRev = this.$rev;
          this.$redoStack.forEach(function(x2) {
            x2[0].id = ++this.$maxRev;
          }, this);
        }
        var deltaSet = this.$redoStack.pop();
        var redoSelectionRange = null;
        if (deltaSet) {
          redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
          this.$undoStack.push(deltaSet);
          this.$syncRev();
        }
        this.$fromUndo = false;
        return redoSelectionRange;
      };
      this.$syncRev = function() {
        var stack = this.$undoStack;
        var nextDelta = stack[stack.length - 1];
        var id2 = nextDelta && nextDelta[0].id || 0;
        this.$redoStackBaseRev = id2;
        this.$rev = id2;
      };
      this.reset = function() {
        this.lastDeltas = null;
        this.$lastDelta = null;
        this.$undoStack = [];
        this.$redoStack = [];
        this.$rev = 0;
        this.mark = 0;
        this.$redoStackBaseRev = this.$rev;
        this.selections = [];
      };
      this.canUndo = function() {
        return this.$undoStack.length > 0;
      };
      this.canRedo = function() {
        return this.$redoStack.length > 0;
      };
      this.bookmark = function(rev) {
        if (rev == void 0)
          rev = this.$rev;
        this.mark = rev;
      };
      this.isAtBookmark = function() {
        return this.$rev === this.mark;
      };
      this.toJSON = function() {
      };
      this.fromJSON = function() {
      };
      this.hasUndo = this.canUndo;
      this.hasRedo = this.canRedo;
      this.isClean = this.isAtBookmark;
      this.markClean = this.bookmark;
      this.$prettyPrint = function(delta) {
        if (delta)
          return stringifyDelta(delta);
        return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
      };
    }).call(UndoManager.prototype);
    function rearrangeUndoStack(stack, pos) {
      for (var i = pos; i--; ) {
        var deltaSet = stack[i];
        if (deltaSet && !deltaSet[0].ignore) {
          while (i < pos - 1) {
            var swapped = swapGroups(stack[i], stack[i + 1]);
            stack[i] = swapped[0];
            stack[i + 1] = swapped[1];
            i++;
          }
          return true;
        }
      }
    }
    var Range = require2("./range").Range;
    var cmp = Range.comparePoints;
    var comparePoints = Range.comparePoints;
    function clonePos(pos) {
      return {row: pos.row, column: pos.column};
    }
    function cloneDelta(d2) {
      return {
        start: clonePos(d2.start),
        end: clonePos(d2.end),
        action: d2.action,
        lines: d2.lines.slice()
      };
    }
    function stringifyDelta(d2) {
      d2 = d2 || this;
      if (Array.isArray(d2)) {
        return d2.map(stringifyDelta).join("\n");
      }
      var type2 = "";
      if (d2.action) {
        type2 = d2.action == "insert" ? "+" : "-";
        type2 += "[" + d2.lines + "]";
      } else if (d2.value) {
        if (Array.isArray(d2.value)) {
          type2 = d2.value.map(stringifyRange).join("\n");
        } else {
          type2 = stringifyRange(d2.value);
        }
      }
      if (d2.start) {
        type2 += stringifyRange(d2);
      }
      if (d2.id || d2.rev) {
        type2 += "	(" + (d2.id || d2.rev) + ")";
      }
      return type2;
    }
    function stringifyRange(r2) {
      return r2.start.row + ":" + r2.start.column + "=>" + r2.end.row + ":" + r2.end.column;
    }
    function swap(d1, d2) {
      var i1 = d1.action == "insert";
      var i2 = d2.action == "insert";
      if (i1 && i2) {
        if (cmp(d2.start, d1.end) >= 0) {
          shift(d2, d1, -1);
        } else if (cmp(d2.start, d1.start) <= 0) {
          shift(d1, d2, 1);
        } else {
          return null;
        }
      } else if (i1 && !i2) {
        if (cmp(d2.start, d1.end) >= 0) {
          shift(d2, d1, -1);
        } else if (cmp(d2.end, d1.start) <= 0) {
          shift(d1, d2, -1);
        } else {
          return null;
        }
      } else if (!i1 && i2) {
        if (cmp(d2.start, d1.start) >= 0) {
          shift(d2, d1, 1);
        } else if (cmp(d2.start, d1.start) <= 0) {
          shift(d1, d2, 1);
        } else {
          return null;
        }
      } else if (!i1 && !i2) {
        if (cmp(d2.start, d1.start) >= 0) {
          shift(d2, d1, 1);
        } else if (cmp(d2.end, d1.start) <= 0) {
          shift(d1, d2, -1);
        } else {
          return null;
        }
      }
      return [d2, d1];
    }
    function swapGroups(ds1, ds2) {
      for (var i = ds1.length; i--; ) {
        for (var j = 0; j < ds2.length; j++) {
          if (!swap(ds1[i], ds2[j])) {
            while (i < ds1.length) {
              while (j--) {
                swap(ds2[j], ds1[i]);
              }
              j = ds2.length;
              i++;
            }
            return [ds1, ds2];
          }
        }
      }
      ds1.selectionBefore = ds2.selectionBefore = ds1.selectionAfter = ds2.selectionAfter = null;
      return [ds2, ds1];
    }
    function xform(d1, c1) {
      var i1 = d1.action == "insert";
      var i2 = c1.action == "insert";
      if (i1 && i2) {
        if (cmp(d1.start, c1.start) < 0) {
          shift(c1, d1, 1);
        } else {
          shift(d1, c1, 1);
        }
      } else if (i1 && !i2) {
        if (cmp(d1.start, c1.end) >= 0) {
          shift(d1, c1, -1);
        } else if (cmp(d1.start, c1.start) <= 0) {
          shift(c1, d1, 1);
        } else {
          shift(d1, Range.fromPoints(c1.start, d1.start), -1);
          shift(c1, d1, 1);
        }
      } else if (!i1 && i2) {
        if (cmp(c1.start, d1.end) >= 0) {
          shift(c1, d1, -1);
        } else if (cmp(c1.start, d1.start) <= 0) {
          shift(d1, c1, 1);
        } else {
          shift(c1, Range.fromPoints(d1.start, c1.start), -1);
          shift(d1, c1, 1);
        }
      } else if (!i1 && !i2) {
        if (cmp(c1.start, d1.end) >= 0) {
          shift(c1, d1, -1);
        } else if (cmp(c1.end, d1.start) <= 0) {
          shift(d1, c1, -1);
        } else {
          var before, after;
          if (cmp(d1.start, c1.start) < 0) {
            before = d1;
            d1 = splitDelta(d1, c1.start);
          }
          if (cmp(d1.end, c1.end) > 0) {
            after = splitDelta(d1, c1.end);
          }
          shiftPos(c1.end, d1.start, d1.end, -1);
          if (after && !before) {
            d1.lines = after.lines;
            d1.start = after.start;
            d1.end = after.end;
            after = d1;
          }
          return [c1, before, after].filter(Boolean);
        }
      }
      return [c1, d1];
    }
    function shift(d1, d2, dir) {
      shiftPos(d1.start, d2.start, d2.end, dir);
      shiftPos(d1.end, d2.start, d2.end, dir);
    }
    function shiftPos(pos, start, end, dir) {
      if (pos.row == (dir == 1 ? start : end).row) {
        pos.column += dir * (end.column - start.column);
      }
      pos.row += dir * (end.row - start.row);
    }
    function splitDelta(c2, pos) {
      var lines = c2.lines;
      var end = c2.end;
      c2.end = clonePos(pos);
      var rowsBefore = c2.end.row - c2.start.row;
      var otherLines = lines.splice(rowsBefore, lines.length);
      var col = rowsBefore ? pos.column : pos.column - c2.start.column;
      lines.push(otherLines[0].substring(0, col));
      otherLines[0] = otherLines[0].substr(col);
      var rest = {
        start: clonePos(pos),
        end,
        lines: otherLines,
        action: c2.action
      };
      return rest;
    }
    function moveDeltasByOne(redoStack, d2) {
      d2 = cloneDelta(d2);
      for (var j = redoStack.length; j--; ) {
        var deltaSet = redoStack[j];
        for (var i = 0; i < deltaSet.length; i++) {
          var x2 = deltaSet[i];
          var xformed = xform(x2, d2);
          d2 = xformed[0];
          if (xformed.length != 2) {
            if (xformed[2]) {
              deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
              i++;
            } else if (!xformed[1]) {
              deltaSet.splice(i, 1);
              i--;
            }
          }
        }
        if (!deltaSet.length) {
          redoStack.splice(j, 1);
        }
      }
      return redoStack;
    }
    function rebaseRedoStack(redoStack, deltaSets) {
      for (var i = 0; i < deltaSets.length; i++) {
        var deltas = deltaSets[i];
        for (var j = 0; j < deltas.length; j++) {
          moveDeltasByOne(redoStack, deltas[j]);
        }
      }
    }
    exports2.UndoManager = UndoManager;
  });
  ace.define("ace/layer/lines", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
    var dom = require2("../lib/dom");
    var Lines = function(element, canvasHeight) {
      this.element = element;
      this.canvasHeight = canvasHeight || 5e5;
      this.element.style.height = this.canvasHeight * 2 + "px";
      this.cells = [];
      this.cellCache = [];
      this.$offsetCoefficient = 0;
    };
    (function() {
      this.moveContainer = function(config) {
        dom.translate(this.element, 0, -(config.firstRowScreen * config.lineHeight % this.canvasHeight) - config.offset * this.$offsetCoefficient);
      };
      this.pageChanged = function(oldConfig, newConfig) {
        return Math.floor(oldConfig.firstRowScreen * oldConfig.lineHeight / this.canvasHeight) !== Math.floor(newConfig.firstRowScreen * newConfig.lineHeight / this.canvasHeight);
      };
      this.computeLineTop = function(row, config, session) {
        var screenTop = config.firstRowScreen * config.lineHeight;
        var screenPage = Math.floor(screenTop / this.canvasHeight);
        var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
        return lineTop - screenPage * this.canvasHeight;
      };
      this.computeLineHeight = function(row, config, session) {
        return config.lineHeight * session.getRowLineCount(row);
      };
      this.getLength = function() {
        return this.cells.length;
      };
      this.get = function(index2) {
        return this.cells[index2];
      };
      this.shift = function() {
        this.$cacheCell(this.cells.shift());
      };
      this.pop = function() {
        this.$cacheCell(this.cells.pop());
      };
      this.push = function(cell) {
        if (Array.isArray(cell)) {
          this.cells.push.apply(this.cells, cell);
          var fragment = dom.createFragment(this.element);
          for (var i = 0; i < cell.length; i++) {
            fragment.appendChild(cell[i].element);
          }
          this.element.appendChild(fragment);
        } else {
          this.cells.push(cell);
          this.element.appendChild(cell.element);
        }
      };
      this.unshift = function(cell) {
        if (Array.isArray(cell)) {
          this.cells.unshift.apply(this.cells, cell);
          var fragment = dom.createFragment(this.element);
          for (var i = 0; i < cell.length; i++) {
            fragment.appendChild(cell[i].element);
          }
          if (this.element.firstChild)
            this.element.insertBefore(fragment, this.element.firstChild);
          else
            this.element.appendChild(fragment);
        } else {
          this.cells.unshift(cell);
          this.element.insertAdjacentElement("afterbegin", cell.element);
        }
      };
      this.last = function() {
        if (this.cells.length)
          return this.cells[this.cells.length - 1];
        else
          return null;
      };
      this.$cacheCell = function(cell) {
        if (!cell)
          return;
        cell.element.remove();
        this.cellCache.push(cell);
      };
      this.createCell = function(row, config, session, initElement) {
        var cell = this.cellCache.pop();
        if (!cell) {
          var element = dom.createElement("div");
          if (initElement)
            initElement(element);
          this.element.appendChild(element);
          cell = {
            element,
            text: "",
            row
          };
        }
        cell.row = row;
        return cell;
      };
    }).call(Lines.prototype);
    exports2.Lines = Lines;
  });
  ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/layer/lines"], function(require2, exports2, module2) {
    var dom = require2("../lib/dom");
    var oop = require2("../lib/oop");
    var lang = require2("../lib/lang");
    var EventEmitter = require2("../lib/event_emitter").EventEmitter;
    var Lines = require2("./lines").Lines;
    var Gutter = function(parentEl) {
      this.element = dom.createElement("div");
      this.element.className = "ace_layer ace_gutter-layer";
      parentEl.appendChild(this.element);
      this.setShowFoldWidgets(this.$showFoldWidgets);
      this.gutterWidth = 0;
      this.$annotations = [];
      this.$updateAnnotations = this.$updateAnnotations.bind(this);
      this.$lines = new Lines(this.element);
      this.$lines.$offsetCoefficient = 1;
    };
    (function() {
      oop.implement(this, EventEmitter);
      this.setSession = function(session) {
        if (this.session)
          this.session.off("change", this.$updateAnnotations);
        this.session = session;
        if (session)
          session.on("change", this.$updateAnnotations);
      };
      this.addGutterDecoration = function(row, className) {
        if (window.console)
          console.warn && console.warn("deprecated use session.addGutterDecoration");
        this.session.addGutterDecoration(row, className);
      };
      this.removeGutterDecoration = function(row, className) {
        if (window.console)
          console.warn && console.warn("deprecated use session.removeGutterDecoration");
        this.session.removeGutterDecoration(row, className);
      };
      this.setAnnotations = function(annotations) {
        this.$annotations = [];
        for (var i = 0; i < annotations.length; i++) {
          var annotation = annotations[i];
          var row = annotation.row;
          var rowInfo = this.$annotations[row];
          if (!rowInfo)
            rowInfo = this.$annotations[row] = {text: []};
          var annoText = annotation.text;
          annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
          if (rowInfo.text.indexOf(annoText) === -1)
            rowInfo.text.push(annoText);
          var type2 = annotation.type;
          if (type2 == "error")
            rowInfo.className = " ace_error";
          else if (type2 == "warning" && rowInfo.className != " ace_error")
            rowInfo.className = " ace_warning";
          else if (type2 == "info" && !rowInfo.className)
            rowInfo.className = " ace_info";
        }
      };
      this.$updateAnnotations = function(delta) {
        if (!this.$annotations.length)
          return;
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0)
          ;
        else if (delta.action == "remove") {
          this.$annotations.splice(firstRow, len + 1, null);
        } else {
          var args = new Array(len + 1);
          args.unshift(firstRow, 1);
          this.$annotations.splice.apply(this.$annotations, args);
        }
      };
      this.update = function(config) {
        this.config = config;
        var session = this.session;
        var firstRow = config.firstRow;
        var lastRow = Math.min(config.lastRow + config.gutterOffset, session.getLength() - 1);
        this.oldLastRow = lastRow;
        this.config = config;
        this.$lines.moveContainer(config);
        this.$updateCursorRow();
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;
        var cell = null;
        var index2 = -1;
        var row = firstRow;
        while (true) {
          if (row > foldStart) {
            row = fold.end.row + 1;
            fold = session.getNextFoldLine(row, fold);
            foldStart = fold ? fold.start.row : Infinity;
          }
          if (row > lastRow) {
            while (this.$lines.getLength() > index2 + 1)
              this.$lines.pop();
            break;
          }
          cell = this.$lines.get(++index2);
          if (cell) {
            cell.row = row;
          } else {
            cell = this.$lines.createCell(row, config, this.session, onCreateCell);
            this.$lines.push(cell);
          }
          this.$renderCell(cell, config, fold, row);
          row++;
        }
        this._signal("afterRender");
        this.$updateGutterWidth(config);
      };
      this.$updateGutterWidth = function(config) {
        var session = this.session;
        var gutterRenderer = session.gutterRenderer || this.$renderer;
        var firstLineNumber = session.$firstLineNumber;
        var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
        if (this.$fixedWidth || session.$useWrapMode)
          lastLineText = session.getLength() + firstLineNumber - 1;
        var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineText, config) : lastLineText.toString().length * config.characterWidth;
        var padding = this.$padding || this.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
          this.gutterWidth = gutterWidth;
          this.element.parentNode.style.width = this.element.style.width = Math.ceil(this.gutterWidth) + "px";
          this._signal("changeGutterWidth", gutterWidth);
        }
      };
      this.$updateCursorRow = function() {
        if (!this.$highlightGutterLine)
          return;
        var position = this.session.selection.getCursor();
        if (this.$cursorRow === position.row)
          return;
        this.$cursorRow = position.row;
      };
      this.updateLineHighlight = function() {
        if (!this.$highlightGutterLine)
          return;
        var row = this.session.selection.cursor.row;
        this.$cursorRow = row;
        if (this.$cursorCell && this.$cursorCell.row == row)
          return;
        if (this.$cursorCell)
          this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
        var cells = this.$lines.cells;
        this.$cursorCell = null;
        for (var i = 0; i < cells.length; i++) {
          var cell = cells[i];
          if (cell.row >= this.$cursorRow) {
            if (cell.row > this.$cursorRow) {
              var fold = this.session.getFoldLine(this.$cursorRow);
              if (i > 0 && fold && fold.start.row == cells[i - 1].row)
                cell = cells[i - 1];
              else
                break;
            }
            cell.element.className = "ace_gutter-active-line " + cell.element.className;
            this.$cursorCell = cell;
            break;
          }
        }
      };
      this.scrollLines = function(config) {
        var oldConfig = this.config;
        this.config = config;
        this.$updateCursorRow();
        if (this.$lines.pageChanged(oldConfig, config))
          return this.update(config);
        this.$lines.moveContainer(config);
        var lastRow = Math.min(config.lastRow + config.gutterOffset, this.session.getLength() - 1);
        var oldLastRow = this.oldLastRow;
        this.oldLastRow = lastRow;
        if (!oldConfig || oldLastRow < config.firstRow)
          return this.update(config);
        if (lastRow < oldConfig.firstRow)
          return this.update(config);
        if (oldConfig.firstRow < config.firstRow)
          for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
            this.$lines.shift();
        if (oldLastRow > lastRow)
          for (var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row > 0; row--)
            this.$lines.pop();
        if (config.firstRow < oldConfig.firstRow) {
          this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
        }
        if (lastRow > oldLastRow) {
          this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
        }
        this.updateLineHighlight();
        this._signal("afterRender");
        this.$updateGutterWidth(config);
      };
      this.$renderLines = function(config, firstRow, lastRow) {
        var fragment = [];
        var row = firstRow;
        var foldLine2 = this.session.getNextFoldLine(row);
        var foldStart = foldLine2 ? foldLine2.start.row : Infinity;
        while (true) {
          if (row > foldStart) {
            row = foldLine2.end.row + 1;
            foldLine2 = this.session.getNextFoldLine(row, foldLine2);
            foldStart = foldLine2 ? foldLine2.start.row : Infinity;
          }
          if (row > lastRow)
            break;
          var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
          this.$renderCell(cell, config, foldLine2, row);
          fragment.push(cell);
          row++;
        }
        return fragment;
      };
      this.$renderCell = function(cell, config, fold, row) {
        var element = cell.element;
        var session = this.session;
        var textNode = element.childNodes[0];
        var foldWidget = element.childNodes[1];
        var firstLineNumber = session.$firstLineNumber;
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var gutterRenderer = session.gutterRenderer || this.$renderer;
        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
        var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
        var className = "ace_gutter-cell ";
        if (this.$highlightGutterLine) {
          if (row == this.$cursorRow || fold && row < this.$cursorRow && row >= foldStart && this.$cursorRow <= fold.end.row) {
            className += "ace_gutter-active-line ";
            if (this.$cursorCell != cell) {
              if (this.$cursorCell)
                this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
              this.$cursorCell = cell;
            }
          }
        }
        if (breakpoints[row])
          className += breakpoints[row];
        if (decorations[row])
          className += decorations[row];
        if (this.$annotations[row])
          className += this.$annotations[row].className;
        if (element.className != className)
          element.className = className;
        if (foldWidgets) {
          var c2 = foldWidgets[row];
          if (c2 == null)
            c2 = foldWidgets[row] = session.getFoldWidget(row);
        }
        if (c2) {
          var className = "ace_fold-widget ace_" + c2;
          if (c2 == "start" && row == foldStart && row < fold.end.row)
            className += " ace_closed";
          else
            className += " ace_open";
          if (foldWidget.className != className)
            foldWidget.className = className;
          var foldHeight = config.lineHeight + "px";
          dom.setStyle(foldWidget.style, "height", foldHeight);
          dom.setStyle(foldWidget.style, "display", "inline-block");
        } else {
          if (foldWidget) {
            dom.setStyle(foldWidget.style, "display", "none");
          }
        }
        var text = (gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber).toString();
        if (text !== textNode.data) {
          textNode.data = text;
        }
        dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
        dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
        cell.text = text;
        return cell;
      };
      this.$fixedWidth = false;
      this.$highlightGutterLine = true;
      this.$renderer = "";
      this.setHighlightGutterLine = function(highlightGutterLine) {
        this.$highlightGutterLine = highlightGutterLine;
      };
      this.$showLineNumbers = true;
      this.$renderer = "";
      this.setShowLineNumbers = function(show) {
        this.$renderer = !show && {
          getWidth: function() {
            return 0;
          },
          getText: function() {
            return "";
          }
        };
      };
      this.getShowLineNumbers = function() {
        return this.$showLineNumbers;
      };
      this.$showFoldWidgets = true;
      this.setShowFoldWidgets = function(show) {
        if (show)
          dom.addCssClass(this.element, "ace_folding-enabled");
        else
          dom.removeCssClass(this.element, "ace_folding-enabled");
        this.$showFoldWidgets = show;
        this.$padding = null;
      };
      this.getShowFoldWidgets = function() {
        return this.$showFoldWidgets;
      };
      this.$computePadding = function() {
        if (!this.element.firstChild)
          return {left: 0, right: 0};
        var style = dom.computedStyle(this.element.firstChild);
        this.$padding = {};
        this.$padding.left = (parseInt(style.borderLeftWidth) || 0) + (parseInt(style.paddingLeft) || 0) + 1;
        this.$padding.right = (parseInt(style.borderRightWidth) || 0) + (parseInt(style.paddingRight) || 0);
        return this.$padding;
      };
      this.getRegion = function(point) {
        var padding = this.$padding || this.$computePadding();
        var rect = this.element.getBoundingClientRect();
        if (point.x < padding.left + rect.left)
          return "markers";
        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
          return "foldWidgets";
      };
    }).call(Gutter.prototype);
    function onCreateCell(element) {
      var textNode = document.createTextNode("");
      element.appendChild(textNode);
      var foldWidget = dom.createElement("span");
      element.appendChild(foldWidget);
      return element;
    }
    exports2.Gutter = Gutter;
  });
  ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function(require2, exports2, module2) {
    var Range = require2("../range").Range;
    var dom = require2("../lib/dom");
    var Marker = function(parentEl) {
      this.element = dom.createElement("div");
      this.element.className = "ace_layer ace_marker-layer";
      parentEl.appendChild(this.element);
    };
    (function() {
      this.$padding = 0;
      this.setPadding = function(padding) {
        this.$padding = padding;
      };
      this.setSession = function(session) {
        this.session = session;
      };
      this.setMarkers = function(markers) {
        this.markers = markers;
      };
      this.elt = function(className, css) {
        var x2 = this.i != -1 && this.element.childNodes[this.i];
        if (!x2) {
          x2 = document.createElement("div");
          this.element.appendChild(x2);
          this.i = -1;
        } else {
          this.i++;
        }
        x2.style.cssText = css;
        x2.className = className;
      };
      this.update = function(config) {
        if (!config)
          return;
        this.config = config;
        this.i = 0;
        var html;
        for (var key in this.markers) {
          var marker = this.markers[key];
          if (!marker.range) {
            marker.update(html, this, this.session, config);
            continue;
          }
          var range = marker.range.clipRows(config.firstRow, config.lastRow);
          if (range.isEmpty())
            continue;
          range = range.toScreenRange(this.session);
          if (marker.renderer) {
            var top = this.$getTop(range.start.row, config);
            var left = this.$padding + range.start.column * config.characterWidth;
            marker.renderer(html, range, left, top, config);
          } else if (marker.type == "fullLine") {
            this.drawFullLineMarker(html, range, marker.clazz, config);
          } else if (marker.type == "screenLine") {
            this.drawScreenLineMarker(html, range, marker.clazz, config);
          } else if (range.isMultiLine()) {
            if (marker.type == "text")
              this.drawTextMarker(html, range, marker.clazz, config);
            else
              this.drawMultiLineMarker(html, range, marker.clazz, config);
          } else {
            this.drawSingleLineMarker(html, range, marker.clazz + " ace_start ace_br15", config);
          }
        }
        if (this.i != -1) {
          while (this.i < this.element.childElementCount)
            this.element.removeChild(this.element.lastChild);
        }
      };
      this.$getTop = function(row, layerConfig) {
        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
      };
      function getBorderClass(tl, tr, br, bl) {
        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
      }
      this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
        var session = this.session;
        var start = range.start.row;
        var end = range.end.row;
        var row = start;
        var prev = 0;
        var curr = 0;
        var next = session.getScreenLastRowColumn(row);
        var lineRange = new Range(row, range.start.column, row, curr);
        for (; row <= end; row++) {
          lineRange.start.row = lineRange.end.row = row;
          lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
          lineRange.end.column = next;
          prev = curr;
          curr = next;
          next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
          this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
        }
      };
      this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var padding = this.$padding;
        var height = config.lineHeight;
        var top = this.$getTop(range.start.row, config);
        var left = padding + range.start.column * config.characterWidth;
        extraStyle = extraStyle || "";
        if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
          var range1 = range.clone();
          range1.end.row = range1.start.row;
          range1.end.column = this.session.getLine(range1.start.row).length;
          this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
        } else {
          this.elt(clazz + " ace_br1 ace_start", "height:" + height + "px;right:0;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
        }
        if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
          var range1 = range.clone();
          range1.start.row = range1.end.row;
          range1.start.column = 0;
          this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
        } else {
          top = this.$getTop(range.end.row, config);
          var width = range.end.column * config.characterWidth;
          this.elt(clazz + " ace_br12", "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
        }
        height = (range.end.row - range.start.row - 1) * config.lineHeight;
        if (height <= 0)
          return;
        top = this.$getTop(range.start.row + 1, config);
        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
        this.elt(clazz + (radiusClass ? " ace_br" + radiusClass : ""), "height:" + height + "px;right:0;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
      };
      this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        if (this.session.$bidiHandler.isBidiRow(range.start.row))
          return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
        var height = config.lineHeight;
        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
        var top = this.$getTop(range.start.row, config);
        var left = this.$padding + range.start.column * config.characterWidth;
        this.elt(clazz, "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
      };
      this.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
        var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
        selections.forEach(function(selection) {
          this.elt(clazz, "height:" + height + "px;width:" + selection.width + (extraLength || 0) + "px;top:" + top + "px;left:" + (padding + selection.left) + "px;" + (extraStyle || ""));
        }, this);
      };
      this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        if (range.start.row != range.end.row)
          height += this.$getTop(range.end.row, config) - top;
        this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
      };
      this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
      };
    }).call(Marker.prototype);
    exports2.Marker = Marker;
  });
  ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/layer/lines", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var dom = require2("../lib/dom");
    var lang = require2("../lib/lang");
    var Lines = require2("./lines").Lines;
    var EventEmitter = require2("../lib/event_emitter").EventEmitter;
    var Text = function(parentEl) {
      this.dom = dom;
      this.element = this.dom.createElement("div");
      this.element.className = "ace_layer ace_text-layer";
      parentEl.appendChild(this.element);
      this.$updateEolChar = this.$updateEolChar.bind(this);
      this.$lines = new Lines(this.element);
    };
    (function() {
      oop.implement(this, EventEmitter);
      this.EOF_CHAR = "";
      this.EOL_CHAR_LF = "";
      this.EOL_CHAR_CRLF = "";
      this.EOL_CHAR = this.EOL_CHAR_LF;
      this.TAB_CHAR = "";
      this.SPACE_CHAR = "";
      this.$padding = 0;
      this.MAX_LINE_LENGTH = 1e4;
      this.$updateEolChar = function() {
        var doc = this.session.doc;
        var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
        var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
        if (this.EOL_CHAR != EOL_CHAR) {
          this.EOL_CHAR = EOL_CHAR;
          return true;
        }
      };
      this.setPadding = function(padding) {
        this.$padding = padding;
        this.element.style.margin = "0 " + padding + "px";
      };
      this.getLineHeight = function() {
        return this.$fontMetrics.$characterSize.height || 0;
      };
      this.getCharacterWidth = function() {
        return this.$fontMetrics.$characterSize.width || 0;
      };
      this.$setFontMetrics = function(measure) {
        this.$fontMetrics = measure;
        this.$fontMetrics.on("changeCharacterSize", function(e2) {
          this._signal("changeCharacterSize", e2);
        }.bind(this));
        this.$pollSizeChanges();
      };
      this.checkForSizeChanges = function() {
        this.$fontMetrics.checkForSizeChanges();
      };
      this.$pollSizeChanges = function() {
        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
      };
      this.setSession = function(session) {
        this.session = session;
        if (session)
          this.$computeTabString();
      };
      this.showInvisibles = false;
      this.showSpaces = false;
      this.showTabs = false;
      this.showEOL = false;
      this.setShowInvisibles = function(showInvisibles) {
        if (this.showInvisibles == showInvisibles)
          return false;
        this.showInvisibles = showInvisibles;
        if (typeof showInvisibles == "string") {
          this.showSpaces = /tab/i.test(showInvisibles);
          this.showTabs = /space/i.test(showInvisibles);
          this.showEOL = /eol/i.test(showInvisibles);
        } else {
          this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
        }
        this.$computeTabString();
        return true;
      };
      this.displayIndentGuides = true;
      this.setDisplayIndentGuides = function(display) {
        if (this.displayIndentGuides == display)
          return false;
        this.displayIndentGuides = display;
        this.$computeTabString();
        return true;
      };
      this.$tabStrings = [];
      this.onChangeTabSize = this.$computeTabString = function() {
        var tabSize = this.session.getTabSize();
        this.tabSize = tabSize;
        var tabStr = this.$tabStrings = [0];
        for (var i = 1; i < tabSize + 1; i++) {
          if (this.showTabs) {
            var span = this.dom.createElement("span");
            span.className = "ace_invisible ace_invisible_tab";
            span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
            tabStr.push(span);
          } else {
            tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
          }
        }
        if (this.displayIndentGuides) {
          this.$indentGuideRe = /\s\S| \t|\t |\s$/;
          var className = "ace_indent-guide";
          var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
          var spaceContent = this.showSpaces ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize) : lang.stringRepeat(" ", this.tabSize);
          var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
          var tabContent = this.showTabs ? lang.stringRepeat(this.TAB_CHAR, this.tabSize) : spaceContent;
          var span = this.dom.createElement("span");
          span.className = className + spaceClass;
          span.textContent = spaceContent;
          this.$tabStrings[" "] = span;
          var span = this.dom.createElement("span");
          span.className = className + tabClass;
          span.textContent = tabContent;
          this.$tabStrings["	"] = span;
        }
      };
      this.updateLines = function(config, firstRow, lastRow) {
        if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
          return this.update(config);
        }
        this.config = config;
        var first = Math.max(firstRow, config.firstRow);
        var last = Math.min(lastRow, config.lastRow);
        var lineElements = this.element.childNodes;
        var lineElementsIdx = 0;
        for (var row = config.firstRow; row < first; row++) {
          var foldLine2 = this.session.getFoldLine(row);
          if (foldLine2) {
            if (foldLine2.containsRow(first)) {
              first = foldLine2.start.row;
              break;
            } else {
              row = foldLine2.end.row;
            }
          }
          lineElementsIdx++;
        }
        var heightChanged = false;
        var row = first;
        var foldLine2 = this.session.getNextFoldLine(row);
        var foldStart = foldLine2 ? foldLine2.start.row : Infinity;
        while (true) {
          if (row > foldStart) {
            row = foldLine2.end.row + 1;
            foldLine2 = this.session.getNextFoldLine(row, foldLine2);
            foldStart = foldLine2 ? foldLine2.start.row : Infinity;
          }
          if (row > last)
            break;
          var lineElement = lineElements[lineElementsIdx++];
          if (lineElement) {
            this.dom.removeChildren(lineElement);
            this.$renderLine(lineElement, row, row == foldStart ? foldLine2 : false);
            if (heightChanged)
              lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";
            var height = config.lineHeight * this.session.getRowLength(row) + "px";
            if (lineElement.style.height != height) {
              heightChanged = true;
              lineElement.style.height = height;
            }
          }
          row++;
        }
        if (heightChanged) {
          while (lineElementsIdx < this.$lines.cells.length) {
            var cell = this.$lines.cells[lineElementsIdx++];
            cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
          }
        }
      };
      this.scrollLines = function(config) {
        var oldConfig = this.config;
        this.config = config;
        if (this.$lines.pageChanged(oldConfig, config))
          return this.update(config);
        this.$lines.moveContainer(config);
        var lastRow = config.lastRow;
        var oldLastRow = oldConfig ? oldConfig.lastRow : -1;
        if (!oldConfig || oldLastRow < config.firstRow)
          return this.update(config);
        if (lastRow < oldConfig.firstRow)
          return this.update(config);
        if (!oldConfig || oldConfig.lastRow < config.firstRow)
          return this.update(config);
        if (config.lastRow < oldConfig.firstRow)
          return this.update(config);
        if (oldConfig.firstRow < config.firstRow)
          for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
            this.$lines.shift();
        if (oldConfig.lastRow > config.lastRow)
          for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)
            this.$lines.pop();
        if (config.firstRow < oldConfig.firstRow) {
          this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
        }
        if (config.lastRow > oldConfig.lastRow) {
          this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
        }
      };
      this.$renderLinesFragment = function(config, firstRow, lastRow) {
        var fragment = [];
        var row = firstRow;
        var foldLine2 = this.session.getNextFoldLine(row);
        var foldStart = foldLine2 ? foldLine2.start.row : Infinity;
        while (true) {
          if (row > foldStart) {
            row = foldLine2.end.row + 1;
            foldLine2 = this.session.getNextFoldLine(row, foldLine2);
            foldStart = foldLine2 ? foldLine2.start.row : Infinity;
          }
          if (row > lastRow)
            break;
          var line = this.$lines.createCell(row, config, this.session);
          var lineEl = line.element;
          this.dom.removeChildren(lineEl);
          dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
          dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");
          this.$renderLine(lineEl, row, row == foldStart ? foldLine2 : false);
          if (this.$useLineGroups()) {
            lineEl.className = "ace_line_group";
          } else {
            lineEl.className = "ace_line";
          }
          fragment.push(line);
          row++;
        }
        return fragment;
      };
      this.update = function(config) {
        this.$lines.moveContainer(config);
        this.config = config;
        var firstRow = config.firstRow;
        var lastRow = config.lastRow;
        var lines = this.$lines;
        while (lines.getLength())
          lines.pop();
        lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
      };
      this.$textToken = {
        text: true,
        rparen: true,
        lparen: true
      };
      this.$renderToken = function(parent, screenColumn, token, value) {
        var self2 = this;
        var re2 = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
        var valueFragment = this.dom.createFragment(this.element);
        var m2;
        var i = 0;
        while (m2 = re2.exec(value)) {
          var tab = m2[1];
          var simpleSpace = m2[2];
          var controlCharacter = m2[3];
          var cjkSpace = m2[4];
          var cjk = m2[5];
          if (!self2.showSpaces && simpleSpace)
            continue;
          var before = i != m2.index ? value.slice(i, m2.index) : "";
          i = m2.index + m2[0].length;
          if (before) {
            valueFragment.appendChild(this.dom.createTextNode(before, this.element));
          }
          if (tab) {
            var tabSize = self2.session.getScreenTabSize(screenColumn + m2.index);
            valueFragment.appendChild(self2.$tabStrings[tabSize].cloneNode(true));
            screenColumn += tabSize - 1;
          } else if (simpleSpace) {
            if (self2.showSpaces) {
              var span = this.dom.createElement("span");
              span.className = "ace_invisible ace_invisible_space";
              span.textContent = lang.stringRepeat(self2.SPACE_CHAR, simpleSpace.length);
              valueFragment.appendChild(span);
            } else {
              valueFragment.appendChild(this.com.createTextNode(simpleSpace, this.element));
            }
          } else if (controlCharacter) {
            var span = this.dom.createElement("span");
            span.className = "ace_invisible ace_invisible_space ace_invalid";
            span.textContent = lang.stringRepeat(self2.SPACE_CHAR, controlCharacter.length);
            valueFragment.appendChild(span);
          } else if (cjkSpace) {
            screenColumn += 1;
            var span = this.dom.createElement("span");
            span.style.width = self2.config.characterWidth * 2 + "px";
            span.className = self2.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
            span.textContent = self2.showSpaces ? self2.SPACE_CHAR : cjkSpace;
            valueFragment.appendChild(span);
          } else if (cjk) {
            screenColumn += 1;
            var span = this.dom.createElement("span");
            span.style.width = self2.config.characterWidth * 2 + "px";
            span.className = "ace_cjk";
            span.textContent = cjk;
            valueFragment.appendChild(span);
          }
        }
        valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));
        if (!this.$textToken[token.type]) {
          var classes = "ace_" + token.type.replace(/\./g, " ace_");
          var span = this.dom.createElement("span");
          if (token.type == "fold")
            span.style.width = token.value.length * this.config.characterWidth + "px";
          span.className = classes;
          span.appendChild(valueFragment);
          parent.appendChild(span);
        } else {
          parent.appendChild(valueFragment);
        }
        return screenColumn + value.length;
      };
      this.renderIndentGuide = function(parent, value, max) {
        var cols = value.search(this.$indentGuideRe);
        if (cols <= 0 || cols >= max)
          return value;
        if (value[0] == " ") {
          cols -= cols % this.tabSize;
          var count = cols / this.tabSize;
          for (var i = 0; i < count; i++) {
            parent.appendChild(this.$tabStrings[" "].cloneNode(true));
          }
          return value.substr(cols);
        } else if (value[0] == "	") {
          for (var i = 0; i < cols; i++) {
            parent.appendChild(this.$tabStrings["	"].cloneNode(true));
          }
          return value.substr(cols);
        }
        return value;
      };
      this.$createLineElement = function(parent) {
        var lineEl = this.dom.createElement("div");
        lineEl.className = "ace_line";
        lineEl.style.height = this.config.lineHeight + "px";
        return lineEl;
      };
      this.$renderWrappedLine = function(parent, tokens, splits) {
        var chars = 0;
        var split2 = 0;
        var splitChars = splits[0];
        var screenColumn = 0;
        var lineEl = this.$createLineElement();
        parent.appendChild(lineEl);
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          var value = token.value;
          if (i == 0 && this.displayIndentGuides) {
            chars = value.length;
            value = this.renderIndentGuide(lineEl, value, splitChars);
            if (!value)
              continue;
            chars -= value.length;
          }
          if (chars + value.length < splitChars) {
            screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
            chars += value.length;
          } else {
            while (chars + value.length >= splitChars) {
              screenColumn = this.$renderToken(lineEl, screenColumn, token, value.substring(0, splitChars - chars));
              value = value.substring(splitChars - chars);
              chars = splitChars;
              lineEl = this.$createLineElement();
              parent.appendChild(lineEl);
              lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat("", splits.indent), this.element));
              split2++;
              screenColumn = 0;
              splitChars = splits[split2] || Number.MAX_VALUE;
            }
            if (value.length != 0) {
              chars += value.length;
              screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
            }
          }
        }
        if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
          this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
      };
      this.$renderSimpleLine = function(parent, tokens) {
        var screenColumn = 0;
        var token = tokens[0];
        var value = token.value;
        if (this.displayIndentGuides)
          value = this.renderIndentGuide(parent, value);
        if (value)
          screenColumn = this.$renderToken(parent, screenColumn, token, value);
        for (var i = 1; i < tokens.length; i++) {
          token = tokens[i];
          value = token.value;
          if (screenColumn + value.length > this.MAX_LINE_LENGTH)
            return this.$renderOverflowMessage(parent, screenColumn, token, value);
          screenColumn = this.$renderToken(parent, screenColumn, token, value);
        }
      };
      this.$renderOverflowMessage = function(parent, screenColumn, token, value, hide) {
        token && this.$renderToken(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
        var overflowEl = this.dom.createElement("span");
        overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
        overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
        parent.appendChild(overflowEl);
      };
      this.$renderLine = function(parent, row, foldLine2) {
        if (!foldLine2 && foldLine2 != false)
          foldLine2 = this.session.getFoldLine(row);
        if (foldLine2)
          var tokens = this.$getFoldLineTokens(row, foldLine2);
        else
          var tokens = this.session.getTokens(row);
        var lastLineEl = parent;
        if (tokens.length) {
          var splits = this.session.getRowSplitData(row);
          if (splits && splits.length) {
            this.$renderWrappedLine(parent, tokens, splits);
            var lastLineEl = parent.lastChild;
          } else {
            var lastLineEl = parent;
            if (this.$useLineGroups()) {
              lastLineEl = this.$createLineElement();
              parent.appendChild(lastLineEl);
            }
            this.$renderSimpleLine(lastLineEl, tokens);
          }
        } else if (this.$useLineGroups()) {
          lastLineEl = this.$createLineElement();
          parent.appendChild(lastLineEl);
        }
        if (this.showEOL && lastLineEl) {
          if (foldLine2)
            row = foldLine2.end.row;
          var invisibleEl = this.dom.createElement("span");
          invisibleEl.className = "ace_invisible ace_invisible_eol";
          invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
          lastLineEl.appendChild(invisibleEl);
        }
      };
      this.$getFoldLineTokens = function(row, foldLine2) {
        var session = this.session;
        var renderTokens = [];
        function addTokens(tokens2, from, to) {
          var idx = 0, col = 0;
          while (col + tokens2[idx].value.length < from) {
            col += tokens2[idx].value.length;
            idx++;
            if (idx == tokens2.length)
              return;
          }
          if (col != from) {
            var value = tokens2[idx].value.substring(from - col);
            if (value.length > to - from)
              value = value.substring(0, to - from);
            renderTokens.push({
              type: tokens2[idx].type,
              value
            });
            col = from + value.length;
            idx += 1;
          }
          while (col < to && idx < tokens2.length) {
            var value = tokens2[idx].value;
            if (value.length + col > to) {
              renderTokens.push({
                type: tokens2[idx].type,
                value: value.substring(0, to - col)
              });
            } else
              renderTokens.push(tokens2[idx]);
            col += value.length;
            idx += 1;
          }
        }
        var tokens = session.getTokens(row);
        foldLine2.walk(function(placeholder, row2, column, lastColumn, isNewRow) {
          if (placeholder != null) {
            renderTokens.push({
              type: "fold",
              value: placeholder
            });
          } else {
            if (isNewRow)
              tokens = session.getTokens(row2);
            if (tokens.length)
              addTokens(tokens, lastColumn, column);
          }
        }, foldLine2.end.row, this.session.getLine(foldLine2.end.row).length);
        return renderTokens;
      };
      this.$useLineGroups = function() {
        return this.session.getUseWrapMode();
      };
      this.destroy = function() {
      };
    }).call(Text.prototype);
    exports2.Text = Text;
  });
  ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
    var dom = require2("../lib/dom");
    var Cursor = function(parentEl) {
      this.element = dom.createElement("div");
      this.element.className = "ace_layer ace_cursor-layer";
      parentEl.appendChild(this.element);
      this.isVisible = false;
      this.isBlinking = true;
      this.blinkInterval = 1e3;
      this.smoothBlinking = false;
      this.cursors = [];
      this.cursor = this.addCursor();
      dom.addCssClass(this.element, "ace_hidden-cursors");
      this.$updateCursors = this.$updateOpacity.bind(this);
    };
    (function() {
      this.$updateOpacity = function(val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
          dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
      };
      this.$startCssAnimation = function() {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
          cursors[i].style.animationDuration = this.blinkInterval + "ms";
        setTimeout(function() {
          dom.addCssClass(this.element, "ace_animate-blinking");
        }.bind(this));
      };
      this.$stopCssAnimation = function() {
        dom.removeCssClass(this.element, "ace_animate-blinking");
      };
      this.$padding = 0;
      this.setPadding = function(padding) {
        this.$padding = padding;
      };
      this.setSession = function(session) {
        this.session = session;
      };
      this.setBlinking = function(blinking) {
        if (blinking != this.isBlinking) {
          this.isBlinking = blinking;
          this.restartTimer();
        }
      };
      this.setBlinkInterval = function(blinkInterval) {
        if (blinkInterval != this.blinkInterval) {
          this.blinkInterval = blinkInterval;
          this.restartTimer();
        }
      };
      this.setSmoothBlinking = function(smoothBlinking) {
        if (smoothBlinking != this.smoothBlinking) {
          this.smoothBlinking = smoothBlinking;
          dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
          this.$updateCursors(true);
          this.restartTimer();
        }
      };
      this.addCursor = function() {
        var el = dom.createElement("div");
        el.className = "ace_cursor";
        this.element.appendChild(el);
        this.cursors.push(el);
        return el;
      };
      this.removeCursor = function() {
        if (this.cursors.length > 1) {
          var el = this.cursors.pop();
          el.parentNode.removeChild(el);
          return el;
        }
      };
      this.hideCursor = function() {
        this.isVisible = false;
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
      };
      this.showCursor = function() {
        this.isVisible = true;
        dom.removeCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
      };
      this.restartTimer = function() {
        var update = this.$updateCursors;
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
        this.$stopCssAnimation();
        if (this.smoothBlinking) {
          dom.removeCssClass(this.element, "ace_smooth-blinking");
        }
        update(true);
        if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
          this.$stopCssAnimation();
          return;
        }
        if (this.smoothBlinking) {
          setTimeout(function() {
            dom.addCssClass(this.element, "ace_smooth-blinking");
          }.bind(this));
        }
        if (dom.HAS_CSS_ANIMATION) {
          this.$startCssAnimation();
        } else {
          var blink = function() {
            this.timeoutId = setTimeout(function() {
              update(false);
            }, 0.6 * this.blinkInterval);
          }.bind(this);
          this.intervalId = setInterval(function() {
            update(true);
            blink();
          }, this.blinkInterval);
          blink();
        }
      };
      this.getPixelPosition = function(position, onScreen) {
        if (!this.config || !this.session)
          return {left: 0, top: 0};
        if (!position)
          position = this.session.selection.getCursor();
        var pos = this.session.documentToScreenPosition(position);
        var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row) ? this.session.$bidiHandler.getPosLeft(pos.column) : pos.column * this.config.characterWidth);
        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
        return {left: cursorLeft, top: cursorTop};
      };
      this.isCursorInView = function(pixelPos, config) {
        return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
      };
      this.update = function(config) {
        this.config = config;
        var selections = this.session.$selectionMarkers;
        var i = 0, cursorIndex = 0;
        if (selections === void 0 || selections.length === 0) {
          selections = [{cursor: null}];
        }
        for (var i = 0, n2 = selections.length; i < n2; i++) {
          var pixelPos = this.getPixelPosition(selections[i].cursor, true);
          if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
            continue;
          }
          var element = this.cursors[cursorIndex++] || this.addCursor();
          var style = element.style;
          if (!this.drawCursor) {
            if (!this.isCursorInView(pixelPos, config)) {
              dom.setStyle(style, "display", "none");
            } else {
              dom.setStyle(style, "display", "block");
              dom.translate(element, pixelPos.left, pixelPos.top);
              dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
              dom.setStyle(style, "height", config.lineHeight + "px");
            }
          } else {
            this.drawCursor(element, pixelPos, config, selections[i], this.session);
          }
        }
        while (this.cursors.length > cursorIndex)
          this.removeCursor();
        var overwrite = this.session.getOverwrite();
        this.$setOverwrite(overwrite);
        this.$pixelPos = pixelPos;
        this.restartTimer();
      };
      this.drawCursor = null;
      this.$setOverwrite = function(overwrite) {
        if (overwrite != this.overwrite) {
          this.overwrite = overwrite;
          if (overwrite)
            dom.addCssClass(this.element, "ace_overwrite-cursors");
          else
            dom.removeCssClass(this.element, "ace_overwrite-cursors");
        }
      };
      this.destroy = function() {
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
      };
    }).call(Cursor.prototype);
    exports2.Cursor = Cursor;
  });
  ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var dom = require2("./lib/dom");
    var event = require2("./lib/event");
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var MAX_SCROLL_H = 32768;
    var ScrollBar = function(parent) {
      this.element = dom.createElement("div");
      this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;
      this.inner = dom.createElement("div");
      this.inner.className = "ace_scrollbar-inner";
      this.inner.textContent = "";
      this.element.appendChild(this.inner);
      parent.appendChild(this.element);
      this.setVisible(false);
      this.skipEvent = false;
      event.addListener(this.element, "scroll", this.onScroll.bind(this));
      event.addListener(this.element, "mousedown", event.preventDefault);
    };
    (function() {
      oop.implement(this, EventEmitter);
      this.setVisible = function(isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
        this.coeff = 1;
      };
    }).call(ScrollBar.prototype);
    var VScrollBar = function(parent, renderer) {
      ScrollBar.call(this, parent);
      this.scrollTop = 0;
      this.scrollHeight = 0;
      renderer.$scrollbarWidth = this.width = dom.scrollbarWidth(parent.ownerDocument);
      this.inner.style.width = this.element.style.width = (this.width || 15) + 5 + "px";
      this.$minWidth = 0;
    };
    oop.inherits(VScrollBar, ScrollBar);
    (function() {
      this.classSuffix = "-v";
      this.onScroll = function() {
        if (!this.skipEvent) {
          this.scrollTop = this.element.scrollTop;
          if (this.coeff != 1) {
            var h2 = this.element.clientHeight / this.scrollHeight;
            this.scrollTop = this.scrollTop * (1 - h2) / (this.coeff - h2);
          }
          this._emit("scroll", {data: this.scrollTop});
        }
        this.skipEvent = false;
      };
      this.getWidth = function() {
        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
      };
      this.setHeight = function(height) {
        this.element.style.height = height + "px";
      };
      this.setInnerHeight = this.setScrollHeight = function(height) {
        this.scrollHeight = height;
        if (height > MAX_SCROLL_H) {
          this.coeff = MAX_SCROLL_H / height;
          height = MAX_SCROLL_H;
        } else if (this.coeff != 1) {
          this.coeff = 1;
        }
        this.inner.style.height = height + "px";
      };
      this.setScrollTop = function(scrollTop) {
        if (this.scrollTop != scrollTop) {
          this.skipEvent = true;
          this.scrollTop = scrollTop;
          this.element.scrollTop = scrollTop * this.coeff;
        }
      };
    }).call(VScrollBar.prototype);
    var HScrollBar = function(parent, renderer) {
      ScrollBar.call(this, parent);
      this.scrollLeft = 0;
      this.height = renderer.$scrollbarWidth;
      this.inner.style.height = this.element.style.height = (this.height || 15) + 5 + "px";
    };
    oop.inherits(HScrollBar, ScrollBar);
    (function() {
      this.classSuffix = "-h";
      this.onScroll = function() {
        if (!this.skipEvent) {
          this.scrollLeft = this.element.scrollLeft;
          this._emit("scroll", {data: this.scrollLeft});
        }
        this.skipEvent = false;
      };
      this.getHeight = function() {
        return this.isVisible ? this.height : 0;
      };
      this.setWidth = function(width) {
        this.element.style.width = width + "px";
      };
      this.setInnerWidth = function(width) {
        this.inner.style.width = width + "px";
      };
      this.setScrollWidth = function(width) {
        this.inner.style.width = width + "px";
      };
      this.setScrollLeft = function(scrollLeft) {
        if (this.scrollLeft != scrollLeft) {
          this.skipEvent = true;
          this.scrollLeft = this.element.scrollLeft = scrollLeft;
        }
      };
    }).call(HScrollBar.prototype);
    exports2.ScrollBar = VScrollBar;
    exports2.ScrollBarV = VScrollBar;
    exports2.ScrollBarH = HScrollBar;
    exports2.VScrollBar = VScrollBar;
    exports2.HScrollBar = HScrollBar;
  });
  ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function(require2, exports2, module2) {
    var event = require2("./lib/event");
    var RenderLoop = function(onRender, win) {
      this.onRender = onRender;
      this.pending = false;
      this.changes = 0;
      this.$recursionLimit = 2;
      this.window = win || window;
      var _self = this;
      this._flush = function(ts) {
        _self.pending = false;
        var changes = _self.changes;
        if (changes) {
          event.blockIdle(100);
          _self.changes = 0;
          _self.onRender(changes);
        }
        if (_self.changes) {
          if (_self.$recursionLimit-- < 0)
            return;
          _self.schedule();
        } else {
          _self.$recursionLimit = 2;
        }
      };
    };
    (function() {
      this.schedule = function(change) {
        this.changes = this.changes | change;
        if (this.changes && !this.pending) {
          event.nextFrame(this._flush);
          this.pending = true;
        }
      };
      this.clear = function(change) {
        var changes = this.changes;
        this.changes = 0;
        return changes;
      };
    }).call(RenderLoop.prototype);
    exports2.RenderLoop = RenderLoop;
  });
  ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/event", "ace/lib/useragent", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var dom = require2("../lib/dom");
    var lang = require2("../lib/lang");
    var event = require2("../lib/event");
    var useragent = require2("../lib/useragent");
    var EventEmitter = require2("../lib/event_emitter").EventEmitter;
    var CHAR_COUNT = 256;
    var USE_OBSERVER = typeof ResizeObserver == "function";
    var L = 200;
    var FontMetrics = exports2.FontMetrics = function(parentEl) {
      this.el = dom.createElement("div");
      this.$setMeasureNodeStyles(this.el.style, true);
      this.$main = dom.createElement("div");
      this.$setMeasureNodeStyles(this.$main.style);
      this.$measureNode = dom.createElement("div");
      this.$setMeasureNodeStyles(this.$measureNode.style);
      this.el.appendChild(this.$main);
      this.el.appendChild(this.$measureNode);
      parentEl.appendChild(this.el);
      this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);
      this.$characterSize = {width: 0, height: 0};
      if (USE_OBSERVER)
        this.$addObserver();
      else
        this.checkForSizeChanges();
    };
    (function() {
      oop.implement(this, EventEmitter);
      this.$characterSize = {width: 0, height: 0};
      this.$setMeasureNodeStyles = function(style, isRoot) {
        style.width = style.height = "auto";
        style.left = style.top = "0px";
        style.visibility = "hidden";
        style.position = "absolute";
        style.whiteSpace = "pre";
        if (useragent.isIE < 8) {
          style["font-family"] = "inherit";
        } else {
          style.font = "inherit";
        }
        style.overflow = isRoot ? "hidden" : "visible";
      };
      this.checkForSizeChanges = function(size) {
        if (size === void 0)
          size = this.$measureSizes();
        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
          this.$measureNode.style.fontWeight = "bold";
          var boldSize = this.$measureSizes();
          this.$measureNode.style.fontWeight = "";
          this.$characterSize = size;
          this.charSizes = Object.create(null);
          this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
          this._emit("changeCharacterSize", {data: size});
        }
      };
      this.$addObserver = function() {
        var self2 = this;
        this.$observer = new window.ResizeObserver(function(e2) {
          self2.checkForSizeChanges();
        });
        this.$observer.observe(this.$measureNode);
      };
      this.$pollSizeChanges = function() {
        if (this.$pollSizeChangesTimer || this.$observer)
          return this.$pollSizeChangesTimer;
        var self2 = this;
        return this.$pollSizeChangesTimer = event.onIdle(function cb2() {
          self2.checkForSizeChanges();
          event.onIdle(cb2, 500);
        }, 500);
      };
      this.setPolling = function(val) {
        if (val) {
          this.$pollSizeChanges();
        } else if (this.$pollSizeChangesTimer) {
          clearInterval(this.$pollSizeChangesTimer);
          this.$pollSizeChangesTimer = 0;
        }
      };
      this.$measureSizes = function(node) {
        var size = {
          height: (node || this.$measureNode).clientHeight,
          width: (node || this.$measureNode).clientWidth / CHAR_COUNT
        };
        if (size.width === 0 || size.height === 0)
          return null;
        return size;
      };
      this.$measureCharWidth = function(ch2) {
        this.$main.textContent = lang.stringRepeat(ch2, CHAR_COUNT);
        var rect = this.$main.getBoundingClientRect();
        return rect.width / CHAR_COUNT;
      };
      this.getCharacterWidth = function(ch2) {
        var w2 = this.charSizes[ch2];
        if (w2 === void 0) {
          w2 = this.charSizes[ch2] = this.$measureCharWidth(ch2) / this.$characterSize.width;
        }
        return w2;
      };
      this.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.$observer)
          this.$observer.disconnect();
        if (this.el && this.el.parentNode)
          this.el.parentNode.removeChild(this.el);
      };
      this.$getZoom = function getZoom(element) {
        if (!element || !element.parentElement)
          return 1;
        return (window.getComputedStyle(element).zoom || 1) * getZoom(element.parentElement);
      };
      this.$initTransformMeasureNodes = function() {
        var t2 = function(t3, l2) {
          return ["div", {
            style: "position: absolute;top:" + t3 + "px;left:" + l2 + "px;"
          }];
        };
        this.els = dom.buildDom([t2(0, 0), t2(L, 0), t2(0, L), t2(L, L)], this.el);
      };
      this.transformCoordinates = function(clientPos, elPos) {
        if (clientPos) {
          var zoom = this.$getZoom(this.el);
          clientPos = mul(1 / zoom, clientPos);
        }
        function solve(l1, l2, r2) {
          var det = l1[1] * l2[0] - l1[0] * l2[1];
          return [
            (-l2[1] * r2[0] + l2[0] * r2[1]) / det,
            (+l1[1] * r2[0] - l1[0] * r2[1]) / det
          ];
        }
        function sub(a2, b3) {
          return [a2[0] - b3[0], a2[1] - b3[1]];
        }
        function add(a2, b3) {
          return [a2[0] + b3[0], a2[1] + b3[1]];
        }
        function mul(a2, b3) {
          return [a2 * b3[0], a2 * b3[1]];
        }
        if (!this.els)
          this.$initTransformMeasureNodes();
        function p2(el) {
          var r2 = el.getBoundingClientRect();
          return [r2.left, r2.top];
        }
        var a = p2(this.els[0]);
        var b2 = p2(this.els[1]);
        var c2 = p2(this.els[2]);
        var d2 = p2(this.els[3]);
        var h2 = solve(sub(d2, b2), sub(d2, c2), sub(add(b2, c2), add(d2, a)));
        var m1 = mul(1 + h2[0], sub(b2, a));
        var m2 = mul(1 + h2[1], sub(c2, a));
        if (elPos) {
          var x2 = elPos;
          var k2 = h2[0] * x2[0] / L + h2[1] * x2[1] / L + 1;
          var ut = add(mul(x2[0], m1), mul(x2[1], m2));
          return add(mul(1 / k2 / L, ut), a);
        }
        var u = sub(clientPos, a);
        var f2 = solve(sub(m1, mul(h2[0], u)), sub(m2, mul(h2[1], u)), u);
        return mul(L, f2);
      };
    }).call(FontMetrics.prototype);
  });
  ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/config", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter", "ace/lib/useragent"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var dom = require2("./lib/dom");
    var config = require2("./config");
    var GutterLayer = require2("./layer/gutter").Gutter;
    var MarkerLayer = require2("./layer/marker").Marker;
    var TextLayer = require2("./layer/text").Text;
    var CursorLayer = require2("./layer/cursor").Cursor;
    var HScrollBar = require2("./scrollbar").HScrollBar;
    var VScrollBar = require2("./scrollbar").VScrollBar;
    var RenderLoop = require2("./renderloop").RenderLoop;
    var FontMetrics = require2("./layer/font_metrics").FontMetrics;
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var editorCss = `.ace_br1 {border-top-left-radius    : 3px;}.ace_br2 {border-top-right-radius   : 3px;}.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}.ace_br4 {border-bottom-right-radius: 3px;}.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}.ace_br8 {border-bottom-left-radius : 3px;}.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}.ace_editor {position: relative;overflow: hidden;padding: 0;font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;direction: ltr;text-align: left;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);}.ace_scroller {position: absolute;overflow: hidden;top: 0;bottom: 0;background-color: inherit;-ms-user-select: none;-moz-user-select: none;-webkit-user-select: none;user-select: none;cursor: text;}.ace_content {position: absolute;box-sizing: border-box;min-width: 100%;contain: style size layout;font-variant-ligatures: no-common-ligatures;}.ace_dragging .ace_scroller:before{position: absolute;top: 0;left: 0;right: 0;bottom: 0;content: '';background: rgba(250, 250, 250, 0.01);z-index: 1000;}.ace_dragging.ace_dark .ace_scroller:before{background: rgba(0, 0, 0, 0.01);}.ace_selecting, .ace_selecting * {cursor: text !important;}.ace_gutter {position: absolute;overflow : hidden;width: auto;top: 0;bottom: 0;left: 0;cursor: default;z-index: 4;-ms-user-select: none;-moz-user-select: none;-webkit-user-select: none;user-select: none;contain: style size layout;}.ace_gutter-active-line {position: absolute;left: 0;right: 0;}.ace_scroller.ace_scroll-left {box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;}.ace_gutter-cell {position: absolute;top: 0;left: 0;right: 0;padding-left: 19px;padding-right: 6px;background-repeat: no-repeat;}.ace_gutter-cell.ace_error {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");background-repeat: no-repeat;background-position: 2px center;}.ace_gutter-cell.ace_warning {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");background-position: 2px center;}.ace_gutter-cell.ace_info {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");background-position: 2px center;}.ace_dark .ace_gutter-cell.ace_info {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");}.ace_scrollbar {contain: strict;position: absolute;right: 0;bottom: 0;z-index: 6;}.ace_scrollbar-inner {position: absolute;cursor: text;left: 0;top: 0;}.ace_scrollbar-v{overflow-x: hidden;overflow-y: scroll;top: 0;}.ace_scrollbar-h {overflow-x: scroll;overflow-y: hidden;left: 0;}.ace_print-margin {position: absolute;height: 100%;}.ace_text-input {position: absolute;z-index: 0;width: 0.5em;height: 1em;opacity: 0;background: transparent;-moz-appearance: none;appearance: none;border: none;resize: none;outline: none;overflow: hidden;font: inherit;padding: 0 1px;margin: 0 -1px;contain: strict;-ms-user-select: text;-moz-user-select: text;-webkit-user-select: text;user-select: text;white-space: pre!important;}.ace_text-input.ace_composition {background: transparent;color: inherit;z-index: 1000;opacity: 1;}.ace_composition_placeholder { color: transparent }.ace_composition_marker { border-bottom: 1px solid;position: absolute;border-radius: 0;margin-top: 1px;}[ace_nocontext=true] {transform: none!important;filter: none!important;clip-path: none!important;mask : none!important;contain: none!important;perspective: none!important;mix-blend-mode: initial!important;z-index: auto;}.ace_layer {z-index: 1;position: absolute;overflow: hidden;word-wrap: normal;white-space: pre;height: 100%;width: 100%;box-sizing: border-box;pointer-events: none;}.ace_gutter-layer {position: relative;width: auto;text-align: right;pointer-events: auto;height: 1000000px;contain: style size layout;}.ace_text-layer {font: inherit !important;position: absolute;height: 1000000px;width: 1000000px;contain: style size layout;}.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {contain: style size layout;position: absolute;top: 0;left: 0;right: 0;}.ace_hidpi .ace_text-layer,.ace_hidpi .ace_gutter-layer,.ace_hidpi .ace_content,.ace_hidpi .ace_gutter {contain: strict;will-change: transform;}.ace_hidpi .ace_text-layer > .ace_line, .ace_hidpi .ace_text-layer > .ace_line_group {contain: strict;}.ace_cjk {display: inline-block;text-align: center;}.ace_cursor-layer {z-index: 4;}.ace_cursor {z-index: 4;position: absolute;box-sizing: border-box;border-left: 2px solid;transform: translatez(0);}.ace_multiselect .ace_cursor {border-left-width: 1px;}.ace_slim-cursors .ace_cursor {border-left-width: 1px;}.ace_overwrite-cursors .ace_cursor {border-left-width: 0;border-bottom: 1px solid;}.ace_hidden-cursors .ace_cursor {opacity: 0.2;}.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {opacity: 0;}.ace_smooth-blinking .ace_cursor {transition: opacity 0.18s;}.ace_animate-blinking .ace_cursor {animation-duration: 1000ms;animation-timing-function: step-end;animation-name: blink-ace-animate;animation-iteration-count: infinite;}.ace_animate-blinking.ace_smooth-blinking .ace_cursor {animation-duration: 1000ms;animation-timing-function: ease-in-out;animation-name: blink-ace-animate-smooth;}@keyframes blink-ace-animate {from, to { opacity: 1; }60% { opacity: 0; }}@keyframes blink-ace-animate-smooth {from, to { opacity: 1; }45% { opacity: 1; }60% { opacity: 0; }85% { opacity: 0; }}.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {position: absolute;z-index: 3;}.ace_marker-layer .ace_selection {position: absolute;z-index: 5;}.ace_marker-layer .ace_bracket {position: absolute;z-index: 6;}.ace_marker-layer .ace_error_bracket {position: absolute;border-bottom: 1px solid #DE5555;border-radius: 0;}.ace_marker-layer .ace_active-line {position: absolute;z-index: 2;}.ace_marker-layer .ace_selected-word {position: absolute;z-index: 4;box-sizing: border-box;}.ace_line .ace_fold {box-sizing: border-box;display: inline-block;height: 11px;margin-top: -2px;vertical-align: middle;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");background-repeat: no-repeat, repeat-x;background-position: center center, top left;color: transparent;border: 1px solid black;border-radius: 2px;cursor: pointer;pointer-events: auto;}.ace_dark .ace_fold {}.ace_fold:hover{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");}.ace_tooltip {background-color: #FFF;background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));border: 1px solid gray;border-radius: 1px;box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);color: black;max-width: 100%;padding: 3px 4px;position: fixed;z-index: 999999;box-sizing: border-box;cursor: default;white-space: pre;word-wrap: break-word;line-height: normal;font-style: normal;font-weight: normal;letter-spacing: normal;pointer-events: none;}.ace_folding-enabled > .ace_gutter-cell {padding-right: 13px;}.ace_fold-widget {box-sizing: border-box;margin: 0 -12px 0 1px;display: none;width: 11px;vertical-align: top;background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");background-repeat: no-repeat;background-position: center;border-radius: 3px;border: 1px solid transparent;cursor: pointer;}.ace_folding-enabled .ace_fold-widget {display: inline-block;   }.ace_fold-widget.ace_end {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");}.ace_fold-widget.ace_closed {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");}.ace_fold-widget:hover {border: 1px solid rgba(0, 0, 0, 0.3);background-color: rgba(255, 255, 255, 0.2);box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);}.ace_fold-widget:active {border: 1px solid rgba(0, 0, 0, 0.4);background-color: rgba(0, 0, 0, 0.05);box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);}.ace_dark .ace_fold-widget {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");}.ace_dark .ace_fold-widget.ace_end {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");}.ace_dark .ace_fold-widget.ace_closed {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");}.ace_dark .ace_fold-widget:hover {box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);background-color: rgba(255, 255, 255, 0.1);}.ace_dark .ace_fold-widget:active {box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);}.ace_inline_button {border: 1px solid lightgray;display: inline-block;margin: -1px 8px;padding: 0 5px;pointer-events: auto;cursor: pointer;}.ace_inline_button:hover {border-color: gray;background: rgba(200,200,200,0.2);display: inline-block;pointer-events: auto;}.ace_fold-widget.ace_invalid {background-color: #FFB4B4;border-color: #DE5555;}.ace_fade-fold-widgets .ace_fold-widget {transition: opacity 0.4s ease 0.05s;opacity: 0;}.ace_fade-fold-widgets:hover .ace_fold-widget {transition: opacity 0.05s ease 0.05s;opacity:1;}.ace_underline {text-decoration: underline;}.ace_bold {font-weight: bold;}.ace_nobold .ace_bold {font-weight: normal;}.ace_italic {font-style: italic;}.ace_error-marker {background-color: rgba(255, 0, 0,0.2);position: absolute;z-index: 9;}.ace_highlight-marker {background-color: rgba(255, 255, 0,0.2);position: absolute;z-index: 8;}.ace_mobile-menu {position: absolute;line-height: 1.5;border-radius: 4px;-ms-user-select: none;-moz-user-select: none;-webkit-user-select: none;user-select: none;background: white;box-shadow: 1px 3px 2px grey;border: 1px solid #dcdcdc;color: black;}.ace_dark > .ace_mobile-menu {background: #333;color: #ccc;box-shadow: 1px 3px 2px grey;border: 1px solid #444;}.ace_mobile-button {padding: 2px;cursor: pointer;overflow: hidden;}.ace_mobile-button:hover {background-color: #eee;opacity:1;}.ace_mobile-button:active {background-color: #ddd;}.ace_placeholder {font-family: arial;transform: scale(0.9);transform-origin: left;white-space: pre;opacity: 0.7;margin: 0 10px;}`;
    var useragent = require2("./lib/useragent");
    var HIDE_TEXTAREA = useragent.isIE;
    dom.importCssString(editorCss, "ace_editor.css");
    var VirtualRenderer = function(container, theme) {
      var _self = this;
      this.container = container || dom.createElement("div");
      dom.addCssClass(this.container, "ace_editor");
      if (dom.HI_DPI)
        dom.addCssClass(this.container, "ace_hidpi");
      this.setTheme(theme);
      this.$gutter = dom.createElement("div");
      this.$gutter.className = "ace_gutter";
      this.container.appendChild(this.$gutter);
      this.$gutter.setAttribute("aria-hidden", true);
      this.scroller = dom.createElement("div");
      this.scroller.className = "ace_scroller";
      this.container.appendChild(this.scroller);
      this.content = dom.createElement("div");
      this.content.className = "ace_content";
      this.scroller.appendChild(this.content);
      this.$gutterLayer = new GutterLayer(this.$gutter);
      this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
      this.$markerBack = new MarkerLayer(this.content);
      var textLayer = this.$textLayer = new TextLayer(this.content);
      this.canvas = textLayer.element;
      this.$markerFront = new MarkerLayer(this.content);
      this.$cursorLayer = new CursorLayer(this.content);
      this.$horizScroll = false;
      this.$vScroll = false;
      this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
      this.scrollBarH = new HScrollBar(this.container, this);
      this.scrollBarV.on("scroll", function(e2) {
        if (!_self.$scrollAnimation)
          _self.session.setScrollTop(e2.data - _self.scrollMargin.top);
      });
      this.scrollBarH.on("scroll", function(e2) {
        if (!_self.$scrollAnimation)
          _self.session.setScrollLeft(e2.data - _self.scrollMargin.left);
      });
      this.scrollTop = 0;
      this.scrollLeft = 0;
      this.cursorPos = {
        row: 0,
        column: 0
      };
      this.$fontMetrics = new FontMetrics(this.container);
      this.$textLayer.$setFontMetrics(this.$fontMetrics);
      this.$textLayer.on("changeCharacterSize", function(e2) {
        _self.updateCharacterSize();
        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
        _self._signal("changeCharacterSize", e2);
      });
      this.$size = {
        width: 0,
        height: 0,
        scrollerHeight: 0,
        scrollerWidth: 0,
        $dirty: true
      };
      this.layerConfig = {
        width: 1,
        padding: 0,
        firstRow: 0,
        firstRowScreen: 0,
        lastRow: 0,
        lineHeight: 0,
        characterWidth: 0,
        minHeight: 1,
        maxHeight: 1,
        offset: 0,
        height: 1,
        gutterOffset: 1
      };
      this.scrollMargin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
      };
      this.margin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
      };
      this.$keepTextAreaAtCursor = !useragent.isIOS;
      this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
      this.$loop.schedule(this.CHANGE_FULL);
      this.updateCharacterSize();
      this.setPadding(4);
      config.resetOptions(this);
      config._signal("renderer", this);
    };
    (function() {
      this.CHANGE_CURSOR = 1;
      this.CHANGE_MARKER = 2;
      this.CHANGE_GUTTER = 4;
      this.CHANGE_SCROLL = 8;
      this.CHANGE_LINES = 16;
      this.CHANGE_TEXT = 32;
      this.CHANGE_SIZE = 64;
      this.CHANGE_MARKER_BACK = 128;
      this.CHANGE_MARKER_FRONT = 256;
      this.CHANGE_FULL = 512;
      this.CHANGE_H_SCROLL = 1024;
      oop.implement(this, EventEmitter);
      this.updateCharacterSize = function() {
        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
          this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
          this.setStyle("ace_nobold", !this.$allowBoldFonts);
        }
        this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
        this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
        this.$updatePrintMargin();
        dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
      };
      this.setSession = function(session) {
        if (this.session)
          this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
        this.session = session;
        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
          session.setScrollTop(-this.scrollMargin.top);
        this.$cursorLayer.setSession(session);
        this.$markerBack.setSession(session);
        this.$markerFront.setSession(session);
        this.$gutterLayer.setSession(session);
        this.$textLayer.setSession(session);
        if (!session)
          return;
        this.$loop.schedule(this.CHANGE_FULL);
        this.session.$setFontMetrics(this.$fontMetrics);
        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
        this.onChangeNewLineMode();
        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
      };
      this.updateLines = function(firstRow, lastRow, force) {
        if (lastRow === void 0)
          lastRow = Infinity;
        if (!this.$changedLines) {
          this.$changedLines = {
            firstRow,
            lastRow
          };
        } else {
          if (this.$changedLines.firstRow > firstRow)
            this.$changedLines.firstRow = firstRow;
          if (this.$changedLines.lastRow < lastRow)
            this.$changedLines.lastRow = lastRow;
        }
        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
          if (force)
            this.$changedLines.lastRow = this.layerConfig.lastRow;
          else
            return;
        }
        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
          return;
        this.$loop.schedule(this.CHANGE_LINES);
      };
      this.onChangeNewLineMode = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
        this.$textLayer.$updateEolChar();
        this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
      };
      this.onChangeTabSize = function() {
        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
        this.$textLayer.onChangeTabSize();
      };
      this.updateText = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
      };
      this.updateFull = function(force) {
        if (force)
          this.$renderChanges(this.CHANGE_FULL, true);
        else
          this.$loop.schedule(this.CHANGE_FULL);
      };
      this.updateFontSize = function() {
        this.$textLayer.checkForSizeChanges();
      };
      this.$changes = 0;
      this.$updateSizeAsync = function() {
        if (this.$loop.pending)
          this.$size.$dirty = true;
        else
          this.onResize();
      };
      this.onResize = function(force, gutterWidth, width, height) {
        if (this.resizing > 2)
          return;
        else if (this.resizing > 0)
          this.resizing++;
        else
          this.resizing = force ? 1 : 0;
        var el = this.container;
        if (!height)
          height = el.clientHeight || el.scrollHeight;
        if (!width)
          width = el.clientWidth || el.scrollWidth;
        var changes = this.$updateCachedSize(force, gutterWidth, width, height);
        if (!this.$size.scrollerHeight || !width && !height)
          return this.resizing = 0;
        if (force)
          this.$gutterLayer.$padding = null;
        if (force)
          this.$renderChanges(changes | this.$changes, true);
        else
          this.$loop.schedule(changes | this.$changes);
        if (this.resizing)
          this.resizing = 0;
        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
      };
      this.$updateCachedSize = function(force, gutterWidth, width, height) {
        height -= this.$extraHeight || 0;
        var changes = 0;
        var size = this.$size;
        var oldSize = {
          width: size.width,
          height: size.height,
          scrollerHeight: size.scrollerHeight,
          scrollerWidth: size.scrollerWidth
        };
        if (height && (force || size.height != height)) {
          size.height = height;
          changes |= this.CHANGE_SIZE;
          size.scrollerHeight = size.height;
          if (this.$horizScroll)
            size.scrollerHeight -= this.scrollBarH.getHeight();
          this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
          changes = changes | this.CHANGE_SCROLL;
        }
        if (width && (force || size.width != width)) {
          changes |= this.CHANGE_SIZE;
          size.width = width;
          if (gutterWidth == null)
            gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
          this.gutterWidth = gutterWidth;
          dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
          dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
          size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
          dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
          var right = this.scrollBarV.getWidth() + "px";
          dom.setStyle(this.scrollBarH.element.style, "right", right);
          dom.setStyle(this.scroller.style, "right", right);
          dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());
          if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
            changes |= this.CHANGE_FULL;
          }
        }
        size.$dirty = !width || !height;
        if (changes)
          this._signal("resize", oldSize);
        return changes;
      };
      this.onGutterResize = function(width) {
        var gutterWidth = this.$showGutter ? width : 0;
        if (gutterWidth != this.gutterWidth)
          this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
          this.$loop.schedule(this.CHANGE_FULL);
        } else if (this.$size.$dirty) {
          this.$loop.schedule(this.CHANGE_FULL);
        } else {
          this.$computeLayerConfig();
        }
      };
      this.adjustWrapLimit = function() {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth);
        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
      };
      this.setAnimatedScroll = function(shouldAnimate) {
        this.setOption("animatedScroll", shouldAnimate);
      };
      this.getAnimatedScroll = function() {
        return this.$animatedScroll;
      };
      this.setShowInvisibles = function(showInvisibles) {
        this.setOption("showInvisibles", showInvisibles);
        this.session.$bidiHandler.setShowInvisibles(showInvisibles);
      };
      this.getShowInvisibles = function() {
        return this.getOption("showInvisibles");
      };
      this.getDisplayIndentGuides = function() {
        return this.getOption("displayIndentGuides");
      };
      this.setDisplayIndentGuides = function(display) {
        this.setOption("displayIndentGuides", display);
      };
      this.setShowPrintMargin = function(showPrintMargin) {
        this.setOption("showPrintMargin", showPrintMargin);
      };
      this.getShowPrintMargin = function() {
        return this.getOption("showPrintMargin");
      };
      this.setPrintMarginColumn = function(showPrintMargin) {
        this.setOption("printMarginColumn", showPrintMargin);
      };
      this.getPrintMarginColumn = function() {
        return this.getOption("printMarginColumn");
      };
      this.getShowGutter = function() {
        return this.getOption("showGutter");
      };
      this.setShowGutter = function(show) {
        return this.setOption("showGutter", show);
      };
      this.getFadeFoldWidgets = function() {
        return this.getOption("fadeFoldWidgets");
      };
      this.setFadeFoldWidgets = function(show) {
        this.setOption("fadeFoldWidgets", show);
      };
      this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
      };
      this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
      };
      this.$updatePrintMargin = function() {
        if (!this.$showPrintMargin && !this.$printMarginEl)
          return;
        if (!this.$printMarginEl) {
          var containerEl = dom.createElement("div");
          containerEl.className = "ace_layer ace_print-margin-layer";
          this.$printMarginEl = dom.createElement("div");
          this.$printMarginEl.className = "ace_print-margin";
          containerEl.appendChild(this.$printMarginEl);
          this.content.insertBefore(containerEl, this.content.firstChild);
        }
        var style = this.$printMarginEl.style;
        style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
        if (this.session && this.session.$wrap == -1)
          this.adjustWrapLimit();
      };
      this.getContainerElement = function() {
        return this.container;
      };
      this.getMouseEventTarget = function() {
        return this.scroller;
      };
      this.getTextAreaContainer = function() {
        return this.container;
      };
      this.$moveTextAreaToCursor = function() {
        if (this.$isMousePressed)
          return;
        var style = this.textarea.style;
        var composition = this.$composition;
        if (!this.$keepTextAreaAtCursor && !composition) {
          dom.translate(this.textarea, -100, 0);
          return;
        }
        var pixelPos = this.$cursorLayer.$pixelPos;
        if (!pixelPos)
          return;
        if (composition && composition.markerRange)
          pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
        var config2 = this.layerConfig;
        var posTop = pixelPos.top;
        var posLeft = pixelPos.left;
        posTop -= config2.offset;
        var h2 = composition && composition.useTextareaForIME ? this.lineHeight : HIDE_TEXTAREA ? 0 : 1;
        if (posTop < 0 || posTop > config2.height - h2) {
          dom.translate(this.textarea, 0, 0);
          return;
        }
        var w2 = 1;
        var maxTop = this.$size.height - h2;
        if (!composition) {
          posTop += this.lineHeight;
        } else {
          if (composition.useTextareaForIME) {
            var val = this.textarea.value;
            w2 = this.characterWidth * this.session.$getStringScreenWidth(val)[0];
          } else {
            posTop += this.lineHeight + 2;
          }
        }
        posLeft -= this.scrollLeft;
        if (posLeft > this.$size.scrollerWidth - w2)
          posLeft = this.$size.scrollerWidth - w2;
        posLeft += this.gutterWidth + this.margin.left;
        dom.setStyle(style, "height", h2 + "px");
        dom.setStyle(style, "width", w2 + "px");
        dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w2), Math.min(posTop, maxTop));
      };
      this.getFirstVisibleRow = function() {
        return this.layerConfig.firstRow;
      };
      this.getFirstFullyVisibleRow = function() {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
      };
      this.getLastFullyVisibleRow = function() {
        var config2 = this.layerConfig;
        var lastRow = config2.lastRow;
        var top = this.session.documentToScreenRow(lastRow, 0) * config2.lineHeight;
        if (top - this.session.getScrollTop() > config2.height - config2.lineHeight)
          return lastRow - 1;
        return lastRow;
      };
      this.getLastVisibleRow = function() {
        return this.layerConfig.lastRow;
      };
      this.$padding = null;
      this.setPadding = function(padding) {
        this.$padding = padding;
        this.$textLayer.setPadding(padding);
        this.$cursorLayer.setPadding(padding);
        this.$markerFront.setPadding(padding);
        this.$markerBack.setPadding(padding);
        this.$loop.schedule(this.CHANGE_FULL);
        this.$updatePrintMargin();
      };
      this.setScrollMargin = function(top, bottom, left, right) {
        var sm = this.scrollMargin;
        sm.top = top | 0;
        sm.bottom = bottom | 0;
        sm.right = right | 0;
        sm.left = left | 0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        if (sm.top && this.scrollTop <= 0 && this.session)
          this.session.setScrollTop(-sm.top);
        this.updateFull();
      };
      this.setMargin = function(top, bottom, left, right) {
        var sm = this.margin;
        sm.top = top | 0;
        sm.bottom = bottom | 0;
        sm.right = right | 0;
        sm.left = left | 0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
        this.updateFull();
      };
      this.getHScrollBarAlwaysVisible = function() {
        return this.$hScrollBarAlwaysVisible;
      };
      this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
      };
      this.getVScrollBarAlwaysVisible = function() {
        return this.$vScrollBarAlwaysVisible;
      };
      this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
      };
      this.$updateScrollBarV = function() {
        var scrollHeight = this.layerConfig.maxHeight;
        var scrollerHeight = this.$size.scrollerHeight;
        if (!this.$maxLines && this.$scrollPastEnd) {
          scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
          if (this.scrollTop > scrollHeight - scrollerHeight) {
            scrollHeight = this.scrollTop + scrollerHeight;
            this.scrollBarV.scrollTop = null;
          }
        }
        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
      };
      this.$updateScrollBarH = function() {
        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
      };
      this.$frozen = false;
      this.freeze = function() {
        this.$frozen = true;
      };
      this.unfreeze = function() {
        this.$frozen = false;
      };
      this.$renderChanges = function(changes, force) {
        if (this.$changes) {
          changes |= this.$changes;
          this.$changes = 0;
        }
        if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
          this.$changes |= changes;
          return;
        }
        if (this.$size.$dirty) {
          this.$changes |= changes;
          return this.onResize(true);
        }
        if (!this.lineHeight) {
          this.$textLayer.checkForSizeChanges();
        }
        this._signal("beforeRender", changes);
        if (this.session && this.session.$bidiHandler)
          this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
        var config2 = this.layerConfig;
        if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
          changes |= this.$computeLayerConfig() | this.$loop.clear();
          if (config2.firstRow != this.layerConfig.firstRow && config2.firstRowScreen == this.layerConfig.firstRowScreen) {
            var st = this.scrollTop + (config2.firstRow - this.layerConfig.firstRow) * this.lineHeight;
            if (st > 0) {
              this.scrollTop = st;
              changes = changes | this.CHANGE_SCROLL;
              changes |= this.$computeLayerConfig() | this.$loop.clear();
            }
          }
          config2 = this.layerConfig;
          this.$updateScrollBarV();
          if (changes & this.CHANGE_H_SCROLL)
            this.$updateScrollBarH();
          dom.translate(this.content, -this.scrollLeft, -config2.offset);
          var width = config2.width + 2 * this.$padding + "px";
          var height = config2.minHeight + "px";
          dom.setStyle(this.content.style, "width", width);
          dom.setStyle(this.content.style, "height", height);
        }
        if (changes & this.CHANGE_H_SCROLL) {
          dom.translate(this.content, -this.scrollLeft, -config2.offset);
          this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
        }
        if (changes & this.CHANGE_FULL) {
          this.$changedLines = null;
          this.$textLayer.update(config2);
          if (this.$showGutter)
            this.$gutterLayer.update(config2);
          this.$markerBack.update(config2);
          this.$markerFront.update(config2);
          this.$cursorLayer.update(config2);
          this.$moveTextAreaToCursor();
          this._signal("afterRender", changes);
          return;
        }
        if (changes & this.CHANGE_SCROLL) {
          this.$changedLines = null;
          if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
            this.$textLayer.update(config2);
          else
            this.$textLayer.scrollLines(config2);
          if (this.$showGutter) {
            if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
              this.$gutterLayer.update(config2);
            else
              this.$gutterLayer.scrollLines(config2);
          }
          this.$markerBack.update(config2);
          this.$markerFront.update(config2);
          this.$cursorLayer.update(config2);
          this.$moveTextAreaToCursor();
          this._signal("afterRender", changes);
          return;
        }
        if (changes & this.CHANGE_TEXT) {
          this.$changedLines = null;
          this.$textLayer.update(config2);
          if (this.$showGutter)
            this.$gutterLayer.update(config2);
        } else if (changes & this.CHANGE_LINES) {
          if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter)
            this.$gutterLayer.update(config2);
        } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
          if (this.$showGutter)
            this.$gutterLayer.update(config2);
        } else if (changes & this.CHANGE_CURSOR) {
          if (this.$highlightGutterLine)
            this.$gutterLayer.updateLineHighlight(config2);
        }
        if (changes & this.CHANGE_CURSOR) {
          this.$cursorLayer.update(config2);
          this.$moveTextAreaToCursor();
        }
        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
          this.$markerFront.update(config2);
        }
        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
          this.$markerBack.update(config2);
        }
        this._signal("afterRender", changes);
      };
      this.$autosize = function() {
        var height = this.session.getScreenLength() * this.lineHeight;
        var maxHeight = this.$maxLines * this.lineHeight;
        var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
        if (this.$horizScroll)
          desiredHeight += this.scrollBarH.getHeight();
        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
          desiredHeight = this.$maxPixelHeight;
        var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
        var vScroll = !hideScrollbars && height > maxHeight;
        if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
          if (vScroll != this.$vScroll) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
          }
          var w2 = this.container.clientWidth;
          this.container.style.height = desiredHeight + "px";
          this.$updateCachedSize(true, this.$gutterWidth, w2, desiredHeight);
          this.desiredHeight = desiredHeight;
          this._signal("autosize");
        }
      };
      this.$computeLayerConfig = function() {
        var session = this.session;
        var size = this.$size;
        var hideScrollbars = size.height <= 2 * this.lineHeight;
        var screenLines = this.session.getScreenLength();
        var maxHeight = screenLines * this.lineHeight;
        var longestLine = this.$getLongestLine();
        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
        var hScrollChanged = this.$horizScroll !== horizScroll;
        if (hScrollChanged) {
          this.$horizScroll = horizScroll;
          this.scrollBarH.setVisible(horizScroll);
        }
        var vScrollBefore = this.$vScroll;
        if (this.$maxLines && this.lineHeight > 1)
          this.$autosize();
        var minHeight = size.scrollerHeight + this.lineHeight;
        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
        maxHeight += scrollPastEnd;
        var sm = this.scrollMargin;
        this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
        var vScrollChanged = vScrollBefore !== vScroll;
        if (vScrollChanged) {
          this.$vScroll = vScroll;
          this.scrollBarV.setVisible(vScroll);
        }
        var offset = this.scrollTop % this.lineHeight;
        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
        var lastRow = firstRow + lineCount;
        var firstRowScreen, firstRowHeight;
        var lineHeight = this.lineHeight;
        firstRow = session.screenToDocumentRow(firstRow, 0);
        var foldLine2 = session.getFoldLine(firstRow);
        if (foldLine2) {
          firstRow = foldLine2.start.row;
        }
        firstRowScreen = session.documentToScreenRow(firstRow, 0);
        firstRowHeight = session.getRowLength(firstRow) * lineHeight;
        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
        offset = this.scrollTop - firstRowScreen * lineHeight;
        var changes = 0;
        if (this.layerConfig.width != longestLine || hScrollChanged)
          changes = this.CHANGE_H_SCROLL;
        if (hScrollChanged || vScrollChanged) {
          changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
          this._signal("scrollbarVisibilityChanged");
          if (vScrollChanged)
            longestLine = this.$getLongestLine();
        }
        this.layerConfig = {
          width: longestLine,
          padding: this.$padding,
          firstRow,
          firstRowScreen,
          lastRow,
          lineHeight,
          characterWidth: this.characterWidth,
          minHeight,
          maxHeight,
          offset,
          gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
          height: this.$size.scrollerHeight
        };
        if (this.session.$bidiHandler)
          this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
        return changes;
      };
      this.$updateLines = function() {
        if (!this.$changedLines)
          return;
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;
        var layerConfig = this.layerConfig;
        if (firstRow > layerConfig.lastRow + 1) {
          return;
        }
        if (lastRow < layerConfig.firstRow) {
          return;
        }
        if (lastRow === Infinity) {
          if (this.$showGutter)
            this.$gutterLayer.update(layerConfig);
          this.$textLayer.update(layerConfig);
          return;
        }
        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
        return true;
      };
      this.$getLongestLine = function() {
        var charCount = this.session.getScreenWidth();
        if (this.showInvisibles && !this.session.$useWrapMode)
          charCount += 1;
        if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
          charCount = this.$textLayer.MAX_LINE_LENGTH + 30;
        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
      };
      this.updateFrontMarkers = function() {
        this.$markerFront.setMarkers(this.session.getMarkers(true));
        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
      };
      this.updateBackMarkers = function() {
        this.$markerBack.setMarkers(this.session.getMarkers());
        this.$loop.schedule(this.CHANGE_MARKER_BACK);
      };
      this.addGutterDecoration = function(row, className) {
        this.$gutterLayer.addGutterDecoration(row, className);
      };
      this.removeGutterDecoration = function(row, className) {
        this.$gutterLayer.removeGutterDecoration(row, className);
      };
      this.updateBreakpoints = function(rows) {
        this.$loop.schedule(this.CHANGE_GUTTER);
      };
      this.setAnnotations = function(annotations) {
        this.$gutterLayer.setAnnotations(annotations);
        this.$loop.schedule(this.CHANGE_GUTTER);
      };
      this.updateCursor = function() {
        this.$loop.schedule(this.CHANGE_CURSOR);
      };
      this.hideCursor = function() {
        this.$cursorLayer.hideCursor();
      };
      this.showCursor = function() {
        this.$cursorLayer.showCursor();
      };
      this.scrollSelectionIntoView = function(anchor, lead, offset) {
        this.scrollCursorIntoView(anchor, offset);
        this.scrollCursorIntoView(lead, offset);
      };
      this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
        if (this.$size.scrollerHeight === 0)
          return;
        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var left = pos.left;
        var top = pos.top;
        var topMargin = $viewMargin && $viewMargin.top || 0;
        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
        if (scrollTop + topMargin > top) {
          if (offset && scrollTop + topMargin > top + this.lineHeight)
            top -= offset * this.$size.scrollerHeight;
          if (top === 0)
            top = -this.scrollMargin.top;
          this.session.setScrollTop(top);
        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
          if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top - this.lineHeight)
            top += offset * this.$size.scrollerHeight;
          this.session.setScrollTop(top + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
        }
        var scrollLeft = this.scrollLeft;
        if (scrollLeft > left) {
          if (left < this.$padding + 2 * this.layerConfig.characterWidth)
            left = -this.scrollMargin.left;
          this.session.setScrollLeft(left);
        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
          this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
          this.session.setScrollLeft(0);
        }
      };
      this.getScrollTop = function() {
        return this.session.getScrollTop();
      };
      this.getScrollLeft = function() {
        return this.session.getScrollLeft();
      };
      this.getScrollTopRow = function() {
        return this.scrollTop / this.lineHeight;
      };
      this.getScrollBottomRow = function() {
        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
      };
      this.scrollToRow = function(row) {
        this.session.setScrollTop(row * this.lineHeight);
      };
      this.alignCursor = function(cursor, alignment) {
        if (typeof cursor == "number")
          cursor = {row: cursor, column: 0};
        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var h2 = this.$size.scrollerHeight - this.lineHeight;
        var offset = pos.top - h2 * (alignment || 0);
        this.session.setScrollTop(offset);
        return offset;
      };
      this.STEPS = 8;
      this.$calcSteps = function(fromValue, toValue) {
        var i = 0;
        var l2 = this.STEPS;
        var steps = [];
        var func = function(t2, x_min, dx) {
          return dx * (Math.pow(t2 - 1, 3) + 1) + x_min;
        };
        for (i = 0; i < l2; ++i)
          steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
        return steps;
      };
      this.scrollToLine = function(line, center, animate, callback) {
        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
        var offset = pos.top;
        if (center)
          offset -= this.$size.scrollerHeight / 2;
        var initialScroll = this.scrollTop;
        this.session.setScrollTop(offset);
        if (animate !== false)
          this.animateScrolling(initialScroll, callback);
      };
      this.animateScrolling = function(fromValue, callback) {
        var toValue = this.scrollTop;
        if (!this.$animatedScroll)
          return;
        var _self = this;
        if (fromValue == toValue)
          return;
        if (this.$scrollAnimation) {
          var oldSteps = this.$scrollAnimation.steps;
          if (oldSteps.length) {
            fromValue = oldSteps[0];
            if (fromValue == toValue)
              return;
          }
        }
        var steps = _self.$calcSteps(fromValue, toValue);
        this.$scrollAnimation = {from: fromValue, to: toValue, steps};
        clearInterval(this.$timer);
        _self.session.setScrollTop(steps.shift());
        _self.session.$scrollTop = toValue;
        this.$timer = setInterval(function() {
          if (!_self.session)
            return clearInterval(_self.$timer);
          if (steps.length) {
            _self.session.setScrollTop(steps.shift());
            _self.session.$scrollTop = toValue;
          } else if (toValue != null) {
            _self.session.$scrollTop = -1;
            _self.session.setScrollTop(toValue);
            toValue = null;
          } else {
            _self.$timer = clearInterval(_self.$timer);
            _self.$scrollAnimation = null;
            callback && callback();
          }
        }, 10);
      };
      this.scrollToY = function(scrollTop) {
        if (this.scrollTop !== scrollTop) {
          this.$loop.schedule(this.CHANGE_SCROLL);
          this.scrollTop = scrollTop;
        }
      };
      this.scrollToX = function(scrollLeft) {
        if (this.scrollLeft !== scrollLeft)
          this.scrollLeft = scrollLeft;
        this.$loop.schedule(this.CHANGE_H_SCROLL);
      };
      this.scrollTo = function(x2, y3) {
        this.session.setScrollTop(y3);
        this.session.setScrollLeft(y3);
      };
      this.scrollBy = function(deltaX, deltaY) {
        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
      };
      this.isScrollableBy = function(deltaX, deltaY) {
        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
          return true;
        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
          return true;
        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
          return true;
        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
          return true;
      };
      this.pixelToScreenCoordinates = function(x2, y3) {
        var canvasPos;
        if (this.$hasCssTransforms) {
          canvasPos = {top: 0, left: 0};
          var p2 = this.$fontMetrics.transformCoordinates([x2, y3]);
          x2 = p2[1] - this.gutterWidth - this.margin.left;
          y3 = p2[0];
        } else {
          canvasPos = this.scroller.getBoundingClientRect();
        }
        var offsetX = x2 + this.scrollLeft - canvasPos.left - this.$padding;
        var offset = offsetX / this.characterWidth;
        var row = Math.floor((y3 + this.scrollTop - canvasPos.top) / this.lineHeight);
        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
        return {row, column: col, side: offset - col > 0 ? 1 : -1, offsetX};
      };
      this.screenToTextCoordinates = function(x2, y3) {
        var canvasPos;
        if (this.$hasCssTransforms) {
          canvasPos = {top: 0, left: 0};
          var p2 = this.$fontMetrics.transformCoordinates([x2, y3]);
          x2 = p2[1] - this.gutterWidth - this.margin.left;
          y3 = p2[0];
        } else {
          canvasPos = this.scroller.getBoundingClientRect();
        }
        var offsetX = x2 + this.scrollLeft - canvasPos.left - this.$padding;
        var offset = offsetX / this.characterWidth;
        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
        var row = Math.floor((y3 + this.scrollTop - canvasPos.top) / this.lineHeight);
        return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
      };
      this.textToScreenCoordinates = function(row, column) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var pos = this.session.documentToScreenPosition(row, column);
        var x2 = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row) ? this.session.$bidiHandler.getPosLeft(pos.column) : Math.round(pos.column * this.characterWidth));
        var y3 = pos.row * this.lineHeight;
        return {
          pageX: canvasPos.left + x2 - this.scrollLeft,
          pageY: canvasPos.top + y3 - this.scrollTop
        };
      };
      this.visualizeFocus = function() {
        dom.addCssClass(this.container, "ace_focus");
      };
      this.visualizeBlur = function() {
        dom.removeCssClass(this.container, "ace_focus");
      };
      this.showComposition = function(composition) {
        this.$composition = composition;
        if (!composition.cssText) {
          composition.cssText = this.textarea.style.cssText;
        }
        if (composition.useTextareaForIME == void 0)
          composition.useTextareaForIME = this.$useTextareaForIME;
        if (this.$useTextareaForIME) {
          dom.addCssClass(this.textarea, "ace_composition");
          this.textarea.style.cssText = "";
          this.$moveTextAreaToCursor();
          this.$cursorLayer.element.style.display = "none";
        } else {
          composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
        }
      };
      this.setCompositionText = function(text) {
        var cursor = this.session.selection.cursor;
        this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
        this.$moveTextAreaToCursor();
      };
      this.hideComposition = function() {
        if (!this.$composition)
          return;
        if (this.$composition.markerId)
          this.session.removeMarker(this.$composition.markerId);
        dom.removeCssClass(this.textarea, "ace_composition");
        this.textarea.style.cssText = this.$composition.cssText;
        var cursor = this.session.selection.cursor;
        this.removeExtraToken(cursor.row, cursor.column);
        this.$composition = null;
        this.$cursorLayer.element.style.display = "";
      };
      this.addToken = function(text, type2, row, column) {
        var session = this.session;
        session.bgTokenizer.lines[row] = null;
        var newToken = {type: type2, value: text};
        var tokens = session.getTokens(row);
        if (column == null) {
          tokens.push(newToken);
        } else {
          var l2 = 0;
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            l2 += token.value.length;
            if (column <= l2) {
              var diff2 = token.value.length - (l2 - column);
              var before = token.value.slice(0, diff2);
              var after = token.value.slice(diff2);
              tokens.splice(i, 1, {type: token.type, value: before}, newToken, {type: token.type, value: after});
              break;
            }
          }
        }
        this.updateLines(row, row);
      };
      this.removeExtraToken = function(row, column) {
        this.updateLines(row, row);
      };
      this.setTheme = function(theme, cb2) {
        var _self = this;
        this.$themeId = theme;
        _self._dispatchEvent("themeChange", {theme});
        if (!theme || typeof theme == "string") {
          var moduleName = theme || this.$options.theme.initialValue;
          config.loadModule(["theme", moduleName], afterLoad);
        } else {
          afterLoad(theme);
        }
        function afterLoad(module3) {
          if (_self.$themeId != theme)
            return cb2 && cb2();
          if (!module3 || !module3.cssClass)
            throw new Error("couldn't load module " + theme + " or it didn't call define");
          if (module3.$id)
            _self.$themeId = module3.$id;
          dom.importCssString(module3.cssText, module3.cssClass, _self.container);
          if (_self.theme)
            dom.removeCssClass(_self.container, _self.theme.cssClass);
          var padding = "padding" in module3 ? module3.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
          if (_self.$padding && padding != _self.$padding)
            _self.setPadding(padding);
          _self.$theme = module3.cssClass;
          _self.theme = module3;
          dom.addCssClass(_self.container, module3.cssClass);
          dom.setCssClass(_self.container, "ace_dark", module3.isDark);
          if (_self.$size) {
            _self.$size.width = 0;
            _self.$updateSizeAsync();
          }
          _self._dispatchEvent("themeLoaded", {theme: module3});
          cb2 && cb2();
        }
      };
      this.getTheme = function() {
        return this.$themeId;
      };
      this.setStyle = function(style, include) {
        dom.setCssClass(this.container, style, include !== false);
      };
      this.unsetStyle = function(style) {
        dom.removeCssClass(this.container, style);
      };
      this.setCursorStyle = function(style) {
        dom.setStyle(this.scroller.style, "cursor", style);
      };
      this.setMouseCursor = function(cursorStyle) {
        dom.setStyle(this.scroller.style, "cursor", cursorStyle);
      };
      this.attachToShadowRoot = function() {
        dom.importCssString(editorCss, "ace_editor.css", this.container);
      };
      this.destroy = function() {
        this.freeze();
        this.$fontMetrics.destroy();
        this.$cursorLayer.destroy();
        this.removeAllListeners();
        this.container.textContent = "";
      };
    }).call(VirtualRenderer.prototype);
    config.defineOptions(VirtualRenderer.prototype, "renderer", {
      animatedScroll: {initialValue: false},
      showInvisibles: {
        set: function(value) {
          if (this.$textLayer.setShowInvisibles(value))
            this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
      },
      showPrintMargin: {
        set: function() {
          this.$updatePrintMargin();
        },
        initialValue: true
      },
      printMarginColumn: {
        set: function() {
          this.$updatePrintMargin();
        },
        initialValue: 80
      },
      printMargin: {
        set: function(val) {
          if (typeof val == "number")
            this.$printMarginColumn = val;
          this.$showPrintMargin = !!val;
          this.$updatePrintMargin();
        },
        get: function() {
          return this.$showPrintMargin && this.$printMarginColumn;
        }
      },
      showGutter: {
        set: function(show) {
          this.$gutter.style.display = show ? "block" : "none";
          this.$loop.schedule(this.CHANGE_FULL);
          this.onGutterResize();
        },
        initialValue: true
      },
      fadeFoldWidgets: {
        set: function(show) {
          dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
        },
        initialValue: false
      },
      showFoldWidgets: {
        set: function(show) {
          this.$gutterLayer.setShowFoldWidgets(show);
          this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
      },
      displayIndentGuides: {
        set: function(show) {
          if (this.$textLayer.setDisplayIndentGuides(show))
            this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
      },
      highlightGutterLine: {
        set: function(shouldHighlight) {
          this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
          this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
      },
      hScrollBarAlwaysVisible: {
        set: function(val) {
          if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
      },
      vScrollBarAlwaysVisible: {
        set: function(val) {
          if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
      },
      fontSize: {
        set: function(size) {
          if (typeof size == "number")
            size = size + "px";
          this.container.style.fontSize = size;
          this.updateFontSize();
        },
        initialValue: 12
      },
      fontFamily: {
        set: function(name) {
          this.container.style.fontFamily = name;
          this.updateFontSize();
        }
      },
      maxLines: {
        set: function(val) {
          this.updateFull();
        }
      },
      minLines: {
        set: function(val) {
          if (!(this.$minLines < 562949953421311))
            this.$minLines = 0;
          this.updateFull();
        }
      },
      maxPixelHeight: {
        set: function(val) {
          this.updateFull();
        },
        initialValue: 0
      },
      scrollPastEnd: {
        set: function(val) {
          val = +val || 0;
          if (this.$scrollPastEnd == val)
            return;
          this.$scrollPastEnd = val;
          this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: 0,
        handlesSet: true
      },
      fixedWidthGutter: {
        set: function(val) {
          this.$gutterLayer.$fixedWidth = !!val;
          this.$loop.schedule(this.CHANGE_GUTTER);
        }
      },
      theme: {
        set: function(val) {
          this.setTheme(val);
        },
        get: function() {
          return this.$themeId || this.theme;
        },
        initialValue: "./theme/textmate",
        handlesSet: true
      },
      hasCssTransforms: {},
      useTextareaForIME: {
        initialValue: !useragent.isMobile && !useragent.isIE
      }
    });
    exports2.VirtualRenderer = VirtualRenderer;
  });
  ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var net = require2("../lib/net");
    var EventEmitter = require2("../lib/event_emitter").EventEmitter;
    var config = require2("../config");
    function $workerBlob(workerUrl) {
      var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
      try {
        return new Blob([script], {type: "application/javascript"});
      } catch (e2) {
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        var blobBuilder = new BlobBuilder();
        blobBuilder.append(script);
        return blobBuilder.getBlob("application/javascript");
      }
    }
    function createWorker(workerUrl) {
      if (typeof Worker == "undefined")
        return {postMessage: function() {
        }, terminate: function() {
        }};
      if (config.get("loadWorkerFromBlob")) {
        var blob = $workerBlob(workerUrl);
        var URL = window.URL || window.webkitURL;
        var blobURL = URL.createObjectURL(blob);
        return new Worker(blobURL);
      }
      return new Worker(workerUrl);
    }
    var WorkerClient = function(worker) {
      if (!worker.postMessage)
        worker = this.$createWorkerFromOldConfig.apply(this, arguments);
      this.$worker = worker;
      this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
      this.changeListener = this.changeListener.bind(this);
      this.onMessage = this.onMessage.bind(this);
      this.callbackId = 1;
      this.callbacks = {};
      this.$worker.onmessage = this.onMessage;
    };
    (function() {
      oop.implement(this, EventEmitter);
      this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
        if (require2.nameToUrl && !require2.toUrl)
          require2.toUrl = require2.nameToUrl;
        if (config.get("packaged") || !require2.toUrl) {
          workerUrl = workerUrl || config.moduleUrl(mod, "worker");
        } else {
          var normalizePath = this.$normalizePath;
          workerUrl = workerUrl || normalizePath(require2.toUrl("ace/worker/worker.js", null, "_"));
          var tlns = {};
          topLevelNamespaces.forEach(function(ns) {
            tlns[ns] = normalizePath(require2.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
          });
        }
        this.$worker = createWorker(workerUrl);
        if (importScripts) {
          this.send("importScripts", importScripts);
        }
        this.$worker.postMessage({
          init: true,
          tlns,
          module: mod,
          classname
        });
        return this.$worker;
      };
      this.onMessage = function(e2) {
        var msg = e2.data;
        switch (msg.type) {
          case "event":
            this._signal(msg.name, {data: msg.data});
            break;
          case "call":
            var callback = this.callbacks[msg.id];
            if (callback) {
              callback(msg.data);
              delete this.callbacks[msg.id];
            }
            break;
          case "error":
            this.reportError(msg.data);
            break;
          case "log":
            window.console && console.log && console.log.apply(console, msg.data);
            break;
        }
      };
      this.reportError = function(err) {
        window.console && console.error && console.error(err);
      };
      this.$normalizePath = function(path) {
        return net.qualifyURL(path);
      };
      this.terminate = function() {
        this._signal("terminate", {});
        this.deltaQueue = null;
        this.$worker.terminate();
        this.$worker = null;
        if (this.$doc)
          this.$doc.off("change", this.changeListener);
        this.$doc = null;
      };
      this.send = function(cmd, args) {
        this.$worker.postMessage({command: cmd, args});
      };
      this.call = function(cmd, args, callback) {
        if (callback) {
          var id2 = this.callbackId++;
          this.callbacks[id2] = callback;
          args.push(id2);
        }
        this.send(cmd, args);
      };
      this.emit = function(event, data) {
        try {
          if (data.data && data.data.err)
            data.data.err = {message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code};
          this.$worker.postMessage({event, data: {data: data.data}});
        } catch (ex) {
          console.error(ex.stack);
        }
      };
      this.attachToDocument = function(doc) {
        if (this.$doc)
          this.terminate();
        this.$doc = doc;
        this.call("setValue", [doc.getValue()]);
        doc.on("change", this.changeListener);
      };
      this.changeListener = function(delta) {
        if (!this.deltaQueue) {
          this.deltaQueue = [];
          setTimeout(this.$sendDeltaQueue, 0);
        }
        if (delta.action == "insert")
          this.deltaQueue.push(delta.start, delta.lines);
        else
          this.deltaQueue.push(delta.start, delta.end);
      };
      this.$sendDeltaQueue = function() {
        var q2 = this.deltaQueue;
        if (!q2)
          return;
        this.deltaQueue = null;
        if (q2.length > 50 && q2.length > this.$doc.getLength() >> 1) {
          this.call("setValue", [this.$doc.getValue()]);
        } else
          this.emit("change", {data: q2});
      };
    }).call(WorkerClient.prototype);
    var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
      var main = null;
      var emitSync = false;
      var sender = Object.create(EventEmitter);
      var messageBuffer = [];
      var workerClient = new WorkerClient({
        messageBuffer,
        terminate: function() {
        },
        postMessage: function(e2) {
          messageBuffer.push(e2);
          if (!main)
            return;
          if (emitSync)
            setTimeout(processNext);
          else
            processNext();
        }
      });
      workerClient.setEmitSync = function(val) {
        emitSync = val;
      };
      var processNext = function() {
        var msg = messageBuffer.shift();
        if (msg.command)
          main[msg.command].apply(main, msg.args);
        else if (msg.event)
          sender._signal(msg.event, msg.data);
      };
      sender.postMessage = function(msg) {
        workerClient.onMessage({data: msg});
      };
      sender.callback = function(data, callbackId) {
        this.postMessage({type: "call", id: callbackId, data});
      };
      sender.emit = function(name, data) {
        this.postMessage({type: "event", name, data});
      };
      config.loadModule(["worker", mod], function(Main) {
        main = new Main[classname](sender);
        while (messageBuffer.length)
          processNext();
      });
      return workerClient;
    };
    exports2.UIWorkerClient = UIWorkerClient;
    exports2.WorkerClient = WorkerClient;
    exports2.createWorker = createWorker;
  });
  ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function(require2, exports2, module2) {
    var Range = require2("./range").Range;
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var oop = require2("./lib/oop");
    var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
      var _self = this;
      this.length = length;
      this.session = session;
      this.doc = session.getDocument();
      this.mainClass = mainClass;
      this.othersClass = othersClass;
      this.$onUpdate = this.onUpdate.bind(this);
      this.doc.on("change", this.$onUpdate);
      this.$others = others;
      this.$onCursorChange = function() {
        setTimeout(function() {
          _self.onCursorChange();
        });
      };
      this.$pos = pos;
      var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
      this.$undoStackDepth = undoStack.length;
      this.setup();
      session.selection.on("changeCursor", this.$onCursorChange);
    };
    (function() {
      oop.implement(this, EventEmitter);
      this.setup = function() {
        var _self = this;
        var doc = this.doc;
        var session = this.session;
        this.selectionBefore = session.selection.toJSON();
        if (session.selection.inMultiSelectMode)
          session.selection.toSingleRange();
        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
        var pos = this.pos;
        pos.$insertRight = true;
        pos.detach();
        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
        this.others = [];
        this.$others.forEach(function(other) {
          var anchor = doc.createAnchor(other.row, other.column);
          anchor.$insertRight = true;
          anchor.detach();
          _self.others.push(anchor);
        });
        session.setUndoSelect(false);
      };
      this.showOtherMarkers = function() {
        if (this.othersActive)
          return;
        var session = this.session;
        var _self = this;
        this.othersActive = true;
        this.others.forEach(function(anchor) {
          anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
        });
      };
      this.hideOtherMarkers = function() {
        if (!this.othersActive)
          return;
        this.othersActive = false;
        for (var i = 0; i < this.others.length; i++) {
          this.session.removeMarker(this.others[i].markerId);
        }
      };
      this.onUpdate = function(delta) {
        if (this.$updating)
          return this.updateAnchors(delta);
        var range = delta;
        if (range.start.row !== range.end.row)
          return;
        if (range.start.row !== this.pos.row)
          return;
        this.$updating = true;
        var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
        var distanceFromStart = range.start.column - this.pos.column;
        this.updateAnchors(delta);
        if (inMainRange)
          this.length += lengthDiff;
        if (inMainRange && !this.session.$fromUndo) {
          if (delta.action === "insert") {
            for (var i = this.others.length - 1; i >= 0; i--) {
              var otherPos = this.others[i];
              var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
              this.doc.insertMergedLines(newPos, delta.lines);
            }
          } else if (delta.action === "remove") {
            for (var i = this.others.length - 1; i >= 0; i--) {
              var otherPos = this.others[i];
              var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
              this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
            }
          }
        }
        this.$updating = false;
        this.updateMarkers();
      };
      this.updateAnchors = function(delta) {
        this.pos.onChange(delta);
        for (var i = this.others.length; i--; )
          this.others[i].onChange(delta);
        this.updateMarkers();
      };
      this.updateMarkers = function() {
        if (this.$updating)
          return;
        var _self = this;
        var session = this.session;
        var updateMarker = function(pos, className) {
          session.removeMarker(pos.markerId);
          pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
        };
        updateMarker(this.pos, this.mainClass);
        for (var i = this.others.length; i--; )
          updateMarker(this.others[i], this.othersClass);
      };
      this.onCursorChange = function(event) {
        if (this.$updating || !this.session)
          return;
        var pos = this.session.selection.getCursor();
        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
          this.showOtherMarkers();
          this._emit("cursorEnter", event);
        } else {
          this.hideOtherMarkers();
          this._emit("cursorLeave", event);
        }
      };
      this.detach = function() {
        this.session.removeMarker(this.pos && this.pos.markerId);
        this.hideOtherMarkers();
        this.doc.off("change", this.$onUpdate);
        this.session.selection.off("changeCursor", this.$onCursorChange);
        this.session.setUndoSelect(true);
        this.session = null;
      };
      this.cancel = function() {
        if (this.$undoStackDepth === -1)
          return;
        var undoManager = this.session.getUndoManager();
        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
        for (var i = 0; i < undosRequired; i++) {
          undoManager.undo(this.session, true);
        }
        if (this.selectionBefore)
          this.session.selection.fromJSON(this.selectionBefore);
      };
    }).call(PlaceHolder.prototype);
    exports2.PlaceHolder = PlaceHolder;
  });
  ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require2, exports2, module2) {
    var event = require2("../lib/event");
    var useragent = require2("../lib/useragent");
    function isSamePoint(p1, p2) {
      return p1.row == p2.row && p1.column == p2.column;
    }
    function onMouseDown(e2) {
      var ev = e2.domEvent;
      var alt = ev.altKey;
      var shift = ev.shiftKey;
      var ctrl = ev.ctrlKey;
      var accel = e2.getAccelKey();
      var button = e2.getButton();
      if (ctrl && useragent.isMac)
        button = ev.button;
      if (e2.editor.inMultiSelectMode && button == 2) {
        e2.editor.textInput.onContextMenu(e2.domEvent);
        return;
      }
      if (!ctrl && !alt && !accel) {
        if (button === 0 && e2.editor.inMultiSelectMode)
          e2.editor.exitMultiSelectMode();
        return;
      }
      if (button !== 0)
        return;
      var editor = e2.editor;
      var selection = editor.selection;
      var isMultiSelect = editor.inMultiSelectMode;
      var pos = e2.getDocumentPosition();
      var cursor = selection.getCursor();
      var inSelection = e2.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);
      var mouseX = e2.x, mouseY = e2.y;
      var onMouseSelection = function(e3) {
        mouseX = e3.clientX;
        mouseY = e3.clientY;
      };
      var session = editor.session;
      var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
      var screenCursor = screenAnchor;
      var selectionMode;
      if (editor.$mouseHandler.$enableJumpToDef) {
        if (ctrl && alt || accel && alt)
          selectionMode = shift ? "block" : "add";
        else if (alt && editor.$blockSelectEnabled)
          selectionMode = "block";
      } else {
        if (accel && !alt) {
          selectionMode = "add";
          if (!isMultiSelect && shift)
            return;
        } else if (alt && editor.$blockSelectEnabled) {
          selectionMode = "block";
        }
      }
      if (selectionMode && useragent.isMac && ev.ctrlKey) {
        editor.$mouseHandler.cancelContextMenu();
      }
      if (selectionMode == "add") {
        if (!isMultiSelect && inSelection)
          return;
        if (!isMultiSelect) {
          var range = selection.toOrientedRange();
          editor.addSelectionMarker(range);
        }
        var oldRange = selection.rangeList.rangeAtPoint(pos);
        editor.inVirtualSelectionMode = true;
        if (shift) {
          oldRange = null;
          range = selection.ranges[0] || range;
          editor.removeSelectionMarker(range);
        }
        editor.once("mouseup", function() {
          var tmpSel = selection.toOrientedRange();
          if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
            selection.substractPoint(tmpSel.cursor);
          else {
            if (shift) {
              selection.substractPoint(range.cursor);
            } else if (range) {
              editor.removeSelectionMarker(range);
              selection.addRange(range);
            }
            selection.addRange(tmpSel);
          }
          editor.inVirtualSelectionMode = false;
        });
      } else if (selectionMode == "block") {
        e2.stop();
        editor.inVirtualSelectionMode = true;
        var initialRange;
        var rectSel = [];
        var blockSelect = function() {
          var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
          var cursor2 = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
          if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor2, selection.lead))
            return;
          screenCursor = newCursor;
          editor.selection.moveToPosition(cursor2);
          editor.renderer.scrollCursorIntoView();
          editor.removeSelectionMarkers(rectSel);
          rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
          if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
            rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
          rectSel.forEach(editor.addSelectionMarker, editor);
          editor.updateSelectionMarkers();
        };
        if (isMultiSelect && !accel) {
          selection.toSingleRange();
        } else if (!isMultiSelect && accel) {
          initialRange = selection.toOrientedRange();
          editor.addSelectionMarker(initialRange);
        }
        if (shift)
          screenAnchor = session.documentToScreenPosition(selection.lead);
        else
          selection.moveToPosition(pos);
        screenCursor = {row: -1, column: -1};
        var onMouseSelectionEnd = function(e3) {
          blockSelect();
          clearInterval(timerId);
          editor.removeSelectionMarkers(rectSel);
          if (!rectSel.length)
            rectSel = [selection.toOrientedRange()];
          if (initialRange) {
            editor.removeSelectionMarker(initialRange);
            selection.toSingleRange(initialRange);
          }
          for (var i = 0; i < rectSel.length; i++)
            selection.addRange(rectSel[i]);
          editor.inVirtualSelectionMode = false;
          editor.$mouseHandler.$clickSelection = null;
        };
        var onSelectionInterval = blockSelect;
        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
        var timerId = setInterval(function() {
          onSelectionInterval();
        }, 20);
        return e2.preventDefault();
      }
    }
    exports2.onMouseDown = onMouseDown;
  });
  ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function(require2, exports2, module2) {
    exports2.defaultCommands = [{
      name: "addCursorAbove",
      description: "Add cursor above",
      exec: function(editor) {
        editor.selectMoreLines(-1);
      },
      bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "addCursorBelow",
      description: "Add cursor below",
      exec: function(editor) {
        editor.selectMoreLines(1);
      },
      bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "addCursorAboveSkipCurrent",
      description: "Add cursor above (skip current)",
      exec: function(editor) {
        editor.selectMoreLines(-1, true);
      },
      bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "addCursorBelowSkipCurrent",
      description: "Add cursor below (skip current)",
      exec: function(editor) {
        editor.selectMoreLines(1, true);
      },
      bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectMoreBefore",
      description: "Select more before",
      exec: function(editor) {
        editor.selectMore(-1);
      },
      bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectMoreAfter",
      description: "Select more after",
      exec: function(editor) {
        editor.selectMore(1);
      },
      bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectNextBefore",
      description: "Select next before",
      exec: function(editor) {
        editor.selectMore(-1, true);
      },
      bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectNextAfter",
      description: "Select next after",
      exec: function(editor) {
        editor.selectMore(1, true);
      },
      bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "toggleSplitSelectionIntoLines",
      description: "Split into lines",
      exec: function(editor) {
        if (editor.multiSelect.rangeCount > 1)
          editor.multiSelect.joinSelections();
        else
          editor.multiSelect.splitIntoLines();
      },
      bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
      readOnly: true
    }, {
      name: "splitSelectionIntoLines",
      description: "Split into lines",
      exec: function(editor) {
        editor.multiSelect.splitIntoLines();
      },
      readOnly: true
    }, {
      name: "alignCursors",
      description: "Align cursors",
      exec: function(editor) {
        editor.alignCursors();
      },
      bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
      scrollIntoView: "cursor"
    }, {
      name: "findAll",
      description: "Find all",
      exec: function(editor) {
        editor.findAll();
      },
      bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
      scrollIntoView: "cursor",
      readOnly: true
    }];
    exports2.multiSelectCommands = [{
      name: "singleSelection",
      description: "Single selection",
      bindKey: "esc",
      exec: function(editor) {
        editor.exitMultiSelectMode();
      },
      scrollIntoView: "cursor",
      readOnly: true,
      isAvailable: function(editor) {
        return editor && editor.inMultiSelectMode;
      }
    }];
    var HashHandler = require2("../keyboard/hash_handler").HashHandler;
    exports2.keyboardHandler = new HashHandler(exports2.multiSelectCommands);
  });
  ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function(require2, exports2, module2) {
    var RangeList = require2("./range_list").RangeList;
    var Range = require2("./range").Range;
    var Selection = require2("./selection").Selection;
    var onMouseDown = require2("./mouse/multi_select_handler").onMouseDown;
    var event = require2("./lib/event");
    var lang = require2("./lib/lang");
    var commands = require2("./commands/multi_select_commands");
    exports2.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
    var Search = require2("./search").Search;
    var search = new Search();
    function find(session, needle, dir) {
      search.$options.wrap = true;
      search.$options.needle = needle;
      search.$options.backwards = dir == -1;
      return search.find(session);
    }
    var EditSession = require2("./edit_session").EditSession;
    (function() {
      this.getSelectionMarkers = function() {
        return this.$selectionMarkers;
      };
    }).call(EditSession.prototype);
    (function() {
      this.ranges = null;
      this.rangeList = null;
      this.addRange = function(range, $blockChangeEvents) {
        if (!range)
          return;
        if (!this.inMultiSelectMode && this.rangeCount === 0) {
          var oldRange = this.toOrientedRange();
          this.rangeList.add(oldRange);
          this.rangeList.add(range);
          if (this.rangeList.ranges.length != 2) {
            this.rangeList.removeAll();
            return $blockChangeEvents || this.fromOrientedRange(range);
          }
          this.rangeList.removeAll();
          this.rangeList.add(oldRange);
          this.$onAddRange(oldRange);
        }
        if (!range.cursor)
          range.cursor = range.end;
        var removed = this.rangeList.add(range);
        this.$onAddRange(range);
        if (removed.length)
          this.$onRemoveRange(removed);
        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
          this._signal("multiSelect");
          this.inMultiSelectMode = true;
          this.session.$undoSelect = false;
          this.rangeList.attach(this.session);
        }
        return $blockChangeEvents || this.fromOrientedRange(range);
      };
      this.toSingleRange = function(range) {
        range = range || this.ranges[0];
        var removed = this.rangeList.removeAll();
        if (removed.length)
          this.$onRemoveRange(removed);
        range && this.fromOrientedRange(range);
      };
      this.substractPoint = function(pos) {
        var removed = this.rangeList.substractPoint(pos);
        if (removed) {
          this.$onRemoveRange(removed);
          return removed[0];
        }
      };
      this.mergeOverlappingRanges = function() {
        var removed = this.rangeList.merge();
        if (removed.length)
          this.$onRemoveRange(removed);
      };
      this.$onAddRange = function(range) {
        this.rangeCount = this.rangeList.ranges.length;
        this.ranges.unshift(range);
        this._signal("addRange", {range});
      };
      this.$onRemoveRange = function(removed) {
        this.rangeCount = this.rangeList.ranges.length;
        if (this.rangeCount == 1 && this.inMultiSelectMode) {
          var lastRange = this.rangeList.ranges.pop();
          removed.push(lastRange);
          this.rangeCount = 0;
        }
        for (var i = removed.length; i--; ) {
          var index2 = this.ranges.indexOf(removed[i]);
          this.ranges.splice(index2, 1);
        }
        this._signal("removeRange", {ranges: removed});
        if (this.rangeCount === 0 && this.inMultiSelectMode) {
          this.inMultiSelectMode = false;
          this._signal("singleSelect");
          this.session.$undoSelect = true;
          this.rangeList.detach(this.session);
        }
        lastRange = lastRange || this.ranges[0];
        if (lastRange && !lastRange.isEqual(this.getRange()))
          this.fromOrientedRange(lastRange);
      };
      this.$initRangeList = function() {
        if (this.rangeList)
          return;
        this.rangeList = new RangeList();
        this.ranges = [];
        this.rangeCount = 0;
      };
      this.getAllRanges = function() {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
      };
      this.splitIntoLines = function() {
        var ranges = this.ranges.length ? this.ranges : [this.getRange()];
        var newRanges = [];
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          var row = range.start.row;
          var endRow = range.end.row;
          if (row === endRow) {
            newRanges.push(range.clone());
          } else {
            newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
            while (++row < endRow)
              newRanges.push(this.getLineRange(row, true));
            newRanges.push(new Range(endRow, 0, endRow, range.end.column));
          }
          if (i == 0 && !this.isBackwards())
            newRanges = newRanges.reverse();
        }
        this.toSingleRange();
        for (var i = newRanges.length; i--; )
          this.addRange(newRanges[i]);
      };
      this.joinSelections = function() {
        var ranges = this.rangeList.ranges;
        var lastRange = ranges[ranges.length - 1];
        var range = Range.fromPoints(ranges[0].start, lastRange.end);
        this.toSingleRange();
        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
      };
      this.toggleBlockSelection = function() {
        if (this.rangeCount > 1) {
          var ranges = this.rangeList.ranges;
          var lastRange = ranges[ranges.length - 1];
          var range = Range.fromPoints(ranges[0].start, lastRange.end);
          this.toSingleRange();
          this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
          var cursor = this.session.documentToScreenPosition(this.cursor);
          var anchor = this.session.documentToScreenPosition(this.anchor);
          var rectSel = this.rectangularRangeBlock(cursor, anchor);
          rectSel.forEach(this.addRange, this);
        }
      };
      this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
        var rectSel = [];
        var xBackwards = screenCursor.column < screenAnchor.column;
        if (xBackwards) {
          var startColumn = screenCursor.column;
          var endColumn = screenAnchor.column;
          var startOffsetX = screenCursor.offsetX;
          var endOffsetX = screenAnchor.offsetX;
        } else {
          var startColumn = screenAnchor.column;
          var endColumn = screenCursor.column;
          var startOffsetX = screenAnchor.offsetX;
          var endOffsetX = screenCursor.offsetX;
        }
        var yBackwards = screenCursor.row < screenAnchor.row;
        if (yBackwards) {
          var startRow = screenCursor.row;
          var endRow = screenAnchor.row;
        } else {
          var startRow = screenAnchor.row;
          var endRow = screenCursor.row;
        }
        if (startColumn < 0)
          startColumn = 0;
        if (startRow < 0)
          startRow = 0;
        if (startRow == endRow)
          includeEmptyLines = true;
        var docEnd;
        for (var row = startRow; row <= endRow; row++) {
          var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
          if (range.isEmpty()) {
            if (docEnd && isSamePoint(range.end, docEnd))
              break;
            docEnd = range.end;
          }
          range.cursor = xBackwards ? range.start : range.end;
          rectSel.push(range);
        }
        if (yBackwards)
          rectSel.reverse();
        if (!includeEmptyLines) {
          var end = rectSel.length - 1;
          while (rectSel[end].isEmpty() && end > 0)
            end--;
          if (end > 0) {
            var start = 0;
            while (rectSel[start].isEmpty())
              start++;
          }
          for (var i = end; i >= start; i--) {
            if (rectSel[i].isEmpty())
              rectSel.splice(i, 1);
          }
        }
        return rectSel;
      };
    }).call(Selection.prototype);
    var Editor = require2("./editor").Editor;
    (function() {
      this.updateSelectionMarkers = function() {
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
      };
      this.addSelectionMarker = function(orientedRange) {
        if (!orientedRange.cursor)
          orientedRange.cursor = orientedRange.end;
        var style = this.getSelectionStyle();
        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
        this.session.$selectionMarkers.push(orientedRange);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        return orientedRange;
      };
      this.removeSelectionMarker = function(range) {
        if (!range.marker)
          return;
        this.session.removeMarker(range.marker);
        var index2 = this.session.$selectionMarkers.indexOf(range);
        if (index2 != -1)
          this.session.$selectionMarkers.splice(index2, 1);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
      };
      this.removeSelectionMarkers = function(ranges) {
        var markerList = this.session.$selectionMarkers;
        for (var i = ranges.length; i--; ) {
          var range = ranges[i];
          if (!range.marker)
            continue;
          this.session.removeMarker(range.marker);
          var index2 = markerList.indexOf(range);
          if (index2 != -1)
            markerList.splice(index2, 1);
        }
        this.session.selectionMarkerCount = markerList.length;
      };
      this.$onAddRange = function(e2) {
        this.addSelectionMarker(e2.range);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
      };
      this.$onRemoveRange = function(e2) {
        this.removeSelectionMarkers(e2.ranges);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
      };
      this.$onMultiSelect = function(e2) {
        if (this.inMultiSelectMode)
          return;
        this.inMultiSelectMode = true;
        this.setStyle("ace_multiselect");
        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
      };
      this.$onSingleSelect = function(e2) {
        if (this.session.multiSelect.inVirtualMode)
          return;
        this.inMultiSelectMode = false;
        this.unsetStyle("ace_multiselect");
        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
        this._emit("changeSelection");
      };
      this.$onMultiSelectExec = function(e2) {
        var command = e2.command;
        var editor = e2.editor;
        if (!editor.multiSelect)
          return;
        if (!command.multiSelectAction) {
          var result = command.exec(editor, e2.args || {});
          editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
          editor.multiSelect.mergeOverlappingRanges();
        } else if (command.multiSelectAction == "forEach") {
          result = editor.forEachSelection(command, e2.args);
        } else if (command.multiSelectAction == "forEachLine") {
          result = editor.forEachSelection(command, e2.args, true);
        } else if (command.multiSelectAction == "single") {
          editor.exitMultiSelectMode();
          result = command.exec(editor, e2.args || {});
        } else {
          result = command.multiSelectAction(editor, e2.args || {});
        }
        return result;
      };
      this.forEachSelection = function(cmd, args, options) {
        if (this.inVirtualSelectionMode)
          return;
        var keepOrder = options && options.keepOrder;
        var $byLines = options == true || options && options.$byLines;
        var session = this.session;
        var selection = this.selection;
        var rangeList = selection.rangeList;
        var ranges = (keepOrder ? selection : rangeList).ranges;
        var result;
        if (!ranges.length)
          return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
        var reg = selection._eventRegistry;
        selection._eventRegistry = {};
        var tmpSel = new Selection(session);
        this.inVirtualSelectionMode = true;
        for (var i = ranges.length; i--; ) {
          if ($byLines) {
            while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
              i--;
          }
          tmpSel.fromOrientedRange(ranges[i]);
          tmpSel.index = i;
          this.selection = session.selection = tmpSel;
          var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
          if (!result && cmdResult !== void 0)
            result = cmdResult;
          tmpSel.toOrientedRange(ranges[i]);
        }
        tmpSel.detach();
        this.selection = session.selection = selection;
        this.inVirtualSelectionMode = false;
        selection._eventRegistry = reg;
        selection.mergeOverlappingRanges();
        if (selection.ranges[0])
          selection.fromOrientedRange(selection.ranges[0]);
        var anim = this.renderer.$scrollAnimation;
        this.onCursorChange();
        this.onSelectionChange();
        if (anim && anim.from == anim.to)
          this.renderer.animateScrolling(anim.from);
        return result;
      };
      this.exitMultiSelectMode = function() {
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
          return;
        this.multiSelect.toSingleRange();
      };
      this.getSelectedText = function() {
        var text = "";
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
          var ranges = this.multiSelect.rangeList.ranges;
          var buf = [];
          for (var i = 0; i < ranges.length; i++) {
            buf.push(this.session.getTextRange(ranges[i]));
          }
          var nl = this.session.getDocument().getNewLineCharacter();
          text = buf.join(nl);
          if (text.length == (buf.length - 1) * nl.length)
            text = "";
        } else if (!this.selection.isEmpty()) {
          text = this.session.getTextRange(this.getSelectionRange());
        }
        return text;
      };
      this.$checkMultiselectChange = function(e2, anchor) {
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
          var range = this.multiSelect.ranges[0];
          if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
            return;
          var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
          if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
            this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
          else
            this.multiSelect.mergeOverlappingRanges();
        }
      };
      this.findAll = function(needle, options, additive) {
        options = options || {};
        options.needle = needle || options.needle;
        if (options.needle == void 0) {
          var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
          options.needle = this.session.getTextRange(range);
        }
        this.$search.set(options);
        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
          return 0;
        var selection = this.multiSelect;
        if (!additive)
          selection.toSingleRange(ranges[0]);
        for (var i = ranges.length; i--; )
          selection.addRange(ranges[i], true);
        if (range && selection.rangeList.rangeAtPoint(range.start))
          selection.addRange(range, true);
        return ranges.length;
      };
      this.selectMoreLines = function(dir, skip) {
        var range = this.selection.toOrientedRange();
        var isBackwards = range.cursor == range.end;
        var screenLead = this.session.documentToScreenPosition(range.cursor);
        if (this.selection.$desiredColumn)
          screenLead.column = this.selection.$desiredColumn;
        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
        if (!range.isEmpty()) {
          var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
          var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
        } else {
          var anchor = lead;
        }
        if (isBackwards) {
          var newRange = Range.fromPoints(lead, anchor);
          newRange.cursor = newRange.start;
        } else {
          var newRange = Range.fromPoints(anchor, lead);
          newRange.cursor = newRange.end;
        }
        newRange.desiredColumn = screenLead.column;
        if (!this.selection.inMultiSelectMode) {
          this.selection.addRange(range);
        } else {
          if (skip)
            var toRemove = range.cursor;
        }
        this.selection.addRange(newRange);
        if (toRemove)
          this.selection.substractPoint(toRemove);
      };
      this.transposeSelections = function(dir) {
        var session = this.session;
        var sel = session.multiSelect;
        var all = sel.ranges;
        for (var i = all.length; i--; ) {
          var range = all[i];
          if (range.isEmpty()) {
            var tmp = session.getWordRange(range.start.row, range.start.column);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
            range.end.row = tmp.end.row;
            range.end.column = tmp.end.column;
          }
        }
        sel.mergeOverlappingRanges();
        var words = [];
        for (var i = all.length; i--; ) {
          var range = all[i];
          words.unshift(session.getTextRange(range));
        }
        if (dir < 0)
          words.unshift(words.pop());
        else
          words.push(words.shift());
        for (var i = all.length; i--; ) {
          var range = all[i];
          var tmp = range.clone();
          session.replace(range, words[i]);
          range.start.row = tmp.start.row;
          range.start.column = tmp.start.column;
        }
        sel.fromOrientedRange(sel.ranges[0]);
      };
      this.selectMore = function(dir, skip, stopAtFirst) {
        var session = this.session;
        var sel = session.multiSelect;
        var range = sel.toOrientedRange();
        if (range.isEmpty()) {
          range = session.getWordRange(range.start.row, range.start.column);
          range.cursor = dir == -1 ? range.start : range.end;
          this.multiSelect.addRange(range);
          if (stopAtFirst)
            return;
        }
        var needle = session.getTextRange(range);
        var newRange = find(session, needle, dir);
        if (newRange) {
          newRange.cursor = dir == -1 ? newRange.start : newRange.end;
          this.session.unfold(newRange);
          this.multiSelect.addRange(newRange);
          this.renderer.scrollCursorIntoView(null, 0.5);
        }
        if (skip)
          this.multiSelect.substractPoint(range.cursor);
      };
      this.alignCursors = function() {
        var session = this.session;
        var sel = session.multiSelect;
        var ranges = sel.ranges;
        var row = -1;
        var sameRowRanges = ranges.filter(function(r2) {
          if (r2.cursor.row == row)
            return true;
          row = r2.cursor.row;
        });
        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
          var range = this.selection.getRange();
          var fr = range.start.row, lr = range.end.row;
          var guessRange = fr == lr;
          if (guessRange) {
            var max = this.session.getLength();
            var line;
            do {
              line = this.session.getLine(lr);
            } while (/[=:]/.test(line) && ++lr < max);
            do {
              line = this.session.getLine(fr);
            } while (/[=:]/.test(line) && --fr > 0);
            if (fr < 0)
              fr = 0;
            if (lr >= max)
              lr = max - 1;
          }
          var lines = this.session.removeFullLines(fr, lr);
          lines = this.$reAlignText(lines, guessRange);
          this.session.insert({row: fr, column: 0}, lines.join("\n") + "\n");
          if (!guessRange) {
            range.start.column = 0;
            range.end.column = lines[lines.length - 1].length;
          }
          this.selection.setRange(range);
        } else {
          sameRowRanges.forEach(function(r2) {
            sel.substractPoint(r2.cursor);
          });
          var maxCol = 0;
          var minSpace = Infinity;
          var spaceOffsets = ranges.map(function(r2) {
            var p2 = r2.cursor;
            var line2 = session.getLine(p2.row);
            var spaceOffset = line2.substr(p2.column).search(/\S/g);
            if (spaceOffset == -1)
              spaceOffset = 0;
            if (p2.column > maxCol)
              maxCol = p2.column;
            if (spaceOffset < minSpace)
              minSpace = spaceOffset;
            return spaceOffset;
          });
          ranges.forEach(function(r2, i) {
            var p2 = r2.cursor;
            var l2 = maxCol - p2.column;
            var d2 = spaceOffsets[i] - minSpace;
            if (l2 > d2)
              session.insert(p2, lang.stringRepeat(" ", l2 - d2));
            else
              session.remove(new Range(p2.row, p2.column, p2.row, p2.column - l2 + d2));
            r2.start.column = r2.end.column = maxCol;
            r2.start.row = r2.end.row = p2.row;
            r2.cursor = r2.end;
          });
          sel.fromOrientedRange(ranges[0]);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        }
      };
      this.$reAlignText = function(lines, forceLeft) {
        var isLeftAligned = true, isRightAligned = true;
        var startW, textW, endW;
        return lines.map(function(line) {
          var m2 = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
          if (!m2)
            return [line];
          if (startW == null) {
            startW = m2[1].length;
            textW = m2[2].length;
            endW = m2[3].length;
            return m2;
          }
          if (startW + textW + endW != m2[1].length + m2[2].length + m2[3].length)
            isRightAligned = false;
          if (startW != m2[1].length)
            isLeftAligned = false;
          if (startW > m2[1].length)
            startW = m2[1].length;
          if (textW < m2[2].length)
            textW = m2[2].length;
          if (endW > m2[3].length)
            endW = m2[3].length;
          return m2;
        }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
        function spaces(n2) {
          return lang.stringRepeat(" ", n2);
        }
        function alignLeft(m2) {
          return !m2[2] ? m2[0] : spaces(startW) + m2[2] + spaces(textW - m2[2].length + endW) + m2[4].replace(/^([=:])\s+/, "$1 ");
        }
        function alignRight(m2) {
          return !m2[2] ? m2[0] : spaces(startW + textW - m2[2].length) + m2[2] + spaces(endW) + m2[4].replace(/^([=:])\s+/, "$1 ");
        }
        function unAlign(m2) {
          return !m2[2] ? m2[0] : spaces(startW) + m2[2] + spaces(endW) + m2[4].replace(/^([=:])\s+/, "$1 ");
        }
      };
    }).call(Editor.prototype);
    function isSamePoint(p1, p2) {
      return p1.row == p2.row && p1.column == p2.column;
    }
    exports2.onSessionChange = function(e2) {
      var session = e2.session;
      if (session && !session.multiSelect) {
        session.$selectionMarkers = [];
        session.selection.$initRangeList();
        session.multiSelect = session.selection;
      }
      this.multiSelect = session && session.multiSelect;
      var oldSession = e2.oldSession;
      if (oldSession) {
        oldSession.multiSelect.off("addRange", this.$onAddRange);
        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
        oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
        oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
      }
      if (session) {
        session.multiSelect.on("addRange", this.$onAddRange);
        session.multiSelect.on("removeRange", this.$onRemoveRange);
        session.multiSelect.on("multiSelect", this.$onMultiSelect);
        session.multiSelect.on("singleSelect", this.$onSingleSelect);
        session.multiSelect.lead.on("change", this.$checkMultiselectChange);
        session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
      }
      if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
        if (session.selection.inMultiSelectMode)
          this.$onMultiSelect();
        else
          this.$onSingleSelect();
      }
    };
    function MultiSelect(editor) {
      if (editor.$multiselectOnSessionChange)
        return;
      editor.$onAddRange = editor.$onAddRange.bind(editor);
      editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
      editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
      editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
      editor.$multiselectOnSessionChange = exports2.onSessionChange.bind(editor);
      editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
      editor.$multiselectOnSessionChange(editor);
      editor.on("changeSession", editor.$multiselectOnSessionChange);
      editor.on("mousedown", onMouseDown);
      editor.commands.addCommands(commands.defaultCommands);
      addAltCursorListeners(editor);
    }
    function addAltCursorListeners(editor) {
      if (!editor.textInput)
        return;
      var el = editor.textInput.getElement();
      var altCursor = false;
      event.addListener(el, "keydown", function(e2) {
        var altDown = e2.keyCode == 18 && !(e2.ctrlKey || e2.shiftKey || e2.metaKey);
        if (editor.$blockSelectEnabled && altDown) {
          if (!altCursor) {
            editor.renderer.setMouseCursor("crosshair");
            altCursor = true;
          }
        } else if (altCursor) {
          reset();
        }
      }, editor);
      event.addListener(el, "keyup", reset, editor);
      event.addListener(el, "blur", reset, editor);
      function reset(e2) {
        if (altCursor) {
          editor.renderer.setMouseCursor("");
          altCursor = false;
        }
      }
    }
    exports2.MultiSelect = MultiSelect;
    require2("./config").defineOptions(Editor.prototype, "editor", {
      enableMultiselect: {
        set: function(val) {
          MultiSelect(this);
          if (val) {
            this.on("changeSession", this.$multiselectOnSessionChange);
            this.on("mousedown", onMouseDown);
          } else {
            this.off("changeSession", this.$multiselectOnSessionChange);
            this.off("mousedown", onMouseDown);
          }
        },
        value: true
      },
      enableBlockSelect: {
        set: function(val) {
          this.$blockSelectEnabled = val;
        },
        value: true
      }
    });
  });
  ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var Range = require2("../../range").Range;
    var FoldMode2 = exports2.FoldMode = function() {
    };
    (function() {
      this.foldingStartMarker = null;
      this.foldingStopMarker = null;
      this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.foldingStartMarker.test(line))
          return "start";
        if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line))
          return "end";
        return "";
      };
      this.getFoldWidgetRange = function(session, foldStyle, row) {
        return null;
      };
      this.indentationBlock = function(session, row, column) {
        var re2 = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re2);
        if (startLevel == -1)
          return;
        var startColumn = column || line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;
        while (++row < maxRow) {
          var level = session.getLine(row).search(re2);
          if (level == -1)
            continue;
          if (level <= startLevel) {
            var token = session.getTokenAt(row, 0);
            if (!token || token.type !== "string")
              break;
          }
          endRow = row;
        }
        if (endRow > startRow) {
          var endColumn = session.getLine(endRow).length;
          return new Range(startRow, startColumn, endRow, endColumn);
        }
      };
      this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
        var start = {row, column: column + 1};
        var end = session.$findClosingBracket(bracket, start, typeRe);
        if (!end)
          return;
        var fw = session.foldWidgets[end.row];
        if (fw == null)
          fw = session.getFoldWidget(end.row);
        if (fw == "start" && end.row > start.row) {
          end.row--;
          end.column = session.getLine(end.row).length;
        }
        return Range.fromPoints(start, end);
      };
      this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
        var end = {row, column};
        var start = session.$findOpeningBracket(bracket, end);
        if (!start)
          return;
        start.column++;
        end.column--;
        return Range.fromPoints(start, end);
      };
    }).call(FoldMode2.prototype);
  });
  ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
    exports2.isDark = false;
    exports2.cssClass = "ace-tm";
    exports2.cssText = '.ace-tm .ace_gutter {background: #f0f0f0;color: #333;}.ace-tm .ace_print-margin {width: 1px;background: #e8e8e8;}.ace-tm .ace_fold {background-color: #6B72E6;}.ace-tm {background-color: #FFFFFF;color: black;}.ace-tm .ace_cursor {color: black;}.ace-tm .ace_invisible {color: rgb(191, 191, 191);}.ace-tm .ace_storage,.ace-tm .ace_keyword {color: blue;}.ace-tm .ace_constant {color: rgb(197, 6, 11);}.ace-tm .ace_constant.ace_buildin {color: rgb(88, 72, 246);}.ace-tm .ace_constant.ace_language {color: rgb(88, 92, 246);}.ace-tm .ace_constant.ace_library {color: rgb(6, 150, 14);}.ace-tm .ace_invalid {background-color: rgba(255, 0, 0, 0.1);color: red;}.ace-tm .ace_support.ace_function {color: rgb(60, 76, 114);}.ace-tm .ace_support.ace_constant {color: rgb(6, 150, 14);}.ace-tm .ace_support.ace_type,.ace-tm .ace_support.ace_class {color: rgb(109, 121, 222);}.ace-tm .ace_keyword.ace_operator {color: rgb(104, 118, 135);}.ace-tm .ace_string {color: rgb(3, 106, 7);}.ace-tm .ace_comment {color: rgb(76, 136, 107);}.ace-tm .ace_comment.ace_doc {color: rgb(0, 102, 255);}.ace-tm .ace_comment.ace_doc.ace_tag {color: rgb(128, 159, 191);}.ace-tm .ace_constant.ace_numeric {color: rgb(0, 0, 205);}.ace-tm .ace_variable {color: rgb(49, 132, 149);}.ace-tm .ace_xml-pe {color: rgb(104, 104, 91);}.ace-tm .ace_entity.ace_name.ace_function {color: #0000A2;}.ace-tm .ace_heading {color: rgb(12, 7, 255);}.ace-tm .ace_list {color:rgb(185, 6, 144);}.ace-tm .ace_meta.ace_tag {color:rgb(0, 22, 142);}.ace-tm .ace_string.ace_regex {color: rgb(255, 0, 0)}.ace-tm .ace_marker-layer .ace_selection {background: rgb(181, 213, 255);}.ace-tm.ace_multiselect .ace_selection.ace_start {box-shadow: 0 0 3px 0px white;}.ace-tm .ace_marker-layer .ace_step {background: rgb(252, 255, 0);}.ace-tm .ace_marker-layer .ace_stack {background: rgb(164, 229, 101);}.ace-tm .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgb(192, 192, 192);}.ace-tm .ace_marker-layer .ace_active-line {background: rgba(0, 0, 0, 0.07);}.ace-tm .ace_gutter-active-line {background-color : #dcdcdc;}.ace-tm .ace_marker-layer .ace_selected-word {background: rgb(250, 250, 255);border: 1px solid rgb(200, 200, 250);}.ace-tm .ace_indent-guide {background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}';
    exports2.$id = "ace/theme/textmate";
    var dom = require2("../lib/dom");
    dom.importCssString(exports2.cssText, exports2.cssClass);
  });
  ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
    var dom = require2("./lib/dom");
    function LineWidgets(session) {
      this.session = session;
      this.session.widgetManager = this;
      this.session.getRowLength = this.getRowLength;
      this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
      this.updateOnChange = this.updateOnChange.bind(this);
      this.renderWidgets = this.renderWidgets.bind(this);
      this.measureWidgets = this.measureWidgets.bind(this);
      this.session._changedWidgets = [];
      this.$onChangeEditor = this.$onChangeEditor.bind(this);
      this.session.on("change", this.updateOnChange);
      this.session.on("changeFold", this.updateOnFold);
      this.session.on("changeEditor", this.$onChangeEditor);
    }
    (function() {
      this.getRowLength = function(row) {
        var h2;
        if (this.lineWidgets)
          h2 = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else
          h2 = 0;
        if (!this.$useWrapMode || !this.$wrapData[row]) {
          return 1 + h2;
        } else {
          return this.$wrapData[row].length + 1 + h2;
        }
      };
      this.$getWidgetScreenLength = function() {
        var screenRows = 0;
        this.lineWidgets.forEach(function(w2) {
          if (w2 && w2.rowCount && !w2.hidden)
            screenRows += w2.rowCount;
        });
        return screenRows;
      };
      this.$onChangeEditor = function(e2) {
        this.attach(e2.editor);
      };
      this.attach = function(editor) {
        if (editor && editor.widgetManager && editor.widgetManager != this)
          editor.widgetManager.detach();
        if (this.editor == editor)
          return;
        this.detach();
        this.editor = editor;
        if (editor) {
          editor.widgetManager = this;
          editor.renderer.on("beforeRender", this.measureWidgets);
          editor.renderer.on("afterRender", this.renderWidgets);
        }
      };
      this.detach = function(e2) {
        var editor = this.editor;
        if (!editor)
          return;
        this.editor = null;
        editor.widgetManager = null;
        editor.renderer.off("beforeRender", this.measureWidgets);
        editor.renderer.off("afterRender", this.renderWidgets);
        var lineWidgets = this.session.lineWidgets;
        lineWidgets && lineWidgets.forEach(function(w2) {
          if (w2 && w2.el && w2.el.parentNode) {
            w2._inDocument = false;
            w2.el.parentNode.removeChild(w2.el);
          }
        });
      };
      this.updateOnFold = function(e2, session) {
        var lineWidgets = session.lineWidgets;
        if (!lineWidgets || !e2.action)
          return;
        var fold = e2.data;
        var start = fold.start.row;
        var end = fold.end.row;
        var hide = e2.action == "add";
        for (var i = start + 1; i < end; i++) {
          if (lineWidgets[i])
            lineWidgets[i].hidden = hide;
        }
        if (lineWidgets[end]) {
          if (hide) {
            if (!lineWidgets[start])
              lineWidgets[start] = lineWidgets[end];
            else
              lineWidgets[end].hidden = hide;
          } else {
            if (lineWidgets[start] == lineWidgets[end])
              lineWidgets[start] = void 0;
            lineWidgets[end].hidden = hide;
          }
        }
      };
      this.updateOnChange = function(delta) {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
          return;
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;
        if (len === 0)
          ;
        else if (delta.action == "remove") {
          var removed = lineWidgets.splice(startRow + 1, len);
          if (!lineWidgets[startRow] && removed[removed.length - 1]) {
            lineWidgets[startRow] = removed.pop();
          }
          removed.forEach(function(w2) {
            w2 && this.removeLineWidget(w2);
          }, this);
          this.$updateRows();
        } else {
          var args = new Array(len);
          if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
            if (delta.start.column > lineWidgets[startRow].column)
              startRow++;
          }
          args.unshift(startRow, 0);
          lineWidgets.splice.apply(lineWidgets, args);
          this.$updateRows();
        }
      };
      this.$updateRows = function() {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
          return;
        var noWidgets = true;
        lineWidgets.forEach(function(w2, i) {
          if (w2) {
            noWidgets = false;
            w2.row = i;
            while (w2.$oldWidget) {
              w2.$oldWidget.row = i;
              w2 = w2.$oldWidget;
            }
          }
        });
        if (noWidgets)
          this.session.lineWidgets = null;
      };
      this.$registerLineWidget = function(w2) {
        if (!this.session.lineWidgets)
          this.session.lineWidgets = new Array(this.session.getLength());
        var old = this.session.lineWidgets[w2.row];
        if (old) {
          w2.$oldWidget = old;
          if (old.el && old.el.parentNode) {
            old.el.parentNode.removeChild(old.el);
            old._inDocument = false;
          }
        }
        this.session.lineWidgets[w2.row] = w2;
        return w2;
      };
      this.addLineWidget = function(w2) {
        this.$registerLineWidget(w2);
        w2.session = this.session;
        if (!this.editor)
          return w2;
        var renderer = this.editor.renderer;
        if (w2.html && !w2.el) {
          w2.el = dom.createElement("div");
          w2.el.innerHTML = w2.html;
        }
        if (w2.el) {
          dom.addCssClass(w2.el, "ace_lineWidgetContainer");
          w2.el.style.position = "absolute";
          w2.el.style.zIndex = 5;
          renderer.container.appendChild(w2.el);
          w2._inDocument = true;
          if (!w2.coverGutter) {
            w2.el.style.zIndex = 3;
          }
          if (w2.pixelHeight == null) {
            w2.pixelHeight = w2.el.offsetHeight;
          }
        }
        if (w2.rowCount == null) {
          w2.rowCount = w2.pixelHeight / renderer.layerConfig.lineHeight;
        }
        var fold = this.session.getFoldAt(w2.row, 0);
        w2.$fold = fold;
        if (fold) {
          var lineWidgets = this.session.lineWidgets;
          if (w2.row == fold.end.row && !lineWidgets[fold.start.row])
            lineWidgets[fold.start.row] = w2;
          else
            w2.hidden = true;
        }
        this.session._emit("changeFold", {data: {start: {row: w2.row}}});
        this.$updateRows();
        this.renderWidgets(null, renderer);
        this.onWidgetChanged(w2);
        return w2;
      };
      this.removeLineWidget = function(w2) {
        w2._inDocument = false;
        w2.session = null;
        if (w2.el && w2.el.parentNode)
          w2.el.parentNode.removeChild(w2.el);
        if (w2.editor && w2.editor.destroy)
          try {
            w2.editor.destroy();
          } catch (e2) {
          }
        if (this.session.lineWidgets) {
          var w1 = this.session.lineWidgets[w2.row];
          if (w1 == w2) {
            this.session.lineWidgets[w2.row] = w2.$oldWidget;
            if (w2.$oldWidget)
              this.onWidgetChanged(w2.$oldWidget);
          } else {
            while (w1) {
              if (w1.$oldWidget == w2) {
                w1.$oldWidget = w2.$oldWidget;
                break;
              }
              w1 = w1.$oldWidget;
            }
          }
        }
        this.session._emit("changeFold", {data: {start: {row: w2.row}}});
        this.$updateRows();
      };
      this.getWidgetsAtRow = function(row) {
        var lineWidgets = this.session.lineWidgets;
        var w2 = lineWidgets && lineWidgets[row];
        var list = [];
        while (w2) {
          list.push(w2);
          w2 = w2.$oldWidget;
        }
        return list;
      };
      this.onWidgetChanged = function(w2) {
        this.session._changedWidgets.push(w2);
        this.editor && this.editor.renderer.updateFull();
      };
      this.measureWidgets = function(e2, renderer) {
        var changedWidgets = this.session._changedWidgets;
        var config = renderer.layerConfig;
        if (!changedWidgets || !changedWidgets.length)
          return;
        var min = Infinity;
        for (var i = 0; i < changedWidgets.length; i++) {
          var w2 = changedWidgets[i];
          if (!w2 || !w2.el)
            continue;
          if (w2.session != this.session)
            continue;
          if (!w2._inDocument) {
            if (this.session.lineWidgets[w2.row] != w2)
              continue;
            w2._inDocument = true;
            renderer.container.appendChild(w2.el);
          }
          w2.h = w2.el.offsetHeight;
          if (!w2.fixedWidth) {
            w2.w = w2.el.offsetWidth;
            w2.screenWidth = Math.ceil(w2.w / config.characterWidth);
          }
          var rowCount = w2.h / config.lineHeight;
          if (w2.coverLine) {
            rowCount -= this.session.getRowLineCount(w2.row);
            if (rowCount < 0)
              rowCount = 0;
          }
          if (w2.rowCount != rowCount) {
            w2.rowCount = rowCount;
            if (w2.row < min)
              min = w2.row;
          }
        }
        if (min != Infinity) {
          this.session._emit("changeFold", {data: {start: {row: min}}});
          this.session.lineWidgetWidth = null;
        }
        this.session._changedWidgets = [];
      };
      this.renderWidgets = function(e2, renderer) {
        var config = renderer.layerConfig;
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
          return;
        var first = Math.min(this.firstRow, config.firstRow);
        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
        while (first > 0 && !lineWidgets[first])
          first--;
        this.firstRow = config.firstRow;
        this.lastRow = config.lastRow;
        renderer.$cursorLayer.config = config;
        for (var i = first; i <= last; i++) {
          var w2 = lineWidgets[i];
          if (!w2 || !w2.el)
            continue;
          if (w2.hidden) {
            w2.el.style.top = -100 - (w2.pixelHeight || 0) + "px";
            continue;
          }
          if (!w2._inDocument) {
            w2._inDocument = true;
            renderer.container.appendChild(w2.el);
          }
          var top = renderer.$cursorLayer.getPixelPosition({row: i, column: 0}, true).top;
          if (!w2.coverLine)
            top += config.lineHeight * this.session.getRowLineCount(w2.row);
          w2.el.style.top = top - config.offset + "px";
          var left = w2.coverGutter ? 0 : renderer.gutterWidth;
          if (!w2.fixedWidth)
            left -= renderer.scrollLeft;
          w2.el.style.left = left + "px";
          if (w2.fullWidth && w2.screenWidth) {
            w2.el.style.minWidth = config.width + 2 * config.padding + "px";
          }
          if (w2.fixedWidth) {
            w2.el.style.right = renderer.scrollBar.getWidth() + "px";
          } else {
            w2.el.style.right = "";
          }
        }
      };
    }).call(LineWidgets.prototype);
    exports2.LineWidgets = LineWidgets;
  });
  ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/line_widgets", "ace/lib/dom", "ace/range"], function(require2, exports2, module2) {
    var LineWidgets = require2("../line_widgets").LineWidgets;
    var dom = require2("../lib/dom");
    var Range = require2("../range").Range;
    function binarySearch(array, needle, comparator) {
      var first = 0;
      var last = array.length - 1;
      while (first <= last) {
        var mid = first + last >> 1;
        var c2 = comparator(needle, array[mid]);
        if (c2 > 0)
          first = mid + 1;
        else if (c2 < 0)
          last = mid - 1;
        else
          return mid;
      }
      return -(first + 1);
    }
    function findAnnotations(session, row, dir) {
      var annotations = session.getAnnotations().sort(Range.comparePoints);
      if (!annotations.length)
        return;
      var i = binarySearch(annotations, {row, column: -1}, Range.comparePoints);
      if (i < 0)
        i = -i - 1;
      if (i >= annotations.length)
        i = dir > 0 ? 0 : annotations.length - 1;
      else if (i === 0 && dir < 0)
        i = annotations.length - 1;
      var annotation = annotations[i];
      if (!annotation || !dir)
        return;
      if (annotation.row === row) {
        do {
          annotation = annotations[i += dir];
        } while (annotation && annotation.row === row);
        if (!annotation)
          return annotations.slice();
      }
      var matched = [];
      row = annotation.row;
      do {
        matched[dir < 0 ? "unshift" : "push"](annotation);
        annotation = annotations[i += dir];
      } while (annotation && annotation.row == row);
      return matched.length && matched;
    }
    exports2.showErrorMarker = function(editor, dir) {
      var session = editor.session;
      if (!session.widgetManager) {
        session.widgetManager = new LineWidgets(session);
        session.widgetManager.attach(editor);
      }
      var pos = editor.getCursorPosition();
      var row = pos.row;
      var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w3) {
        return w3.type == "errorMarker";
      })[0];
      if (oldWidget) {
        oldWidget.destroy();
      } else {
        row -= dir;
      }
      var annotations = findAnnotations(session, row, dir);
      var gutterAnno;
      if (annotations) {
        var annotation = annotations[0];
        pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
        pos.row = annotation.row;
        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
      } else if (oldWidget) {
        return;
      } else {
        gutterAnno = {
          text: ["Looks good!"],
          className: "ace_ok"
        };
      }
      editor.session.unfold(pos.row);
      editor.selection.moveToPosition(pos);
      var w2 = {
        row: pos.row,
        fixedWidth: true,
        coverGutter: true,
        el: dom.createElement("div"),
        type: "errorMarker"
      };
      var el = w2.el.appendChild(dom.createElement("div"));
      var arrow = w2.el.appendChild(dom.createElement("div"));
      arrow.className = "error_widget_arrow " + gutterAnno.className;
      var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
      arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
      w2.el.className = "error_widget_wrapper";
      el.className = "error_widget " + gutterAnno.className;
      el.innerHTML = gutterAnno.text.join("<br>");
      el.appendChild(dom.createElement("div"));
      var kb2 = function(_, hashId, keyString) {
        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
          w2.destroy();
          return {command: "null"};
        }
      };
      w2.destroy = function() {
        if (editor.$mouseHandler.isMousePressed)
          return;
        editor.keyBinding.removeKeyboardHandler(kb2);
        session.widgetManager.removeLineWidget(w2);
        editor.off("changeSelection", w2.destroy);
        editor.off("changeSession", w2.destroy);
        editor.off("mouseup", w2.destroy);
        editor.off("change", w2.destroy);
      };
      editor.keyBinding.addKeyboardHandler(kb2);
      editor.on("changeSelection", w2.destroy);
      editor.on("changeSession", w2.destroy);
      editor.on("mouseup", w2.destroy);
      editor.on("change", w2.destroy);
      editor.session.widgetManager.addLineWidget(w2);
      w2.el.onmousedown = editor.focus.bind(editor);
      editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w2.el.offsetHeight});
    };
    dom.importCssString("    .error_widget_wrapper {        background: inherit;        color: inherit;        border:none    }    .error_widget {        border-top: solid 2px;        border-bottom: solid 2px;        margin: 5px 0;        padding: 10px 40px;        white-space: pre-wrap;    }    .error_widget.ace_error, .error_widget_arrow.ace_error{        border-color: #ff5a5a    }    .error_widget.ace_warning, .error_widget_arrow.ace_warning{        border-color: #F1D817    }    .error_widget.ace_info, .error_widget_arrow.ace_info{        border-color: #5a5a5a    }    .error_widget.ace_ok, .error_widget_arrow.ace_ok{        border-color: #5aaa5a    }    .error_widget_arrow {        position: absolute;        border: solid 5px;        border-top-color: transparent!important;        border-right-color: transparent!important;        border-left-color: transparent!important;        top: -5px;    }", "");
  });
  ace.define("ace/ace", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/dom", "ace/lib/event", "ace/range", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config"], function(require2, exports2, module2) {
    require2("./lib/fixoldbrowsers");
    var dom = require2("./lib/dom");
    var event = require2("./lib/event");
    var Range = require2("./range").Range;
    var Editor = require2("./editor").Editor;
    var EditSession = require2("./edit_session").EditSession;
    var UndoManager = require2("./undomanager").UndoManager;
    var Renderer = require2("./virtual_renderer").VirtualRenderer;
    require2("./worker/worker_client");
    require2("./keyboard/hash_handler");
    require2("./placeholder");
    require2("./multi_select");
    require2("./mode/folding/fold_mode");
    require2("./theme/textmate");
    require2("./ext/error_marker");
    exports2.config = require2("./config");
    exports2.require = require2;
    exports2.edit = function(el, options) {
      if (typeof el == "string") {
        var _id = el;
        el = document.getElementById(_id);
        if (!el)
          throw new Error("ace.edit can't find div #" + _id);
      }
      if (el && el.env && el.env.editor instanceof Editor)
        return el.env.editor;
      var value = "";
      if (el && /input|textarea/i.test(el.tagName)) {
        var oldNode = el;
        value = oldNode.value;
        el = dom.createElement("pre");
        oldNode.parentNode.replaceChild(el, oldNode);
      } else if (el) {
        value = el.textContent;
        el.innerHTML = "";
      }
      var doc = exports2.createEditSession(value);
      var editor = new Editor(new Renderer(el), doc, options);
      var env = {
        document: doc,
        editor,
        onResize: editor.resize.bind(editor, null)
      };
      if (oldNode)
        env.textarea = oldNode;
      event.addListener(window, "resize", env.onResize);
      editor.on("destroy", function() {
        event.removeListener(window, "resize", env.onResize);
        env.editor.container.env = null;
      });
      editor.container.env = editor.env = env;
      return editor;
    };
    exports2.createEditSession = function(text, mode) {
      var doc = new EditSession(text, mode);
      doc.setUndoManager(new UndoManager());
      return doc;
    };
    exports2.Range = Range;
    exports2.Editor = Editor;
    exports2.EditSession = EditSession;
    exports2.UndoManager = UndoManager;
    exports2.VirtualRenderer = Renderer;
    exports2.version = exports2.config.version;
  });
  (function() {
    ace.require(["ace/ace"], function(a) {
      if (a) {
        a.config.init(true);
        a.define = ace.define;
      }
      if (!window.ace)
        window.ace = a;
      for (var key in a)
        if (a.hasOwnProperty(key))
          window.ace[key] = a[key];
      window.ace["default"] = window.ace;
      if (module) {
        module.exports = window.ace;
      }
    });
  })();
});
var lodash_isequal = createCommonjsModule(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arrayFilter(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function arrayPush(array, values) {
    var index2 = -1, length = values.length, offset = array.length;
    while (++index2 < length) {
      array[offset + index2] = values[index2];
    }
    return array;
  }
  function arraySome(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty3 = objectProto2.hasOwnProperty;
  var maskSrcKey2 = function() {
    var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto2.toString;
  var reIsNative2 = RegExp("^" + funcToString2.call(hasOwnProperty3).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer = moduleExports ? root2.Buffer : void 0, Symbol3 = root2.Symbol, Uint8Array2 = root2.Uint8Array, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, symToStringTag = Symbol3 ? Symbol3.toStringTag : void 0;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView = getNative2(root2, "DataView"), Map3 = getNative2(root2, "Map"), Promise2 = getNative2(root2, "Promise"), Set2 = getNative2(root2, "Set"), WeakMap2 = getNative2(root2, "WeakMap"), nativeCreate2 = getNative2(Object, "create");
  var dataViewCtorString = toSource2(DataView), mapCtorString = toSource2(Map3), promiseCtorString = toSource2(Promise2), setCtorString = toSource2(Set2), weakMapCtorString = toSource2(WeakMap2);
  var symbolProto2 = Symbol3 ? Symbol3.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    this.size = 0;
  }
  function hashDelete2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty3.call(data, key) ? data[key] : void 0;
  }
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty3.call(data, key);
  }
  function hashSet2(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash2(),
      map: new (Map3 || ListCache2)(),
      string: new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    var result = getMapData2(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    var data = getMapData2(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function SetCache(values) {
    var index2 = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache2();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED2);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries) {
    var data = this.__data__ = new ListCache2(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache2();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache2) {
      var pairs2 = data.__data__;
      if (!Map3 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache2(pairs2);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf2(array, key) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsNative2(value) {
    if (!isObject3(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty3.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index2 < arrLength) {
      var arrValue = array[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq2(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag2:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty3.call(other, key))) {
        return false;
      }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  function getMapData2(map2, key) {
    var data = map2.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative2(object, key) {
    var value = getValue2(object, key);
    return baseIsNative2(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e2) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map3 && getTag(new Map3()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable2(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function objectToString2(value) {
    return nativeObjectToString.call(value);
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }
  function isFunction2(value) {
    if (!isObject3(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag2 || tag == genTag2 || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject3(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = isEqual;
});
var editorOptions_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.getAceInstance = exports.debounce = exports.editorEvents = exports.editorOptions = void 0;
  var editorOptions = [
    "minLines",
    "maxLines",
    "readOnly",
    "highlightActiveLine",
    "tabSize",
    "enableBasicAutocompletion",
    "enableLiveAutocompletion",
    "enableSnippets"
  ];
  exports.editorOptions = editorOptions;
  var editorEvents = [
    "onChange",
    "onFocus",
    "onInput",
    "onBlur",
    "onCopy",
    "onPaste",
    "onSelectionChange",
    "onCursorChange",
    "onScroll",
    "handleOptions",
    "updateRef"
  ];
  exports.editorEvents = editorEvents;
  var getAceInstance = function() {
    var ace2;
    if (typeof window === "undefined") {
      commonjsGlobal.window = {};
      ace2 = ace_1;
      delete commonjsGlobal.window;
    } else if (window.ace) {
      ace2 = window.ace;
      ace2.acequire = window.ace.require || window.ace.acequire;
    } else {
      ace2 = ace_1;
    }
    return ace2;
  };
  exports.getAceInstance = getAceInstance;
  var debounce = function(fn, delay) {
    var timer = null;
    return function() {
      var context2 = this;
      var args = arguments;
      clearTimeout(timer);
      timer = setTimeout(function() {
        fn.apply(context2, args);
      }, delay);
    };
  };
  exports.debounce = debounce;
});
var ace_1$1 = createCommonjsModule(function(module, exports) {
  var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p2))
            d3[p2] = b3[p2];
      };
      return extendStatics(d2, b2);
    };
    return function(d2, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
  }();
  var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
        s = arguments[i];
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2))
            t2[p2] = s[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  var ace2 = editorOptions_1.getAceInstance();
  var ReactAce = function(_super) {
    __extends(ReactAce2, _super);
    function ReactAce2(props) {
      var _this = _super.call(this, props) || this;
      editorOptions_1.editorEvents.forEach(function(method) {
        _this[method] = _this[method].bind(_this);
      });
      _this.debounce = editorOptions_1.debounce;
      return _this;
    }
    ReactAce2.prototype.isInShadow = function(node) {
      var parent = node && node.parentNode;
      while (parent) {
        if (parent.toString() === "[object ShadowRoot]") {
          return true;
        }
        parent = parent.parentNode;
      }
      return false;
    };
    ReactAce2.prototype.componentDidMount = function() {
      var _this = this;
      var _a = this.props, className = _a.className, onBeforeLoad = _a.onBeforeLoad, onValidate = _a.onValidate, mode = _a.mode, focus = _a.focus, theme = _a.theme, fontSize = _a.fontSize, value = _a.value, defaultValue = _a.defaultValue, showGutter = _a.showGutter, wrapEnabled = _a.wrapEnabled, showPrintMargin = _a.showPrintMargin, _b = _a.scrollMargin, scrollMargin = _b === void 0 ? [0, 0, 0, 0] : _b, keyboardHandler = _a.keyboardHandler, onLoad = _a.onLoad, commands = _a.commands, annotations = _a.annotations, markers = _a.markers, placeholder = _a.placeholder;
      this.editor = ace2.edit(this.refEditor);
      if (onBeforeLoad) {
        onBeforeLoad(ace2);
      }
      var editorProps = Object.keys(this.props.editorProps);
      for (var i = 0; i < editorProps.length; i++) {
        this.editor[editorProps[i]] = this.props.editorProps[editorProps[i]];
      }
      if (this.props.debounceChangePeriod) {
        this.onChange = this.debounce(this.onChange, this.props.debounceChangePeriod);
      }
      this.editor.renderer.setScrollMargin(scrollMargin[0], scrollMargin[1], scrollMargin[2], scrollMargin[3]);
      if (this.isInShadow(this.refEditor)) {
        this.editor.renderer.attachToShadowRoot();
      }
      this.editor.getSession().setMode(typeof mode === "string" ? "ace/mode/" + mode : mode);
      if (theme && theme !== "")
        this.editor.setTheme("ace/theme/" + theme);
      this.editor.setFontSize(typeof fontSize === "number" ? fontSize + "px" : fontSize);
      this.editor.getSession().setValue(!defaultValue ? value || "" : defaultValue);
      if (this.props.navigateToFileEnd) {
        this.editor.navigateFileEnd();
      }
      this.editor.renderer.setShowGutter(showGutter);
      this.editor.getSession().setUseWrapMode(wrapEnabled);
      this.editor.setShowPrintMargin(showPrintMargin);
      this.editor.on("focus", this.onFocus);
      this.editor.on("blur", this.onBlur);
      this.editor.on("copy", this.onCopy);
      this.editor.on("paste", this.onPaste);
      this.editor.on("change", this.onChange);
      this.editor.on("input", this.onInput);
      if (placeholder) {
        this.updatePlaceholder();
      }
      this.editor.getSession().selection.on("changeSelection", this.onSelectionChange);
      this.editor.getSession().selection.on("changeCursor", this.onCursorChange);
      if (onValidate) {
        this.editor.getSession().on("changeAnnotation", function() {
          var annotations2 = _this.editor.getSession().getAnnotations();
          _this.props.onValidate(annotations2);
        });
      }
      this.editor.session.on("changeScrollTop", this.onScroll);
      this.editor.getSession().setAnnotations(annotations || []);
      if (markers && markers.length > 0) {
        this.handleMarkers(markers);
      }
      var availableOptions = this.editor.$options;
      editorOptions_1.editorOptions.forEach(function(option) {
        if (availableOptions.hasOwnProperty(option)) {
          _this.editor.setOption(option, _this.props[option]);
        } else if (_this.props[option]) {
          console.warn("ReactAce: editor option " + option + " was activated but not found. Did you need to import a related tool or did you possibly mispell the option?");
        }
      });
      this.handleOptions(this.props);
      if (Array.isArray(commands)) {
        commands.forEach(function(command) {
          if (typeof command.exec === "string") {
            _this.editor.commands.bindKey(command.bindKey, command.exec);
          } else {
            _this.editor.commands.addCommand(command);
          }
        });
      }
      if (keyboardHandler) {
        this.editor.setKeyboardHandler("ace/keyboard/" + keyboardHandler);
      }
      if (className) {
        this.refEditor.className += " " + className;
      }
      if (onLoad) {
        onLoad(this.editor);
      }
      this.editor.resize();
      if (focus) {
        this.editor.focus();
      }
    };
    ReactAce2.prototype.componentDidUpdate = function(prevProps) {
      var oldProps = prevProps;
      var nextProps = this.props;
      for (var i = 0; i < editorOptions_1.editorOptions.length; i++) {
        var option = editorOptions_1.editorOptions[i];
        if (nextProps[option] !== oldProps[option]) {
          this.editor.setOption(option, nextProps[option]);
        }
      }
      if (nextProps.className !== oldProps.className) {
        var appliedClasses = this.refEditor.className;
        var appliedClassesArray_1 = appliedClasses.trim().split(" ");
        var oldClassesArray = oldProps.className.trim().split(" ");
        oldClassesArray.forEach(function(oldClass) {
          var index2 = appliedClassesArray_1.indexOf(oldClass);
          appliedClassesArray_1.splice(index2, 1);
        });
        this.refEditor.className = " " + nextProps.className + " " + appliedClassesArray_1.join(" ");
      }
      if (this.editor && nextProps.value != null && this.editor.getValue() !== nextProps.value) {
        this.silent = true;
        var pos = this.editor.session.selection.toJSON();
        this.editor.setValue(nextProps.value, nextProps.cursorStart);
        this.editor.session.selection.fromJSON(pos);
        this.silent = false;
      }
      if (nextProps.placeholder !== oldProps.placeholder) {
        this.updatePlaceholder();
      }
      if (nextProps.mode !== oldProps.mode) {
        this.editor.getSession().setMode(typeof nextProps.mode === "string" ? "ace/mode/" + nextProps.mode : nextProps.mode);
      }
      if (nextProps.theme !== oldProps.theme) {
        this.editor.setTheme("ace/theme/" + nextProps.theme);
      }
      if (nextProps.keyboardHandler !== oldProps.keyboardHandler) {
        if (nextProps.keyboardHandler) {
          this.editor.setKeyboardHandler("ace/keyboard/" + nextProps.keyboardHandler);
        } else {
          this.editor.setKeyboardHandler(null);
        }
      }
      if (nextProps.fontSize !== oldProps.fontSize) {
        this.editor.setFontSize(typeof nextProps.fontSize === "number" ? nextProps.fontSize + "px" : nextProps.fontSize);
      }
      if (nextProps.wrapEnabled !== oldProps.wrapEnabled) {
        this.editor.getSession().setUseWrapMode(nextProps.wrapEnabled);
      }
      if (nextProps.showPrintMargin !== oldProps.showPrintMargin) {
        this.editor.setShowPrintMargin(nextProps.showPrintMargin);
      }
      if (nextProps.showGutter !== oldProps.showGutter) {
        this.editor.renderer.setShowGutter(nextProps.showGutter);
      }
      if (!lodash_isequal(nextProps.setOptions, oldProps.setOptions)) {
        this.handleOptions(nextProps);
      }
      if (!lodash_isequal(nextProps.annotations, oldProps.annotations)) {
        this.editor.getSession().setAnnotations(nextProps.annotations || []);
      }
      if (!lodash_isequal(nextProps.markers, oldProps.markers) && Array.isArray(nextProps.markers)) {
        this.handleMarkers(nextProps.markers);
      }
      if (!lodash_isequal(nextProps.scrollMargin, oldProps.scrollMargin)) {
        this.handleScrollMargins(nextProps.scrollMargin);
      }
      if (prevProps.height !== this.props.height || prevProps.width !== this.props.width) {
        this.editor.resize();
      }
      if (this.props.focus && !prevProps.focus) {
        this.editor.focus();
      }
    };
    ReactAce2.prototype.handleScrollMargins = function(margins) {
      if (margins === void 0) {
        margins = [0, 0, 0, 0];
      }
      this.editor.renderer.setScrollMargin(margins[0], margins[1], margins[2], margins[3]);
    };
    ReactAce2.prototype.componentWillUnmount = function() {
      this.editor.destroy();
      this.editor = null;
    };
    ReactAce2.prototype.onChange = function(event) {
      if (this.props.onChange && !this.silent) {
        var value = this.editor.getValue();
        this.props.onChange(value, event);
      }
    };
    ReactAce2.prototype.onSelectionChange = function(event) {
      if (this.props.onSelectionChange) {
        var value = this.editor.getSelection();
        this.props.onSelectionChange(value, event);
      }
    };
    ReactAce2.prototype.onCursorChange = function(event) {
      if (this.props.onCursorChange) {
        var value = this.editor.getSelection();
        this.props.onCursorChange(value, event);
      }
    };
    ReactAce2.prototype.onInput = function(event) {
      if (this.props.onInput) {
        this.props.onInput(event);
      }
      if (this.props.placeholder) {
        this.updatePlaceholder();
      }
    };
    ReactAce2.prototype.onFocus = function(event) {
      if (this.props.onFocus) {
        this.props.onFocus(event, this.editor);
      }
    };
    ReactAce2.prototype.onBlur = function(event) {
      if (this.props.onBlur) {
        this.props.onBlur(event, this.editor);
      }
    };
    ReactAce2.prototype.onCopy = function(_a) {
      var text = _a.text;
      if (this.props.onCopy) {
        this.props.onCopy(text);
      }
    };
    ReactAce2.prototype.onPaste = function(_a) {
      var text = _a.text;
      if (this.props.onPaste) {
        this.props.onPaste(text);
      }
    };
    ReactAce2.prototype.onScroll = function() {
      if (this.props.onScroll) {
        this.props.onScroll(this.editor);
      }
    };
    ReactAce2.prototype.handleOptions = function(props) {
      var setOptions = Object.keys(props.setOptions);
      for (var y3 = 0; y3 < setOptions.length; y3++) {
        this.editor.setOption(setOptions[y3], props.setOptions[setOptions[y3]]);
      }
    };
    ReactAce2.prototype.handleMarkers = function(markers) {
      var _this = this;
      var currentMarkers = this.editor.getSession().getMarkers(true);
      for (var i in currentMarkers) {
        if (currentMarkers.hasOwnProperty(i)) {
          this.editor.getSession().removeMarker(currentMarkers[i].id);
        }
      }
      currentMarkers = this.editor.getSession().getMarkers(false);
      for (var i in currentMarkers) {
        if (currentMarkers.hasOwnProperty(i) && currentMarkers[i].clazz !== "ace_active-line" && currentMarkers[i].clazz !== "ace_selected-word") {
          this.editor.getSession().removeMarker(currentMarkers[i].id);
        }
      }
      markers.forEach(function(_a) {
        var startRow = _a.startRow, startCol = _a.startCol, endRow = _a.endRow, endCol = _a.endCol, className = _a.className, type2 = _a.type, _b = _a.inFront, inFront = _b === void 0 ? false : _b;
        var range = new ace_1.Range(startRow, startCol, endRow, endCol);
        _this.editor.getSession().addMarker(range, className, type2, inFront);
      });
    };
    ReactAce2.prototype.updatePlaceholder = function() {
      var editor = this.editor;
      var placeholder = this.props.placeholder;
      var showPlaceholder = !editor.session.getValue().length;
      var node = editor.renderer.placeholderNode;
      if (!showPlaceholder && node) {
        editor.renderer.scroller.removeChild(editor.renderer.placeholderNode);
        editor.renderer.placeholderNode = null;
      } else if (showPlaceholder && !node) {
        node = editor.renderer.placeholderNode = document.createElement("div");
        node.textContent = placeholder || "";
        node.className = "ace_comment ace_placeholder";
        node.style.padding = "0 9px";
        node.style.position = "absolute";
        node.style.zIndex = "3";
        editor.renderer.scroller.appendChild(node);
      } else if (showPlaceholder && node) {
        node.textContent = placeholder;
      }
    };
    ReactAce2.prototype.updateRef = function(item) {
      this.refEditor = item;
    };
    ReactAce2.prototype.render = function() {
      var _a = this.props, name = _a.name, width = _a.width, height = _a.height, style = _a.style;
      var divStyle = __assign({width, height}, style);
      return react.createElement("div", {ref: this.updateRef, id: name, style: divStyle});
    };
    ReactAce2.propTypes = {
      mode: propTypes.oneOfType([propTypes.string, propTypes.object]),
      focus: propTypes.bool,
      theme: propTypes.string,
      name: propTypes.string,
      className: propTypes.string,
      height: propTypes.string,
      width: propTypes.string,
      fontSize: propTypes.oneOfType([propTypes.number, propTypes.string]),
      showGutter: propTypes.bool,
      onChange: propTypes.func,
      onCopy: propTypes.func,
      onPaste: propTypes.func,
      onFocus: propTypes.func,
      onInput: propTypes.func,
      onBlur: propTypes.func,
      onScroll: propTypes.func,
      value: propTypes.string,
      defaultValue: propTypes.string,
      onLoad: propTypes.func,
      onSelectionChange: propTypes.func,
      onCursorChange: propTypes.func,
      onBeforeLoad: propTypes.func,
      onValidate: propTypes.func,
      minLines: propTypes.number,
      maxLines: propTypes.number,
      readOnly: propTypes.bool,
      highlightActiveLine: propTypes.bool,
      tabSize: propTypes.number,
      showPrintMargin: propTypes.bool,
      cursorStart: propTypes.number,
      debounceChangePeriod: propTypes.number,
      editorProps: propTypes.object,
      setOptions: propTypes.object,
      style: propTypes.object,
      scrollMargin: propTypes.array,
      annotations: propTypes.array,
      markers: propTypes.array,
      keyboardHandler: propTypes.string,
      wrapEnabled: propTypes.bool,
      enableSnippets: propTypes.bool,
      enableBasicAutocompletion: propTypes.oneOfType([
        propTypes.bool,
        propTypes.array
      ]),
      enableLiveAutocompletion: propTypes.oneOfType([
        propTypes.bool,
        propTypes.array
      ]),
      navigateToFileEnd: propTypes.bool,
      commands: propTypes.array,
      placeholder: propTypes.string
    };
    ReactAce2.defaultProps = {
      name: "ace-editor",
      focus: false,
      mode: "",
      theme: "",
      height: "500px",
      width: "500px",
      fontSize: 12,
      enableSnippets: false,
      showGutter: true,
      onChange: null,
      onPaste: null,
      onLoad: null,
      onScroll: null,
      minLines: null,
      maxLines: null,
      readOnly: false,
      highlightActiveLine: true,
      showPrintMargin: true,
      tabSize: 4,
      cursorStart: 1,
      editorProps: {},
      style: {},
      scrollMargin: [0, 0, 0, 0],
      setOptions: {},
      wrapEnabled: false,
      enableBasicAutocompletion: false,
      enableLiveAutocompletion: false,
      placeholder: null,
      navigateToFileEnd: true
    };
    return ReactAce2;
  }(react.Component);
  exports.default = ReactAce;
});
var extSplit = createCommonjsModule(function(module, exports) {
  ace.define("ace/split", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/editor", "ace/virtual_renderer", "ace/edit_session"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var lang = require2("./lib/lang");
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var Editor = require2("./editor").Editor;
    var Renderer = require2("./virtual_renderer").VirtualRenderer;
    var EditSession = require2("./edit_session").EditSession;
    var Split = function(container, theme, splits) {
      this.BELOW = 1;
      this.BESIDE = 0;
      this.$container = container;
      this.$theme = theme;
      this.$splits = 0;
      this.$editorCSS = "";
      this.$editors = [];
      this.$orientation = this.BESIDE;
      this.setSplits(splits || 1);
      this.$cEditor = this.$editors[0];
      this.on("focus", function(editor) {
        this.$cEditor = editor;
      }.bind(this));
    };
    (function() {
      oop.implement(this, EventEmitter);
      this.$createEditor = function() {
        var el = document.createElement("div");
        el.className = this.$editorCSS;
        el.style.cssText = "position: absolute; top:0px; bottom:0px";
        this.$container.appendChild(el);
        var editor = new Editor(new Renderer(el, this.$theme));
        editor.on("focus", function() {
          this._emit("focus", editor);
        }.bind(this));
        this.$editors.push(editor);
        editor.setFontSize(this.$fontSize);
        return editor;
      };
      this.setSplits = function(splits) {
        var editor;
        if (splits < 1) {
          throw "The number of splits have to be > 0!";
        }
        if (splits == this.$splits) {
          return;
        } else if (splits > this.$splits) {
          while (this.$splits < this.$editors.length && this.$splits < splits) {
            editor = this.$editors[this.$splits];
            this.$container.appendChild(editor.container);
            editor.setFontSize(this.$fontSize);
            this.$splits++;
          }
          while (this.$splits < splits) {
            this.$createEditor();
            this.$splits++;
          }
        } else {
          while (this.$splits > splits) {
            editor = this.$editors[this.$splits - 1];
            this.$container.removeChild(editor.container);
            this.$splits--;
          }
        }
        this.resize();
      };
      this.getSplits = function() {
        return this.$splits;
      };
      this.getEditor = function(idx) {
        return this.$editors[idx];
      };
      this.getCurrentEditor = function() {
        return this.$cEditor;
      };
      this.focus = function() {
        this.$cEditor.focus();
      };
      this.blur = function() {
        this.$cEditor.blur();
      };
      this.setTheme = function(theme) {
        this.$editors.forEach(function(editor) {
          editor.setTheme(theme);
        });
      };
      this.setKeyboardHandler = function(keybinding) {
        this.$editors.forEach(function(editor) {
          editor.setKeyboardHandler(keybinding);
        });
      };
      this.forEach = function(callback, scope) {
        this.$editors.forEach(callback, scope);
      };
      this.$fontSize = "";
      this.setFontSize = function(size) {
        this.$fontSize = size;
        this.forEach(function(editor) {
          editor.setFontSize(size);
        });
      };
      this.$cloneSession = function(session) {
        var s = new EditSession(session.getDocument(), session.getMode());
        var undoManager = session.getUndoManager();
        s.setUndoManager(undoManager);
        s.setTabSize(session.getTabSize());
        s.setUseSoftTabs(session.getUseSoftTabs());
        s.setOverwrite(session.getOverwrite());
        s.setBreakpoints(session.getBreakpoints());
        s.setUseWrapMode(session.getUseWrapMode());
        s.setUseWorker(session.getUseWorker());
        s.setWrapLimitRange(session.$wrapLimitRange.min, session.$wrapLimitRange.max);
        s.$foldData = session.$cloneFoldData();
        return s;
      };
      this.setSession = function(session, idx) {
        var editor;
        if (idx == null) {
          editor = this.$cEditor;
        } else {
          editor = this.$editors[idx];
        }
        var isUsed = this.$editors.some(function(editor2) {
          return editor2.session === session;
        });
        if (isUsed) {
          session = this.$cloneSession(session);
        }
        editor.setSession(session);
        return session;
      };
      this.getOrientation = function() {
        return this.$orientation;
      };
      this.setOrientation = function(orientation) {
        if (this.$orientation == orientation) {
          return;
        }
        this.$orientation = orientation;
        this.resize();
      };
      this.resize = function() {
        var width = this.$container.clientWidth;
        var height = this.$container.clientHeight;
        var editor;
        if (this.$orientation == this.BESIDE) {
          var editorWidth = width / this.$splits;
          for (var i = 0; i < this.$splits; i++) {
            editor = this.$editors[i];
            editor.container.style.width = editorWidth + "px";
            editor.container.style.top = "0px";
            editor.container.style.left = i * editorWidth + "px";
            editor.container.style.height = height + "px";
            editor.resize();
          }
        } else {
          var editorHeight = height / this.$splits;
          for (var i = 0; i < this.$splits; i++) {
            editor = this.$editors[i];
            editor.container.style.width = width + "px";
            editor.container.style.top = i * editorHeight + "px";
            editor.container.style.left = "0px";
            editor.container.style.height = editorHeight + "px";
            editor.resize();
          }
        }
      };
    }).call(Split.prototype);
    exports2.Split = Split;
  });
  ace.define("ace/ext/split", ["require", "exports", "module", "ace/split"], function(require2, exports2, module2) {
    module2.exports = require2("../split");
  });
  (function() {
    ace.require(["ace/ext/split"], function(m2) {
      if (module) {
        module.exports = m2;
      }
    });
  })();
});
var FUNC_ERROR_TEXT = "Expected a function";
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var INFINITY = 1 / 0;
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var symbolTag = "[object Symbol]";
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
var reLeadingDot = /^\./;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reEscapeChar = /\\(\\)?/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function isHostObject(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e2) {
    }
  }
  return result;
}
var arrayProto = Array.prototype;
var funcProto = Function.prototype;
var objectProto = Object.prototype;
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
var funcToString = funcProto.toString;
var hasOwnProperty2 = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
var Symbol2 = root.Symbol;
var splice = arrayProto.splice;
var Map2 = getNative(root, "Map");
var nativeCreate = getNative(Object, "create");
var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function Hash(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty2.call(data, key) ? data[key] : void 0;
}
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
}
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear() {
  this.__data__ = [];
}
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear() {
  this.__data__ = {
    hash: new Hash(),
    map: new (Map2 || ListCache)(),
    string: new Hash()
  };
}
function mapCacheDelete(key) {
  return getMapData(this, key)["delete"](key);
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[toKey(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
function baseIsNative(value) {
  if (!isObject2(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
function isKeyable(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var stringToPath = memoize(function(string) {
  string = toString2(string);
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, string2) {
    result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
function memoize(func, resolver) {
  if (typeof func != "function" || resolver && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var isArray = Array.isArray;
function isFunction(value) {
  var tag = isObject2(value) ? objectToString.call(value) : "";
  return tag == funcTag || tag == genTag;
}
function isObject2(value) {
  var type2 = typeof value;
  return !!value && (type2 == "object" || type2 == "function");
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toString2(value) {
  return value == null ? "" : baseToString(value);
}
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
var lodash_get = get;
var split = createCommonjsModule(function(module, exports) {
  var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p2))
            d3[p2] = b3[p2];
      };
      return extendStatics(d2, b2);
    };
    return function(d2, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
  }();
  var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
        s = arguments[i];
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2))
            t2[p2] = s[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  var ace2 = editorOptions_1.getAceInstance();
  var SplitComponent = function(_super) {
    __extends(SplitComponent2, _super);
    function SplitComponent2(props) {
      var _this = _super.call(this, props) || this;
      editorOptions_1.editorEvents.forEach(function(method) {
        _this[method] = _this[method].bind(_this);
      });
      _this.debounce = editorOptions_1.debounce;
      return _this;
    }
    SplitComponent2.prototype.isInShadow = function(node) {
      var parent = node && node.parentNode;
      while (parent) {
        if (parent.toString() === "[object ShadowRoot]") {
          return true;
        }
        parent = parent.parentNode;
      }
      return false;
    };
    SplitComponent2.prototype.componentDidMount = function() {
      var _this = this;
      var _a = this.props, className = _a.className, onBeforeLoad = _a.onBeforeLoad, mode = _a.mode, focus = _a.focus, theme = _a.theme, fontSize = _a.fontSize, value = _a.value, defaultValue = _a.defaultValue, cursorStart = _a.cursorStart, showGutter = _a.showGutter, wrapEnabled = _a.wrapEnabled, showPrintMargin = _a.showPrintMargin, _b = _a.scrollMargin, scrollMargin = _b === void 0 ? [0, 0, 0, 0] : _b, keyboardHandler = _a.keyboardHandler, onLoad = _a.onLoad, commands = _a.commands, annotations = _a.annotations, markers = _a.markers, splits = _a.splits;
      this.editor = ace2.edit(this.refEditor);
      if (this.isInShadow(this.refEditor)) {
        this.editor.renderer.attachToShadowRoot();
      }
      this.editor.setTheme("ace/theme/" + theme);
      if (onBeforeLoad) {
        onBeforeLoad(ace2);
      }
      var editorProps = Object.keys(this.props.editorProps);
      var split2 = new extSplit.Split(this.editor.container, "ace/theme/" + theme, splits);
      this.editor.env.split = split2;
      this.splitEditor = split2.getEditor(0);
      this.split = split2;
      this.editor.setShowPrintMargin(false);
      this.editor.renderer.setShowGutter(false);
      var availableOptions = this.splitEditor.$options;
      if (this.props.debounceChangePeriod) {
        this.onChange = this.debounce(this.onChange, this.props.debounceChangePeriod);
      }
      split2.forEach(function(editor, index2) {
        for (var i = 0; i < editorProps.length; i++) {
          editor[editorProps[i]] = _this.props.editorProps[editorProps[i]];
        }
        var defaultValueForEditor = lodash_get(defaultValue, index2);
        var valueForEditor = lodash_get(value, index2, "");
        editor.session.setUndoManager(new ace2.UndoManager());
        editor.setTheme("ace/theme/" + theme);
        editor.renderer.setScrollMargin(scrollMargin[0], scrollMargin[1], scrollMargin[2], scrollMargin[3]);
        editor.getSession().setMode("ace/mode/" + mode);
        editor.setFontSize(fontSize);
        editor.renderer.setShowGutter(showGutter);
        editor.getSession().setUseWrapMode(wrapEnabled);
        editor.setShowPrintMargin(showPrintMargin);
        editor.on("focus", _this.onFocus);
        editor.on("blur", _this.onBlur);
        editor.on("input", _this.onInput);
        editor.on("copy", _this.onCopy);
        editor.on("paste", _this.onPaste);
        editor.on("change", _this.onChange);
        editor.getSession().selection.on("changeSelection", _this.onSelectionChange);
        editor.getSession().selection.on("changeCursor", _this.onCursorChange);
        editor.session.on("changeScrollTop", _this.onScroll);
        editor.setValue(defaultValueForEditor === void 0 ? valueForEditor : defaultValueForEditor, cursorStart);
        var newAnnotations = lodash_get(annotations, index2, []);
        var newMarkers = lodash_get(markers, index2, []);
        editor.getSession().setAnnotations(newAnnotations);
        if (newMarkers && newMarkers.length > 0) {
          _this.handleMarkers(newMarkers, editor);
        }
        for (var i = 0; i < editorOptions_1.editorOptions.length; i++) {
          var option = editorOptions_1.editorOptions[i];
          if (availableOptions.hasOwnProperty(option)) {
            editor.setOption(option, _this.props[option]);
          } else if (_this.props[option]) {
            console.warn("ReaceAce: editor option " + option + " was activated but not found. Did you need to import a related tool or did you possibly mispell the option?");
          }
        }
        _this.handleOptions(_this.props, editor);
        if (Array.isArray(commands)) {
          commands.forEach(function(command) {
            if (typeof command.exec === "string") {
              editor.commands.bindKey(command.bindKey, command.exec);
            } else {
              editor.commands.addCommand(command);
            }
          });
        }
        if (keyboardHandler) {
          editor.setKeyboardHandler("ace/keyboard/" + keyboardHandler);
        }
      });
      if (className) {
        this.refEditor.className += " " + className;
      }
      if (focus) {
        this.splitEditor.focus();
      }
      var sp = this.editor.env.split;
      sp.setOrientation(this.props.orientation === "below" ? sp.BELOW : sp.BESIDE);
      sp.resize(true);
      if (onLoad) {
        onLoad(sp);
      }
    };
    SplitComponent2.prototype.componentDidUpdate = function(prevProps) {
      var _this = this;
      var oldProps = prevProps;
      var nextProps = this.props;
      var split2 = this.editor.env.split;
      if (nextProps.splits !== oldProps.splits) {
        split2.setSplits(nextProps.splits);
      }
      if (nextProps.orientation !== oldProps.orientation) {
        split2.setOrientation(nextProps.orientation === "below" ? split2.BELOW : split2.BESIDE);
      }
      split2.forEach(function(editor, index2) {
        if (nextProps.mode !== oldProps.mode) {
          editor.getSession().setMode("ace/mode/" + nextProps.mode);
        }
        if (nextProps.keyboardHandler !== oldProps.keyboardHandler) {
          if (nextProps.keyboardHandler) {
            editor.setKeyboardHandler("ace/keyboard/" + nextProps.keyboardHandler);
          } else {
            editor.setKeyboardHandler(null);
          }
        }
        if (nextProps.fontSize !== oldProps.fontSize) {
          editor.setFontSize(nextProps.fontSize);
        }
        if (nextProps.wrapEnabled !== oldProps.wrapEnabled) {
          editor.getSession().setUseWrapMode(nextProps.wrapEnabled);
        }
        if (nextProps.showPrintMargin !== oldProps.showPrintMargin) {
          editor.setShowPrintMargin(nextProps.showPrintMargin);
        }
        if (nextProps.showGutter !== oldProps.showGutter) {
          editor.renderer.setShowGutter(nextProps.showGutter);
        }
        for (var i = 0; i < editorOptions_1.editorOptions.length; i++) {
          var option = editorOptions_1.editorOptions[i];
          if (nextProps[option] !== oldProps[option]) {
            editor.setOption(option, nextProps[option]);
          }
        }
        if (!lodash_isequal(nextProps.setOptions, oldProps.setOptions)) {
          _this.handleOptions(nextProps, editor);
        }
        var nextValue = lodash_get(nextProps.value, index2, "");
        if (editor.getValue() !== nextValue) {
          _this.silent = true;
          var pos = editor.session.selection.toJSON();
          editor.setValue(nextValue, nextProps.cursorStart);
          editor.session.selection.fromJSON(pos);
          _this.silent = false;
        }
        var newAnnotations = lodash_get(nextProps.annotations, index2, []);
        var oldAnnotations = lodash_get(oldProps.annotations, index2, []);
        if (!lodash_isequal(newAnnotations, oldAnnotations)) {
          editor.getSession().setAnnotations(newAnnotations);
        }
        var newMarkers = lodash_get(nextProps.markers, index2, []);
        var oldMarkers = lodash_get(oldProps.markers, index2, []);
        if (!lodash_isequal(newMarkers, oldMarkers) && Array.isArray(newMarkers)) {
          _this.handleMarkers(newMarkers, editor);
        }
      });
      if (nextProps.className !== oldProps.className) {
        var appliedClasses = this.refEditor.className;
        var appliedClassesArray_1 = appliedClasses.trim().split(" ");
        var oldClassesArray = oldProps.className.trim().split(" ");
        oldClassesArray.forEach(function(oldClass) {
          var index2 = appliedClassesArray_1.indexOf(oldClass);
          appliedClassesArray_1.splice(index2, 1);
        });
        this.refEditor.className = " " + nextProps.className + " " + appliedClassesArray_1.join(" ");
      }
      if (nextProps.theme !== oldProps.theme) {
        split2.setTheme("ace/theme/" + nextProps.theme);
      }
      if (nextProps.focus && !oldProps.focus) {
        this.splitEditor.focus();
      }
      if (nextProps.height !== this.props.height || nextProps.width !== this.props.width) {
        this.editor.resize();
      }
    };
    SplitComponent2.prototype.componentWillUnmount = function() {
      this.editor.destroy();
      this.editor = null;
    };
    SplitComponent2.prototype.onChange = function(event) {
      if (this.props.onChange && !this.silent) {
        var value_1 = [];
        this.editor.env.split.forEach(function(editor) {
          value_1.push(editor.getValue());
        });
        this.props.onChange(value_1, event);
      }
    };
    SplitComponent2.prototype.onSelectionChange = function(event) {
      if (this.props.onSelectionChange) {
        var value_2 = [];
        this.editor.env.split.forEach(function(editor) {
          value_2.push(editor.getSelection());
        });
        this.props.onSelectionChange(value_2, event);
      }
    };
    SplitComponent2.prototype.onCursorChange = function(event) {
      if (this.props.onCursorChange) {
        var value_3 = [];
        this.editor.env.split.forEach(function(editor) {
          value_3.push(editor.getSelection());
        });
        this.props.onCursorChange(value_3, event);
      }
    };
    SplitComponent2.prototype.onFocus = function(event) {
      if (this.props.onFocus) {
        this.props.onFocus(event);
      }
    };
    SplitComponent2.prototype.onInput = function(event) {
      if (this.props.onInput) {
        this.props.onInput(event);
      }
    };
    SplitComponent2.prototype.onBlur = function(event) {
      if (this.props.onBlur) {
        this.props.onBlur(event);
      }
    };
    SplitComponent2.prototype.onCopy = function(text) {
      if (this.props.onCopy) {
        this.props.onCopy(text);
      }
    };
    SplitComponent2.prototype.onPaste = function(text) {
      if (this.props.onPaste) {
        this.props.onPaste(text);
      }
    };
    SplitComponent2.prototype.onScroll = function() {
      if (this.props.onScroll) {
        this.props.onScroll(this.editor);
      }
    };
    SplitComponent2.prototype.handleOptions = function(props, editor) {
      var setOptions = Object.keys(props.setOptions);
      for (var y3 = 0; y3 < setOptions.length; y3++) {
        editor.setOption(setOptions[y3], props.setOptions[setOptions[y3]]);
      }
    };
    SplitComponent2.prototype.handleMarkers = function(markers, editor) {
      var currentMarkers = editor.getSession().getMarkers(true);
      for (var i in currentMarkers) {
        if (currentMarkers.hasOwnProperty(i)) {
          editor.getSession().removeMarker(currentMarkers[i].id);
        }
      }
      currentMarkers = editor.getSession().getMarkers(false);
      for (var i in currentMarkers) {
        if (currentMarkers.hasOwnProperty(i)) {
          editor.getSession().removeMarker(currentMarkers[i].id);
        }
      }
      markers.forEach(function(_a) {
        var startRow = _a.startRow, startCol = _a.startCol, endRow = _a.endRow, endCol = _a.endCol, className = _a.className, type2 = _a.type, _b = _a.inFront, inFront = _b === void 0 ? false : _b;
        var range = new ace_1.Range(startRow, startCol, endRow, endCol);
        editor.getSession().addMarker(range, className, type2, inFront);
      });
    };
    SplitComponent2.prototype.updateRef = function(item) {
      this.refEditor = item;
    };
    SplitComponent2.prototype.render = function() {
      var _a = this.props, name = _a.name, width = _a.width, height = _a.height, style = _a.style;
      var divStyle = __assign({width, height}, style);
      return react.createElement("div", {ref: this.updateRef, id: name, style: divStyle});
    };
    SplitComponent2.propTypes = {
      className: propTypes.string,
      debounceChangePeriod: propTypes.number,
      defaultValue: propTypes.arrayOf(propTypes.string),
      focus: propTypes.bool,
      fontSize: propTypes.oneOfType([propTypes.number, propTypes.string]),
      height: propTypes.string,
      mode: propTypes.string,
      name: propTypes.string,
      onBlur: propTypes.func,
      onChange: propTypes.func,
      onCopy: propTypes.func,
      onFocus: propTypes.func,
      onInput: propTypes.func,
      onLoad: propTypes.func,
      onPaste: propTypes.func,
      onScroll: propTypes.func,
      orientation: propTypes.string,
      showGutter: propTypes.bool,
      splits: propTypes.number,
      theme: propTypes.string,
      value: propTypes.arrayOf(propTypes.string),
      width: propTypes.string,
      onSelectionChange: propTypes.func,
      onCursorChange: propTypes.func,
      onBeforeLoad: propTypes.func,
      minLines: propTypes.number,
      maxLines: propTypes.number,
      readOnly: propTypes.bool,
      highlightActiveLine: propTypes.bool,
      tabSize: propTypes.number,
      showPrintMargin: propTypes.bool,
      cursorStart: propTypes.number,
      editorProps: propTypes.object,
      setOptions: propTypes.object,
      style: propTypes.object,
      scrollMargin: propTypes.array,
      annotations: propTypes.array,
      markers: propTypes.array,
      keyboardHandler: propTypes.string,
      wrapEnabled: propTypes.bool,
      enableBasicAutocompletion: propTypes.oneOfType([
        propTypes.bool,
        propTypes.array
      ]),
      enableLiveAutocompletion: propTypes.oneOfType([
        propTypes.bool,
        propTypes.array
      ]),
      commands: propTypes.array
    };
    SplitComponent2.defaultProps = {
      name: "ace-editor",
      focus: false,
      orientation: "beside",
      splits: 2,
      mode: "",
      theme: "",
      height: "500px",
      width: "500px",
      value: [],
      fontSize: 12,
      showGutter: true,
      onChange: null,
      onPaste: null,
      onLoad: null,
      onScroll: null,
      minLines: null,
      maxLines: null,
      readOnly: false,
      highlightActiveLine: true,
      showPrintMargin: true,
      tabSize: 4,
      cursorStart: 1,
      editorProps: {},
      style: {},
      scrollMargin: [0, 0, 0, 0],
      setOptions: {},
      wrapEnabled: false,
      enableBasicAutocompletion: false,
      enableLiveAutocompletion: false
    };
    return SplitComponent2;
  }(react.Component);
  exports.default = SplitComponent;
});
var diffMatchPatch = createCommonjsModule(function(module) {
  var diff_match_patch = function() {
    this.Diff_Timeout = 1;
    this.Diff_EditCost = 4;
    this.Match_Threshold = 0.5;
    this.Match_Distance = 1e3;
    this.Patch_DeleteThreshold = 0.5;
    this.Patch_Margin = 4;
    this.Match_MaxBits = 32;
  };
  var DIFF_DELETE = -1;
  var DIFF_INSERT = 1;
  var DIFF_EQUAL = 0;
  diff_match_patch.Diff = function(op, text) {
    return [op, text];
  };
  diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines, opt_deadline) {
    if (typeof opt_deadline == "undefined") {
      if (this.Diff_Timeout <= 0) {
        opt_deadline = Number.MAX_VALUE;
      } else {
        opt_deadline = new Date().getTime() + this.Diff_Timeout * 1e3;
      }
    }
    var deadline = opt_deadline;
    if (text1 == null || text2 == null) {
      throw new Error("Null input. (diff_main)");
    }
    if (text1 == text2) {
      if (text1) {
        return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
      }
      return [];
    }
    if (typeof opt_checklines == "undefined") {
      opt_checklines = true;
    }
    var checklines = opt_checklines;
    var commonlength = this.diff_commonPrefix(text1, text2);
    var commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength);
    text2 = text2.substring(commonlength);
    commonlength = this.diff_commonSuffix(text1, text2);
    var commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength);
    text2 = text2.substring(0, text2.length - commonlength);
    var diffs = this.diff_compute_(text1, text2, checklines, deadline);
    if (commonprefix) {
      diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
    }
    if (commonsuffix) {
      diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
    }
    this.diff_cleanupMerge(diffs);
    return diffs;
  };
  diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines, deadline) {
    var diffs;
    if (!text1) {
      return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
    }
    if (!text2) {
      return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
    }
    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    var i = longtext.indexOf(shorttext);
    if (i != -1) {
      diffs = [
        new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),
        new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
        new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(i + shorttext.length))
      ];
      if (text1.length > text2.length) {
        diffs[0][0] = diffs[2][0] = DIFF_DELETE;
      }
      return diffs;
    }
    if (shorttext.length == 1) {
      return [
        new diff_match_patch.Diff(DIFF_DELETE, text1),
        new diff_match_patch.Diff(DIFF_INSERT, text2)
      ];
    }
    var hm = this.diff_halfMatch_(text1, text2);
    if (hm) {
      var text1_a = hm[0];
      var text1_b = hm[1];
      var text2_a = hm[2];
      var text2_b = hm[3];
      var mid_common = hm[4];
      var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
      var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
      return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)], diffs_b);
    }
    if (checklines && text1.length > 100 && text2.length > 100) {
      return this.diff_lineMode_(text1, text2, deadline);
    }
    return this.diff_bisect_(text1, text2, deadline);
  };
  diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
    var a = this.diff_linesToChars_(text1, text2);
    text1 = a.chars1;
    text2 = a.chars2;
    var linearray = a.lineArray;
    var diffs = this.diff_main(text1, text2, false, deadline);
    this.diff_charsToLines_(diffs, linearray);
    this.diff_cleanupSemantic(diffs);
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = "";
    var text_insert = "";
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          break;
        case DIFF_EQUAL:
          if (count_delete >= 1 && count_insert >= 1) {
            diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);
            pointer = pointer - count_delete - count_insert;
            var subDiff = this.diff_main(text_delete, text_insert, false, deadline);
            for (var j = subDiff.length - 1; j >= 0; j--) {
              diffs.splice(pointer, 0, subDiff[j]);
            }
            pointer = pointer + subDiff.length;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = "";
          text_insert = "";
          break;
      }
      pointer++;
    }
    diffs.pop();
    return diffs;
  };
  diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
    var text1_length = text1.length;
    var text2_length = text2.length;
    var max_d = Math.ceil((text1_length + text2_length) / 2);
    var v_offset = max_d;
    var v_length = 2 * max_d;
    var v1 = new Array(v_length);
    var v2 = new Array(v_length);
    for (var x2 = 0; x2 < v_length; x2++) {
      v1[x2] = -1;
      v2[x2] = -1;
    }
    v1[v_offset + 1] = 0;
    v2[v_offset + 1] = 0;
    var delta = text1_length - text2_length;
    var front = delta % 2 != 0;
    var k1start = 0;
    var k1end = 0;
    var k2start = 0;
    var k2end = 0;
    for (var d2 = 0; d2 < max_d; d2++) {
      if (new Date().getTime() > deadline) {
        break;
      }
      for (var k1 = -d2 + k1start; k1 <= d2 - k1end; k1 += 2) {
        var k1_offset = v_offset + k1;
        var x1;
        if (k1 == -d2 || k1 != d2 && v1[k1_offset - 1] < v1[k1_offset + 1]) {
          x1 = v1[k1_offset + 1];
        } else {
          x1 = v1[k1_offset - 1] + 1;
        }
        var y1 = x1 - k1;
        while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
          x1++;
          y1++;
        }
        v1[k1_offset] = x1;
        if (x1 > text1_length) {
          k1end += 2;
        } else if (y1 > text2_length) {
          k1start += 2;
        } else if (front) {
          var k2_offset = v_offset + delta - k1;
          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
            var x22 = text1_length - v2[k2_offset];
            if (x1 >= x22) {
              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
            }
          }
        }
      }
      for (var k2 = -d2 + k2start; k2 <= d2 - k2end; k2 += 2) {
        var k2_offset = v_offset + k2;
        var x22;
        if (k2 == -d2 || k2 != d2 && v2[k2_offset - 1] < v2[k2_offset + 1]) {
          x22 = v2[k2_offset + 1];
        } else {
          x22 = v2[k2_offset - 1] + 1;
        }
        var y22 = x22 - k2;
        while (x22 < text1_length && y22 < text2_length && text1.charAt(text1_length - x22 - 1) == text2.charAt(text2_length - y22 - 1)) {
          x22++;
          y22++;
        }
        v2[k2_offset] = x22;
        if (x22 > text1_length) {
          k2end += 2;
        } else if (y22 > text2_length) {
          k2start += 2;
        } else if (!front) {
          var k1_offset = v_offset + delta - k2;
          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
            var x1 = v1[k1_offset];
            var y1 = v_offset + x1 - k1_offset;
            x22 = text1_length - x22;
            if (x1 >= x22) {
              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
            }
          }
        }
      }
    }
    return [
      new diff_match_patch.Diff(DIFF_DELETE, text1),
      new diff_match_patch.Diff(DIFF_INSERT, text2)
    ];
  };
  diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x2, y3, deadline) {
    var text1a = text1.substring(0, x2);
    var text2a = text2.substring(0, y3);
    var text1b = text1.substring(x2);
    var text2b = text2.substring(y3);
    var diffs = this.diff_main(text1a, text2a, false, deadline);
    var diffsb = this.diff_main(text1b, text2b, false, deadline);
    return diffs.concat(diffsb);
  };
  diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
    var lineArray = [];
    var lineHash = {};
    lineArray[0] = "";
    function diff_linesToCharsMunge_(text) {
      var chars = "";
      var lineStart = 0;
      var lineEnd = -1;
      var lineArrayLength = lineArray.length;
      while (lineEnd < text.length - 1) {
        lineEnd = text.indexOf("\n", lineStart);
        if (lineEnd == -1) {
          lineEnd = text.length - 1;
        }
        var line = text.substring(lineStart, lineEnd + 1);
        if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
          chars += String.fromCharCode(lineHash[line]);
        } else {
          if (lineArrayLength == maxLines) {
            line = text.substring(lineStart);
            lineEnd = text.length;
          }
          chars += String.fromCharCode(lineArrayLength);
          lineHash[line] = lineArrayLength;
          lineArray[lineArrayLength++] = line;
        }
        lineStart = lineEnd + 1;
      }
      return chars;
    }
    var maxLines = 4e4;
    var chars1 = diff_linesToCharsMunge_(text1);
    maxLines = 65535;
    var chars2 = diff_linesToCharsMunge_(text2);
    return {chars1, chars2, lineArray};
  };
  diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
    for (var i = 0; i < diffs.length; i++) {
      var chars = diffs[i][1];
      var text = [];
      for (var j = 0; j < chars.length; j++) {
        text[j] = lineArray[chars.charCodeAt(j)];
      }
      diffs[i][1] = text.join("");
    }
  };
  diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
      return 0;
    }
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerstart = 0;
    while (pointermin < pointermid) {
      if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
        pointermin = pointermid;
        pointerstart = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
  };
  diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
    if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
      return 0;
    }
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerend = 0;
    while (pointermin < pointermid) {
      if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
        pointermin = pointermid;
        pointerend = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
  };
  diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
    var text1_length = text1.length;
    var text2_length = text2.length;
    if (text1_length == 0 || text2_length == 0) {
      return 0;
    }
    if (text1_length > text2_length) {
      text1 = text1.substring(text1_length - text2_length);
    } else if (text1_length < text2_length) {
      text2 = text2.substring(0, text1_length);
    }
    var text_length = Math.min(text1_length, text2_length);
    if (text1 == text2) {
      return text_length;
    }
    var best = 0;
    var length = 1;
    while (true) {
      var pattern = text1.substring(text_length - length);
      var found = text2.indexOf(pattern);
      if (found == -1) {
        return best;
      }
      length += found;
      if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
        best = length;
        length++;
      }
    }
  };
  diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
    if (this.Diff_Timeout <= 0) {
      return null;
    }
    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
      return null;
    }
    var dmp = this;
    function diff_halfMatchI_(longtext2, shorttext2, i) {
      var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
      var j = -1;
      var best_common = "";
      var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
      while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
        var prefixLength = dmp.diff_commonPrefix(longtext2.substring(i), shorttext2.substring(j));
        var suffixLength = dmp.diff_commonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));
        if (best_common.length < suffixLength + prefixLength) {
          best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
          best_longtext_a = longtext2.substring(0, i - suffixLength);
          best_longtext_b = longtext2.substring(i + prefixLength);
          best_shorttext_a = shorttext2.substring(0, j - suffixLength);
          best_shorttext_b = shorttext2.substring(j + prefixLength);
        }
      }
      if (best_common.length * 2 >= longtext2.length) {
        return [
          best_longtext_a,
          best_longtext_b,
          best_shorttext_a,
          best_shorttext_b,
          best_common
        ];
      } else {
        return null;
      }
    }
    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
    var hm;
    if (!hm1 && !hm2) {
      return null;
    } else if (!hm2) {
      hm = hm1;
    } else if (!hm1) {
      hm = hm2;
    } else {
      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
    }
    var text1_a, text1_b, text2_a, text2_b;
    if (text1.length > text2.length) {
      text1_a = hm[0];
      text1_b = hm[1];
      text2_a = hm[2];
      text2_b = hm[3];
    } else {
      text2_a = hm[0];
      text2_b = hm[1];
      text1_a = hm[2];
      text1_b = hm[3];
    }
    var mid_common = hm[4];
    return [text1_a, text1_b, text2_a, text2_b, mid_common];
  };
  diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
    var changes = false;
    var equalities = [];
    var equalitiesLength = 0;
    var lastEquality = null;
    var pointer = 0;
    var length_insertions1 = 0;
    var length_deletions1 = 0;
    var length_insertions2 = 0;
    var length_deletions2 = 0;
    while (pointer < diffs.length) {
      if (diffs[pointer][0] == DIFF_EQUAL) {
        equalities[equalitiesLength++] = pointer;
        length_insertions1 = length_insertions2;
        length_deletions1 = length_deletions2;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = diffs[pointer][1];
      } else {
        if (diffs[pointer][0] == DIFF_INSERT) {
          length_insertions2 += diffs[pointer][1].length;
        } else {
          length_deletions2 += diffs[pointer][1].length;
        }
        if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
          diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
          equalitiesLength--;
          equalitiesLength--;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          length_insertions1 = 0;
          length_deletions1 = 0;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastEquality = null;
          changes = true;
        }
      }
      pointer++;
    }
    if (changes) {
      this.diff_cleanupMerge(diffs);
    }
    this.diff_cleanupSemanticLossless(diffs);
    pointer = 1;
    while (pointer < diffs.length) {
      if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
        var deletion = diffs[pointer - 1][1];
        var insertion = diffs[pointer][1];
        var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
        var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
        if (overlap_length1 >= overlap_length2) {
          if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
            diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
            diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
            diffs[pointer + 1][1] = insertion.substring(overlap_length1);
            pointer++;
          }
        } else {
          if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
            diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
            diffs[pointer - 1][0] = DIFF_INSERT;
            diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
            diffs[pointer + 1][0] = DIFF_DELETE;
            diffs[pointer + 1][1] = deletion.substring(overlap_length2);
            pointer++;
          }
        }
        pointer++;
      }
      pointer++;
    }
  };
  diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
    function diff_cleanupSemanticScore_(one, two) {
      if (!one || !two) {
        return 6;
      }
      var char1 = one.charAt(one.length - 1);
      var char2 = two.charAt(0);
      var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
      var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
      var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch.whitespaceRegex_);
      var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch.whitespaceRegex_);
      var lineBreak1 = whitespace1 && char1.match(diff_match_patch.linebreakRegex_);
      var lineBreak2 = whitespace2 && char2.match(diff_match_patch.linebreakRegex_);
      var blankLine1 = lineBreak1 && one.match(diff_match_patch.blanklineEndRegex_);
      var blankLine2 = lineBreak2 && two.match(diff_match_patch.blanklineStartRegex_);
      if (blankLine1 || blankLine2) {
        return 5;
      } else if (lineBreak1 || lineBreak2) {
        return 4;
      } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
        return 3;
      } else if (whitespace1 || whitespace2) {
        return 2;
      } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
        return 1;
      }
      return 0;
    }
    var pointer = 1;
    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
        var equality1 = diffs[pointer - 1][1];
        var edit = diffs[pointer][1];
        var equality2 = diffs[pointer + 1][1];
        var commonOffset = this.diff_commonSuffix(equality1, edit);
        if (commonOffset) {
          var commonString = edit.substring(edit.length - commonOffset);
          equality1 = equality1.substring(0, equality1.length - commonOffset);
          edit = commonString + edit.substring(0, edit.length - commonOffset);
          equality2 = commonString + equality2;
        }
        var bestEquality1 = equality1;
        var bestEdit = edit;
        var bestEquality2 = equality2;
        var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        while (edit.charAt(0) === equality2.charAt(0)) {
          equality1 += edit.charAt(0);
          edit = edit.substring(1) + equality2.charAt(0);
          equality2 = equality2.substring(1);
          var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          if (score >= bestScore) {
            bestScore = score;
            bestEquality1 = equality1;
            bestEdit = edit;
            bestEquality2 = equality2;
          }
        }
        if (diffs[pointer - 1][1] != bestEquality1) {
          if (bestEquality1) {
            diffs[pointer - 1][1] = bestEquality1;
          } else {
            diffs.splice(pointer - 1, 1);
            pointer--;
          }
          diffs[pointer][1] = bestEdit;
          if (bestEquality2) {
            diffs[pointer + 1][1] = bestEquality2;
          } else {
            diffs.splice(pointer + 1, 1);
            pointer--;
          }
        }
      }
      pointer++;
    }
  };
  diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
  diff_match_patch.whitespaceRegex_ = /\s/;
  diff_match_patch.linebreakRegex_ = /[\r\n]/;
  diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
  diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;
  diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
    var changes = false;
    var equalities = [];
    var equalitiesLength = 0;
    var lastEquality = null;
    var pointer = 0;
    var pre_ins = false;
    var pre_del = false;
    var post_ins = false;
    var post_del = false;
    while (pointer < diffs.length) {
      if (diffs[pointer][0] == DIFF_EQUAL) {
        if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
          equalities[equalitiesLength++] = pointer;
          pre_ins = post_ins;
          pre_del = post_del;
          lastEquality = diffs[pointer][1];
        } else {
          equalitiesLength = 0;
          lastEquality = null;
        }
        post_ins = post_del = false;
      } else {
        if (diffs[pointer][0] == DIFF_DELETE) {
          post_del = true;
        } else {
          post_ins = true;
        }
        if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
          diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
          equalitiesLength--;
          lastEquality = null;
          if (pre_ins && pre_del) {
            post_ins = post_del = true;
            equalitiesLength = 0;
          } else {
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            post_ins = post_del = false;
          }
          changes = true;
        }
      }
      pointer++;
    }
    if (changes) {
      this.diff_cleanupMerge(diffs);
    }
  };
  diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = "";
    var text_insert = "";
    var commonlength;
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          pointer++;
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          pointer++;
          break;
        case DIFF_EQUAL:
          if (count_delete + count_insert > 1) {
            if (count_delete !== 0 && count_insert !== 0) {
              commonlength = this.diff_commonPrefix(text_insert, text_delete);
              if (commonlength !== 0) {
                if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                  diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                } else {
                  diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                  pointer++;
                }
                text_insert = text_insert.substring(commonlength);
                text_delete = text_delete.substring(commonlength);
              }
              commonlength = this.diff_commonSuffix(text_insert, text_delete);
              if (commonlength !== 0) {
                diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                text_insert = text_insert.substring(0, text_insert.length - commonlength);
                text_delete = text_delete.substring(0, text_delete.length - commonlength);
              }
            }
            pointer -= count_delete + count_insert;
            diffs.splice(pointer, count_delete + count_insert);
            if (text_delete.length) {
              diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_DELETE, text_delete));
              pointer++;
            }
            if (text_insert.length) {
              diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_INSERT, text_insert));
              pointer++;
            }
            pointer++;
          } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
            diffs[pointer - 1][1] += diffs[pointer][1];
            diffs.splice(pointer, 1);
          } else {
            pointer++;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = "";
          text_insert = "";
          break;
      }
    }
    if (diffs[diffs.length - 1][1] === "") {
      diffs.pop();
    }
    var changes = false;
    pointer = 1;
    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
        if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
          diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
          diffs.splice(pointer - 1, 1);
          changes = true;
        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
          diffs[pointer - 1][1] += diffs[pointer + 1][1];
          diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
          diffs.splice(pointer + 1, 1);
          changes = true;
        }
      }
      pointer++;
    }
    if (changes) {
      this.diff_cleanupMerge(diffs);
    }
  };
  diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
    var chars1 = 0;
    var chars2 = 0;
    var last_chars1 = 0;
    var last_chars2 = 0;
    var x2;
    for (x2 = 0; x2 < diffs.length; x2++) {
      if (diffs[x2][0] !== DIFF_INSERT) {
        chars1 += diffs[x2][1].length;
      }
      if (diffs[x2][0] !== DIFF_DELETE) {
        chars2 += diffs[x2][1].length;
      }
      if (chars1 > loc) {
        break;
      }
      last_chars1 = chars1;
      last_chars2 = chars2;
    }
    if (diffs.length != x2 && diffs[x2][0] === DIFF_DELETE) {
      return last_chars2;
    }
    return last_chars2 + (loc - last_chars1);
  };
  diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
    var html = [];
    var pattern_amp = /&/g;
    var pattern_lt = /</g;
    var pattern_gt = />/g;
    var pattern_para = /\n/g;
    for (var x2 = 0; x2 < diffs.length; x2++) {
      var op = diffs[x2][0];
      var data = diffs[x2][1];
      var text = data.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
      switch (op) {
        case DIFF_INSERT:
          html[x2] = '<ins style="background:#e6ffe6;">' + text + "</ins>";
          break;
        case DIFF_DELETE:
          html[x2] = '<del style="background:#ffe6e6;">' + text + "</del>";
          break;
        case DIFF_EQUAL:
          html[x2] = "<span>" + text + "</span>";
          break;
      }
    }
    return html.join("");
  };
  diff_match_patch.prototype.diff_text1 = function(diffs) {
    var text = [];
    for (var x2 = 0; x2 < diffs.length; x2++) {
      if (diffs[x2][0] !== DIFF_INSERT) {
        text[x2] = diffs[x2][1];
      }
    }
    return text.join("");
  };
  diff_match_patch.prototype.diff_text2 = function(diffs) {
    var text = [];
    for (var x2 = 0; x2 < diffs.length; x2++) {
      if (diffs[x2][0] !== DIFF_DELETE) {
        text[x2] = diffs[x2][1];
      }
    }
    return text.join("");
  };
  diff_match_patch.prototype.diff_levenshtein = function(diffs) {
    var levenshtein = 0;
    var insertions = 0;
    var deletions = 0;
    for (var x2 = 0; x2 < diffs.length; x2++) {
      var op = diffs[x2][0];
      var data = diffs[x2][1];
      switch (op) {
        case DIFF_INSERT:
          insertions += data.length;
          break;
        case DIFF_DELETE:
          deletions += data.length;
          break;
        case DIFF_EQUAL:
          levenshtein += Math.max(insertions, deletions);
          insertions = 0;
          deletions = 0;
          break;
      }
    }
    levenshtein += Math.max(insertions, deletions);
    return levenshtein;
  };
  diff_match_patch.prototype.diff_toDelta = function(diffs) {
    var text = [];
    for (var x2 = 0; x2 < diffs.length; x2++) {
      switch (diffs[x2][0]) {
        case DIFF_INSERT:
          text[x2] = "+" + encodeURI(diffs[x2][1]);
          break;
        case DIFF_DELETE:
          text[x2] = "-" + diffs[x2][1].length;
          break;
        case DIFF_EQUAL:
          text[x2] = "=" + diffs[x2][1].length;
          break;
      }
    }
    return text.join("	").replace(/%20/g, " ");
  };
  diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
    var diffs = [];
    var diffsLength = 0;
    var pointer = 0;
    var tokens = delta.split(/\t/g);
    for (var x2 = 0; x2 < tokens.length; x2++) {
      var param = tokens[x2].substring(1);
      switch (tokens[x2].charAt(0)) {
        case "+":
          try {
            diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));
          } catch (ex) {
            throw new Error("Illegal escape in diff_fromDelta: " + param);
          }
          break;
        case "-":
        case "=":
          var n2 = parseInt(param, 10);
          if (isNaN(n2) || n2 < 0) {
            throw new Error("Invalid number in diff_fromDelta: " + param);
          }
          var text = text1.substring(pointer, pointer += n2);
          if (tokens[x2].charAt(0) == "=") {
            diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);
          } else {
            diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);
          }
          break;
        default:
          if (tokens[x2]) {
            throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x2]);
          }
      }
    }
    if (pointer != text1.length) {
      throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").");
    }
    return diffs;
  };
  diff_match_patch.prototype.match_main = function(text, pattern, loc) {
    if (text == null || pattern == null || loc == null) {
      throw new Error("Null input. (match_main)");
    }
    loc = Math.max(0, Math.min(loc, text.length));
    if (text == pattern) {
      return 0;
    } else if (!text.length) {
      return -1;
    } else if (text.substring(loc, loc + pattern.length) == pattern) {
      return loc;
    } else {
      return this.match_bitap_(text, pattern, loc);
    }
  };
  diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
    if (pattern.length > this.Match_MaxBits) {
      throw new Error("Pattern too long for this browser.");
    }
    var s = this.match_alphabet_(pattern);
    var dmp = this;
    function match_bitapScore_(e2, x2) {
      var accuracy = e2 / pattern.length;
      var proximity = Math.abs(loc - x2);
      if (!dmp.Match_Distance) {
        return proximity ? 1 : accuracy;
      }
      return accuracy + proximity / dmp.Match_Distance;
    }
    var score_threshold = this.Match_Threshold;
    var best_loc = text.indexOf(pattern, loc);
    if (best_loc != -1) {
      score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
      best_loc = text.lastIndexOf(pattern, loc + pattern.length);
      if (best_loc != -1) {
        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
      }
    }
    var matchmask = 1 << pattern.length - 1;
    best_loc = -1;
    var bin_min, bin_mid;
    var bin_max = pattern.length + text.length;
    var last_rd;
    for (var d2 = 0; d2 < pattern.length; d2++) {
      bin_min = 0;
      bin_mid = bin_max;
      while (bin_min < bin_mid) {
        if (match_bitapScore_(d2, loc + bin_mid) <= score_threshold) {
          bin_min = bin_mid;
        } else {
          bin_max = bin_mid;
        }
        bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
      }
      bin_max = bin_mid;
      var start = Math.max(1, loc - bin_mid + 1);
      var finish = Math.min(loc + bin_mid, text.length) + pattern.length;
      var rd2 = Array(finish + 2);
      rd2[finish + 1] = (1 << d2) - 1;
      for (var j = finish; j >= start; j--) {
        var charMatch = s[text.charAt(j - 1)];
        if (d2 === 0) {
          rd2[j] = (rd2[j + 1] << 1 | 1) & charMatch;
        } else {
          rd2[j] = (rd2[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];
        }
        if (rd2[j] & matchmask) {
          var score = match_bitapScore_(d2, j - 1);
          if (score <= score_threshold) {
            score_threshold = score;
            best_loc = j - 1;
            if (best_loc > loc) {
              start = Math.max(1, 2 * loc - best_loc);
            } else {
              break;
            }
          }
        }
      }
      if (match_bitapScore_(d2 + 1, loc) > score_threshold) {
        break;
      }
      last_rd = rd2;
    }
    return best_loc;
  };
  diff_match_patch.prototype.match_alphabet_ = function(pattern) {
    var s = {};
    for (var i = 0; i < pattern.length; i++) {
      s[pattern.charAt(i)] = 0;
    }
    for (var i = 0; i < pattern.length; i++) {
      s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
    }
    return s;
  };
  diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
    if (text.length == 0) {
      return;
    }
    if (patch.start2 === null) {
      throw Error("patch not initialized");
    }
    var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
    var padding = 0;
    while (text.indexOf(pattern) != text.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
      padding += this.Patch_Margin;
      pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);
    }
    padding += this.Patch_Margin;
    var prefix2 = text.substring(patch.start2 - padding, patch.start2);
    if (prefix2) {
      patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix2));
    }
    var suffix = text.substring(patch.start2 + patch.length1, patch.start2 + patch.length1 + padding);
    if (suffix) {
      patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
    }
    patch.start1 -= prefix2.length;
    patch.start2 -= prefix2.length;
    patch.length1 += prefix2.length + suffix.length;
    patch.length2 += prefix2.length + suffix.length;
  };
  diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
    var text1, diffs;
    if (typeof a == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
      text1 = a;
      diffs = this.diff_main(text1, opt_b, true);
      if (diffs.length > 2) {
        this.diff_cleanupSemantic(diffs);
        this.diff_cleanupEfficiency(diffs);
      }
    } else if (a && typeof a == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
      diffs = a;
      text1 = this.diff_text1(diffs);
    } else if (typeof a == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
      text1 = a;
      diffs = opt_b;
    } else if (typeof a == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
      text1 = a;
      diffs = opt_c;
    } else {
      throw new Error("Unknown call format to patch_make.");
    }
    if (diffs.length === 0) {
      return [];
    }
    var patches = [];
    var patch = new diff_match_patch.patch_obj();
    var patchDiffLength = 0;
    var char_count1 = 0;
    var char_count2 = 0;
    var prepatch_text = text1;
    var postpatch_text = text1;
    for (var x2 = 0; x2 < diffs.length; x2++) {
      var diff_type = diffs[x2][0];
      var diff_text = diffs[x2][1];
      if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
        patch.start1 = char_count1;
        patch.start2 = char_count2;
      }
      switch (diff_type) {
        case DIFF_INSERT:
          patch.diffs[patchDiffLength++] = diffs[x2];
          patch.length2 += diff_text.length;
          postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
          break;
        case DIFF_DELETE:
          patch.length1 += diff_text.length;
          patch.diffs[patchDiffLength++] = diffs[x2];
          postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
          break;
        case DIFF_EQUAL:
          if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x2 + 1) {
            patch.diffs[patchDiffLength++] = diffs[x2];
            patch.length1 += diff_text.length;
            patch.length2 += diff_text.length;
          } else if (diff_text.length >= 2 * this.Patch_Margin) {
            if (patchDiffLength) {
              this.patch_addContext_(patch, prepatch_text);
              patches.push(patch);
              patch = new diff_match_patch.patch_obj();
              patchDiffLength = 0;
              prepatch_text = postpatch_text;
              char_count1 = char_count2;
            }
          }
          break;
      }
      if (diff_type !== DIFF_INSERT) {
        char_count1 += diff_text.length;
      }
      if (diff_type !== DIFF_DELETE) {
        char_count2 += diff_text.length;
      }
    }
    if (patchDiffLength) {
      this.patch_addContext_(patch, prepatch_text);
      patches.push(patch);
    }
    return patches;
  };
  diff_match_patch.prototype.patch_deepCopy = function(patches) {
    var patchesCopy = [];
    for (var x2 = 0; x2 < patches.length; x2++) {
      var patch = patches[x2];
      var patchCopy = new diff_match_patch.patch_obj();
      patchCopy.diffs = [];
      for (var y3 = 0; y3 < patch.diffs.length; y3++) {
        patchCopy.diffs[y3] = new diff_match_patch.Diff(patch.diffs[y3][0], patch.diffs[y3][1]);
      }
      patchCopy.start1 = patch.start1;
      patchCopy.start2 = patch.start2;
      patchCopy.length1 = patch.length1;
      patchCopy.length2 = patch.length2;
      patchesCopy[x2] = patchCopy;
    }
    return patchesCopy;
  };
  diff_match_patch.prototype.patch_apply = function(patches, text) {
    if (patches.length == 0) {
      return [text, []];
    }
    patches = this.patch_deepCopy(patches);
    var nullPadding = this.patch_addPadding(patches);
    text = nullPadding + text + nullPadding;
    this.patch_splitMax(patches);
    var delta = 0;
    var results = [];
    for (var x2 = 0; x2 < patches.length; x2++) {
      var expected_loc = patches[x2].start2 + delta;
      var text1 = this.diff_text1(patches[x2].diffs);
      var start_loc;
      var end_loc = -1;
      if (text1.length > this.Match_MaxBits) {
        start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits), expected_loc);
        if (start_loc != -1) {
          end_loc = this.match_main(text, text1.substring(text1.length - this.Match_MaxBits), expected_loc + text1.length - this.Match_MaxBits);
          if (end_loc == -1 || start_loc >= end_loc) {
            start_loc = -1;
          }
        }
      } else {
        start_loc = this.match_main(text, text1, expected_loc);
      }
      if (start_loc == -1) {
        results[x2] = false;
        delta -= patches[x2].length2 - patches[x2].length1;
      } else {
        results[x2] = true;
        delta = start_loc - expected_loc;
        var text2;
        if (end_loc == -1) {
          text2 = text.substring(start_loc, start_loc + text1.length);
        } else {
          text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
        }
        if (text1 == text2) {
          text = text.substring(0, start_loc) + this.diff_text2(patches[x2].diffs) + text.substring(start_loc + text1.length);
        } else {
          var diffs = this.diff_main(text1, text2, false);
          if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
            results[x2] = false;
          } else {
            this.diff_cleanupSemanticLossless(diffs);
            var index1 = 0;
            var index2;
            for (var y3 = 0; y3 < patches[x2].diffs.length; y3++) {
              var mod = patches[x2].diffs[y3];
              if (mod[0] !== DIFF_EQUAL) {
                index2 = this.diff_xIndex(diffs, index1);
              }
              if (mod[0] === DIFF_INSERT) {
                text = text.substring(0, start_loc + index2) + mod[1] + text.substring(start_loc + index2);
              } else if (mod[0] === DIFF_DELETE) {
                text = text.substring(0, start_loc + index2) + text.substring(start_loc + this.diff_xIndex(diffs, index1 + mod[1].length));
              }
              if (mod[0] !== DIFF_DELETE) {
                index1 += mod[1].length;
              }
            }
          }
        }
      }
    }
    text = text.substring(nullPadding.length, text.length - nullPadding.length);
    return [text, results];
  };
  diff_match_patch.prototype.patch_addPadding = function(patches) {
    var paddingLength = this.Patch_Margin;
    var nullPadding = "";
    for (var x2 = 1; x2 <= paddingLength; x2++) {
      nullPadding += String.fromCharCode(x2);
    }
    for (var x2 = 0; x2 < patches.length; x2++) {
      patches[x2].start1 += paddingLength;
      patches[x2].start2 += paddingLength;
    }
    var patch = patches[0];
    var diffs = patch.diffs;
    if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
      diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
      patch.start1 -= paddingLength;
      patch.start2 -= paddingLength;
      patch.length1 += paddingLength;
      patch.length2 += paddingLength;
    } else if (paddingLength > diffs[0][1].length) {
      var extraLength = paddingLength - diffs[0][1].length;
      diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
      patch.start1 -= extraLength;
      patch.start2 -= extraLength;
      patch.length1 += extraLength;
      patch.length2 += extraLength;
    }
    patch = patches[patches.length - 1];
    diffs = patch.diffs;
    if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
      diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
      patch.length1 += paddingLength;
      patch.length2 += paddingLength;
    } else if (paddingLength > diffs[diffs.length - 1][1].length) {
      var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
      diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
      patch.length1 += extraLength;
      patch.length2 += extraLength;
    }
    return nullPadding;
  };
  diff_match_patch.prototype.patch_splitMax = function(patches) {
    var patch_size = this.Match_MaxBits;
    for (var x2 = 0; x2 < patches.length; x2++) {
      if (patches[x2].length1 <= patch_size) {
        continue;
      }
      var bigpatch = patches[x2];
      patches.splice(x2--, 1);
      var start1 = bigpatch.start1;
      var start2 = bigpatch.start2;
      var precontext = "";
      while (bigpatch.diffs.length !== 0) {
        var patch = new diff_match_patch.patch_obj();
        var empty = true;
        patch.start1 = start1 - precontext.length;
        patch.start2 = start2 - precontext.length;
        if (precontext !== "") {
          patch.length1 = patch.length2 = precontext.length;
          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
        }
        while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {
          var diff_type = bigpatch.diffs[0][0];
          var diff_text = bigpatch.diffs[0][1];
          if (diff_type === DIFF_INSERT) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
            patch.diffs.push(bigpatch.diffs.shift());
            empty = false;
          } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            empty = false;
            patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
            bigpatch.diffs.shift();
          } else {
            diff_text = diff_text.substring(0, patch_size - patch.length1 - this.Patch_Margin);
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            if (diff_type === DIFF_EQUAL) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
            } else {
              empty = false;
            }
            patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
            if (diff_text == bigpatch.diffs[0][1]) {
              bigpatch.diffs.shift();
            } else {
              bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
            }
          }
        }
        precontext = this.diff_text2(patch.diffs);
        precontext = precontext.substring(precontext.length - this.Patch_Margin);
        var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
        if (postcontext !== "") {
          patch.length1 += postcontext.length;
          patch.length2 += postcontext.length;
          if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
            patch.diffs[patch.diffs.length - 1][1] += postcontext;
          } else {
            patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
          }
        }
        if (!empty) {
          patches.splice(++x2, 0, patch);
        }
      }
    }
  };
  diff_match_patch.prototype.patch_toText = function(patches) {
    var text = [];
    for (var x2 = 0; x2 < patches.length; x2++) {
      text[x2] = patches[x2];
    }
    return text.join("");
  };
  diff_match_patch.prototype.patch_fromText = function(textline) {
    var patches = [];
    if (!textline) {
      return patches;
    }
    var text = textline.split("\n");
    var textPointer = 0;
    var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
    while (textPointer < text.length) {
      var m2 = text[textPointer].match(patchHeader);
      if (!m2) {
        throw new Error("Invalid patch string: " + text[textPointer]);
      }
      var patch = new diff_match_patch.patch_obj();
      patches.push(patch);
      patch.start1 = parseInt(m2[1], 10);
      if (m2[2] === "") {
        patch.start1--;
        patch.length1 = 1;
      } else if (m2[2] == "0") {
        patch.length1 = 0;
      } else {
        patch.start1--;
        patch.length1 = parseInt(m2[2], 10);
      }
      patch.start2 = parseInt(m2[3], 10);
      if (m2[4] === "") {
        patch.start2--;
        patch.length2 = 1;
      } else if (m2[4] == "0") {
        patch.length2 = 0;
      } else {
        patch.start2--;
        patch.length2 = parseInt(m2[4], 10);
      }
      textPointer++;
      while (textPointer < text.length) {
        var sign = text[textPointer].charAt(0);
        try {
          var line = decodeURI(text[textPointer].substring(1));
        } catch (ex) {
          throw new Error("Illegal escape in patch_fromText: " + line);
        }
        if (sign == "-") {
          patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
        } else if (sign == "+") {
          patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
        } else if (sign == " ") {
          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
        } else if (sign == "@") {
          break;
        } else if (sign === "")
          ;
        else {
          throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
        }
        textPointer++;
      }
    }
    return patches;
  };
  diff_match_patch.patch_obj = function() {
    this.diffs = [];
    this.start1 = null;
    this.start2 = null;
    this.length1 = 0;
    this.length2 = 0;
  };
  diff_match_patch.patch_obj.prototype.toString = function() {
    var coords1, coords2;
    if (this.length1 === 0) {
      coords1 = this.start1 + ",0";
    } else if (this.length1 == 1) {
      coords1 = this.start1 + 1;
    } else {
      coords1 = this.start1 + 1 + "," + this.length1;
    }
    if (this.length2 === 0) {
      coords2 = this.start2 + ",0";
    } else if (this.length2 == 1) {
      coords2 = this.start2 + 1;
    } else {
      coords2 = this.start2 + 1 + "," + this.length2;
    }
    var text = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
    var op;
    for (var x2 = 0; x2 < this.diffs.length; x2++) {
      switch (this.diffs[x2][0]) {
        case DIFF_INSERT:
          op = "+";
          break;
        case DIFF_DELETE:
          op = "-";
          break;
        case DIFF_EQUAL:
          op = " ";
          break;
      }
      text[x2 + 1] = op + encodeURI(this.diffs[x2][1]) + "\n";
    }
    return text.join("").replace(/%20/g, " ");
  };
  module.exports = diff_match_patch;
  module.exports["diff_match_patch"] = diff_match_patch;
  module.exports["DIFF_DELETE"] = DIFF_DELETE;
  module.exports["DIFF_INSERT"] = DIFF_INSERT;
  module.exports["DIFF_EQUAL"] = DIFF_EQUAL;
});
var diff = createCommonjsModule(function(module, exports) {
  var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p2))
            d3[p2] = b3[p2];
      };
      return extendStatics(d2, b2);
    };
    return function(d2, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
  }();
  Object.defineProperty(exports, "__esModule", {value: true});
  var DiffComponent = function(_super) {
    __extends(DiffComponent2, _super);
    function DiffComponent2(props) {
      var _this = _super.call(this, props) || this;
      _this.state = {
        value: _this.props.value
      };
      _this.onChange = _this.onChange.bind(_this);
      _this.diff = _this.diff.bind(_this);
      return _this;
    }
    DiffComponent2.prototype.componentDidUpdate = function() {
      var value = this.props.value;
      if (value !== this.state.value) {
        this.setState({value});
      }
    };
    DiffComponent2.prototype.onChange = function(value) {
      this.setState({
        value
      });
      if (this.props.onChange) {
        this.props.onChange(value);
      }
    };
    DiffComponent2.prototype.diff = function() {
      var dmp = new diffMatchPatch();
      var lhString = this.state.value[0];
      var rhString = this.state.value[1];
      if (lhString.length === 0 && rhString.length === 0) {
        return [];
      }
      var diff2 = dmp.diff_main(lhString, rhString);
      dmp.diff_cleanupSemantic(diff2);
      var diffedLines = this.generateDiffedLines(diff2);
      var codeEditorSettings = this.setCodeMarkers(diffedLines);
      return codeEditorSettings;
    };
    DiffComponent2.prototype.generateDiffedLines = function(diff2) {
      var C = {
        DIFF_EQUAL: 0,
        DIFF_DELETE: -1,
        DIFF_INSERT: 1
      };
      var diffedLines = {
        left: [],
        right: []
      };
      var cursor = {
        left: 1,
        right: 1
      };
      diff2.forEach(function(chunk) {
        var chunkType = chunk[0];
        var text = chunk[1];
        var lines = text.split("\n").length - 1;
        if (text.length === 0) {
          return;
        }
        var firstChar = text[0];
        var lastChar = text[text.length - 1];
        var linesToHighlight = 0;
        switch (chunkType) {
          case C.DIFF_EQUAL:
            cursor.left += lines;
            cursor.right += lines;
            break;
          case C.DIFF_DELETE:
            if (firstChar === "\n") {
              cursor.left++;
              lines--;
            }
            linesToHighlight = lines;
            if (linesToHighlight === 0) {
              diffedLines.right.push({
                startLine: cursor.right,
                endLine: cursor.right
              });
            }
            if (lastChar === "\n") {
              linesToHighlight -= 1;
            }
            diffedLines.left.push({
              startLine: cursor.left,
              endLine: cursor.left + linesToHighlight
            });
            cursor.left += lines;
            break;
          case C.DIFF_INSERT:
            if (firstChar === "\n") {
              cursor.right++;
              lines--;
            }
            linesToHighlight = lines;
            if (linesToHighlight === 0) {
              diffedLines.left.push({
                startLine: cursor.left,
                endLine: cursor.left
              });
            }
            if (lastChar === "\n") {
              linesToHighlight -= 1;
            }
            diffedLines.right.push({
              startLine: cursor.right,
              endLine: cursor.right + linesToHighlight
            });
            cursor.right += lines;
            break;
          default:
            throw new Error("Diff type was not defined.");
        }
      });
      return diffedLines;
    };
    DiffComponent2.prototype.setCodeMarkers = function(diffedLines) {
      if (diffedLines === void 0) {
        diffedLines = {left: [], right: []};
      }
      var codeEditorSettings = [];
      var newMarkerSet = {
        left: [],
        right: []
      };
      for (var i = 0; i < diffedLines.left.length; i++) {
        var markerObj = {
          startRow: diffedLines.left[i].startLine - 1,
          endRow: diffedLines.left[i].endLine,
          type: "text",
          className: "codeMarker"
        };
        newMarkerSet.left.push(markerObj);
      }
      for (var i = 0; i < diffedLines.right.length; i++) {
        var markerObj = {
          startRow: diffedLines.right[i].startLine - 1,
          endRow: diffedLines.right[i].endLine,
          type: "text",
          className: "codeMarker"
        };
        newMarkerSet.right.push(markerObj);
      }
      codeEditorSettings[0] = newMarkerSet.left;
      codeEditorSettings[1] = newMarkerSet.right;
      return codeEditorSettings;
    };
    DiffComponent2.prototype.render = function() {
      var markers = this.diff();
      return react.createElement(split.default, {name: this.props.name, className: this.props.className, focus: this.props.focus, orientation: this.props.orientation, splits: this.props.splits, mode: this.props.mode, theme: this.props.theme, height: this.props.height, width: this.props.width, fontSize: this.props.fontSize, showGutter: this.props.showGutter, onChange: this.onChange, onPaste: this.props.onPaste, onLoad: this.props.onLoad, onScroll: this.props.onScroll, minLines: this.props.minLines, maxLines: this.props.maxLines, readOnly: this.props.readOnly, highlightActiveLine: this.props.highlightActiveLine, showPrintMargin: this.props.showPrintMargin, tabSize: this.props.tabSize, cursorStart: this.props.cursorStart, editorProps: this.props.editorProps, style: this.props.style, scrollMargin: this.props.scrollMargin, setOptions: this.props.setOptions, wrapEnabled: this.props.wrapEnabled, enableBasicAutocompletion: this.props.enableBasicAutocompletion, enableLiveAutocompletion: this.props.enableLiveAutocompletion, value: this.state.value, markers});
    };
    DiffComponent2.propTypes = {
      cursorStart: propTypes.number,
      editorProps: propTypes.object,
      enableBasicAutocompletion: propTypes.bool,
      enableLiveAutocompletion: propTypes.bool,
      focus: propTypes.bool,
      fontSize: propTypes.number,
      height: propTypes.string,
      highlightActiveLine: propTypes.bool,
      maxLines: propTypes.number,
      minLines: propTypes.number,
      mode: propTypes.string,
      name: propTypes.string,
      className: propTypes.string,
      onLoad: propTypes.func,
      onPaste: propTypes.func,
      onScroll: propTypes.func,
      onChange: propTypes.func,
      orientation: propTypes.string,
      readOnly: propTypes.bool,
      scrollMargin: propTypes.array,
      setOptions: propTypes.object,
      showGutter: propTypes.bool,
      showPrintMargin: propTypes.bool,
      splits: propTypes.number,
      style: propTypes.object,
      tabSize: propTypes.number,
      theme: propTypes.string,
      value: propTypes.array,
      width: propTypes.string,
      wrapEnabled: propTypes.bool
    };
    DiffComponent2.defaultProps = {
      cursorStart: 1,
      editorProps: {},
      enableBasicAutocompletion: false,
      enableLiveAutocompletion: false,
      focus: false,
      fontSize: 12,
      height: "500px",
      highlightActiveLine: true,
      maxLines: null,
      minLines: null,
      mode: "",
      name: "ace-editor",
      onLoad: null,
      onScroll: null,
      onPaste: null,
      onChange: null,
      orientation: "beside",
      readOnly: false,
      scrollMargin: [0, 0, 0, 0],
      setOptions: {},
      showGutter: true,
      showPrintMargin: true,
      splits: 2,
      style: {},
      tabSize: 4,
      theme: "github",
      value: ["", ""],
      width: "500px",
      wrapEnabled: true
    };
    return DiffComponent2;
  }(react.Component);
  exports.default = DiffComponent;
});
var lib = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.diff = exports.split = void 0;
  exports.diff = diff.default;
  exports.split = split.default;
  exports.default = ace_1$1.default;
});
var __pika_web_default_export_for_treeshaking__ = /* @__PURE__ */ getDefaultExportFromCjs(lib);
var react_ace_default = __pika_web_default_export_for_treeshaking__;

// build/dist/pkg/ace-builds/src-noconflict/mode-yaml.js
var modeYaml = createCommonjsModule(function(module, exports) {
  ace.define("ace/mode/yaml_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var TextHighlightRules = require2("./text_highlight_rules").TextHighlightRules;
    var YamlHighlightRules2 = function() {
      this.$rules = {
        start: [
          {
            token: "comment",
            regex: "#.*$"
          },
          {
            token: "list.markup",
            regex: /^(?:-{3}|\.{3})\s*(?=#|$)/
          },
          {
            token: "list.markup",
            regex: /^\s*[\-?](?:$|\s)/
          },
          {
            token: "constant",
            regex: "!![\\w//]+"
          },
          {
            token: "constant.language",
            regex: "[&\\*][a-zA-Z0-9-_]+"
          },
          {
            token: ["meta.tag", "keyword"],
            regex: /^(\s*\w.*?)(:(?=\s|$))/
          },
          {
            token: ["meta.tag", "keyword"],
            regex: /(\w+?)(\s*:(?=\s|$))/
          },
          {
            token: "keyword.operator",
            regex: "<<\\w*:\\w*"
          },
          {
            token: "keyword.operator",
            regex: "-\\s*(?=[{])"
          },
          {
            token: "string",
            regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
          },
          {
            token: "string",
            regex: /[|>][-+\d]*(?:$|\s+(?:$|#))/,
            onMatch: function(val, state, stack, line) {
              line = line.replace(/ #.*/, "");
              var indent = /^ *((:\s*)?-(\s*[^|>])?)?/.exec(line)[0].replace(/\S\s*$/, "").length;
              var indentationIndicator = parseInt(/\d+[\s+-]*$/.exec(line));
              if (indentationIndicator) {
                indent += indentationIndicator - 1;
                this.next = "mlString";
              } else {
                this.next = "mlStringPre";
              }
              if (!stack.length) {
                stack.push(this.next);
                stack.push(indent);
              } else {
                stack[0] = this.next;
                stack[1] = indent;
              }
              return this.token;
            },
            next: "mlString"
          },
          {
            token: "string",
            regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
          },
          {
            token: "constant.numeric",
            regex: /(\b|[+\-\.])[\d_]+(?:(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)(?=[^\d-\w]|$)/
          },
          {
            token: "constant.numeric",
            regex: /[+\-]?\.inf\b|NaN\b|0x[\dA-Fa-f_]+|0b[10_]+/
          },
          {
            token: "constant.language.boolean",
            regex: "\\b(?:true|false|TRUE|FALSE|True|False|yes|no)\\b"
          },
          {
            token: "paren.lparen",
            regex: "[[({]"
          },
          {
            token: "paren.rparen",
            regex: "[\\])}]"
          },
          {
            token: "text",
            regex: /[^\s,:\[\]\{\}]+/
          }
        ],
        mlStringPre: [
          {
            token: "indent",
            regex: /^ *$/
          },
          {
            token: "indent",
            regex: /^ */,
            onMatch: function(val, state, stack) {
              var curIndent = stack[1];
              if (curIndent >= val.length) {
                this.next = "start";
                stack.shift();
                stack.shift();
              } else {
                stack[1] = val.length - 1;
                this.next = stack[0] = "mlString";
              }
              return this.token;
            },
            next: "mlString"
          },
          {
            defaultToken: "string"
          }
        ],
        mlString: [
          {
            token: "indent",
            regex: /^ *$/
          },
          {
            token: "indent",
            regex: /^ */,
            onMatch: function(val, state, stack) {
              var curIndent = stack[1];
              if (curIndent >= val.length) {
                this.next = "start";
                stack.splice(0);
              } else {
                this.next = "mlString";
              }
              return this.token;
            },
            next: "mlString"
          },
          {
            token: "string",
            regex: ".+"
          }
        ]
      };
      this.normalizeRules();
    };
    oop.inherits(YamlHighlightRules2, TextHighlightRules);
    exports2.YamlHighlightRules = YamlHighlightRules2;
  });
  ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var Range = require2("../range").Range;
    var MatchingBraceOutdent2 = function() {
    };
    (function() {
      this.checkOutdent = function(line, input) {
        if (!/^\s+$/.test(line))
          return false;
        return /^\s*\}/.test(input);
      };
      this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);
        if (!match)
          return 0;
        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({row, column});
        if (!openBracePos || openBracePos.row == row)
          return 0;
        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column - 1), indent);
      };
      this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
      };
    }).call(MatchingBraceOutdent2.prototype);
    exports2.MatchingBraceOutdent = MatchingBraceOutdent2;
  });
  ace.define("ace/mode/folding/coffee", ["require", "exports", "module", "ace/lib/oop", "ace/mode/folding/fold_mode", "ace/range"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var BaseFoldMode = require2("./fold_mode").FoldMode;
    var Range = require2("../../range").Range;
    var FoldMode2 = exports2.FoldMode = function() {
    };
    oop.inherits(FoldMode2, BaseFoldMode);
    (function() {
      this.getFoldWidgetRange = function(session, foldStyle, row) {
        var range = this.indentationBlock(session, row);
        if (range)
          return range;
        var re2 = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re2);
        if (startLevel == -1 || line[startLevel] != "#")
          return;
        var startColumn = line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;
        while (++row < maxRow) {
          line = session.getLine(row);
          var level = line.search(re2);
          if (level == -1)
            continue;
          if (line[level] != "#")
            break;
          endRow = row;
        }
        if (endRow > startRow) {
          var endColumn = session.getLine(endRow).length;
          return new Range(startRow, startColumn, endRow, endColumn);
        }
      };
      this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        var indent = line.search(/\S/);
        var next = session.getLine(row + 1);
        var prev = session.getLine(row - 1);
        var prevIndent = prev.search(/\S/);
        var nextIndent = next.search(/\S/);
        if (indent == -1) {
          session.foldWidgets[row - 1] = prevIndent != -1 && prevIndent < nextIndent ? "start" : "";
          return "";
        }
        if (prevIndent == -1) {
          if (indent == nextIndent && line[indent] == "#" && next[indent] == "#") {
            session.foldWidgets[row - 1] = "";
            session.foldWidgets[row + 1] = "";
            return "start";
          }
        } else if (prevIndent == indent && line[indent] == "#" && prev[indent] == "#") {
          if (session.getLine(row - 2).search(/\S/) == -1) {
            session.foldWidgets[row - 1] = "start";
            session.foldWidgets[row + 1] = "";
            return "";
          }
        }
        if (prevIndent != -1 && prevIndent < indent)
          session.foldWidgets[row - 1] = "start";
        else
          session.foldWidgets[row - 1] = "";
        if (indent < nextIndent)
          return "start";
        else
          return "";
      };
    }).call(FoldMode2.prototype);
  });
  ace.define("ace/mode/yaml", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/yaml_highlight_rules", "ace/mode/matching_brace_outdent", "ace/mode/folding/coffee"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var TextMode = require2("./text").Mode;
    var YamlHighlightRules2 = require2("./yaml_highlight_rules").YamlHighlightRules;
    var MatchingBraceOutdent2 = require2("./matching_brace_outdent").MatchingBraceOutdent;
    var FoldMode2 = require2("./folding/coffee").FoldMode;
    var Mode2 = function() {
      this.HighlightRules = YamlHighlightRules2;
      this.$outdent = new MatchingBraceOutdent2();
      this.foldingRules = new FoldMode2();
      this.$behaviour = this.$defaultBehaviour;
    };
    oop.inherits(Mode2, TextMode);
    (function() {
      this.lineCommentStart = ["#"];
      this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);
        if (state == "start") {
          var match = line.match(/^.*[\{\(\[]\s*$/);
          if (match) {
            indent += tab;
          }
        }
        return indent;
      };
      this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
      };
      this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
      };
      this.$id = "ace/mode/yaml";
    }).call(Mode2.prototype);
    exports2.Mode = Mode2;
  });
  (function() {
    ace.require(["ace/mode/yaml"], function(m2) {
      if (module) {
        module.exports = m2;
      }
    });
  })();
});
var FoldMode = modeYaml.FoldMode;
var MatchingBraceOutdent = modeYaml.MatchingBraceOutdent;
var Mode = modeYaml.Mode;
var YamlHighlightRules = modeYaml.YamlHighlightRules;

// build/dist/pkg/ace-builds/src-noconflict/theme-chrome.js
var themeChrome = createCommonjsModule(function(module, exports) {
  ace.define("ace/theme/chrome", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
    exports2.isDark = false;
    exports2.cssClass = "ace-chrome";
    exports2.cssText = '.ace-chrome .ace_gutter {background: #ebebeb;color: #333;overflow : hidden;}.ace-chrome .ace_print-margin {width: 1px;background: #e8e8e8;}.ace-chrome {background-color: #FFFFFF;color: black;}.ace-chrome .ace_cursor {color: black;}.ace-chrome .ace_invisible {color: rgb(191, 191, 191);}.ace-chrome .ace_constant.ace_buildin {color: rgb(88, 72, 246);}.ace-chrome .ace_constant.ace_language {color: rgb(88, 92, 246);}.ace-chrome .ace_constant.ace_library {color: rgb(6, 150, 14);}.ace-chrome .ace_invalid {background-color: rgb(153, 0, 0);color: white;}.ace-chrome .ace_fold {}.ace-chrome .ace_support.ace_function {color: rgb(60, 76, 114);}.ace-chrome .ace_support.ace_constant {color: rgb(6, 150, 14);}.ace-chrome .ace_support.ace_type,.ace-chrome .ace_support.ace_class.ace-chrome .ace_support.ace_other {color: rgb(109, 121, 222);}.ace-chrome .ace_variable.ace_parameter {font-style:italic;color:#FD971F;}.ace-chrome .ace_keyword.ace_operator {color: rgb(104, 118, 135);}.ace-chrome .ace_comment {color: #236e24;}.ace-chrome .ace_comment.ace_doc {color: #236e24;}.ace-chrome .ace_comment.ace_doc.ace_tag {color: #236e24;}.ace-chrome .ace_constant.ace_numeric {color: rgb(0, 0, 205);}.ace-chrome .ace_variable {color: rgb(49, 132, 149);}.ace-chrome .ace_xml-pe {color: rgb(104, 104, 91);}.ace-chrome .ace_entity.ace_name.ace_function {color: #0000A2;}.ace-chrome .ace_heading {color: rgb(12, 7, 255);}.ace-chrome .ace_list {color:rgb(185, 6, 144);}.ace-chrome .ace_marker-layer .ace_selection {background: rgb(181, 213, 255);}.ace-chrome .ace_marker-layer .ace_step {background: rgb(252, 255, 0);}.ace-chrome .ace_marker-layer .ace_stack {background: rgb(164, 229, 101);}.ace-chrome .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgb(192, 192, 192);}.ace-chrome .ace_marker-layer .ace_active-line {background: rgba(0, 0, 0, 0.07);}.ace-chrome .ace_gutter-active-line {background-color : #dcdcdc;}.ace-chrome .ace_marker-layer .ace_selected-word {background: rgb(250, 250, 255);border: 1px solid rgb(200, 200, 250);}.ace-chrome .ace_storage,.ace-chrome .ace_keyword,.ace-chrome .ace_meta.ace_tag {color: rgb(147, 15, 128);}.ace-chrome .ace_string.ace_regex {color: rgb(255, 0, 0)}.ace-chrome .ace_string {color: #1A1AA6;}.ace-chrome .ace_entity.ace_other.ace_attribute-name {color: #994409;}.ace-chrome .ace_indent-guide {background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}';
    var dom = require2("../lib/dom");
    dom.importCssString(exports2.cssText, exports2.cssClass);
  });
  (function() {
    ace.require(["ace/theme/chrome"], function(m2) {
      if (module) {
        module.exports = m2;
      }
    });
  })();
});
var cssClass = themeChrome.cssClass;
var cssText = themeChrome.cssText;
var isDark = themeChrome.isDark;

// build/dist/components/CodeEditor/CodeEditor.js
var CodeEditor = (props) => {
  const [code, setCode] = useState(props.value);
  useEffect(() => {
    props.onChange(code);
  }, [code]);
  return /* @__PURE__ */ react.createElement(react_ace_default, {
    mode: "yaml",
    theme: "chrome",
    width: "100%",
    height: "100%",
    value: code,
    onChange: setCode,
    showPrintMargin: false
  });
};
var CodeEditor_default = CodeEditor;

// build/dist/components/CodeEditor/index.js
var CodeEditor_default2 = CodeEditor_default;

// build/dist/components/WaveDistributionChart/WaveDistributionChart.js
var KNOWN_TYPES = [
  "default",
  "special",
  "swarm",
  "supply",
  "upgrade",
  "boss"
];
var WaveDistributionChart = (props) => {
  const all = props.recurrent.concat(props.single);
  const distribution = all.reduce((map2, w2) => {
    if (map2[w2.type] == null) {
      map2[w2.type] = [];
    }
    map2[w2.type].push(w2);
    return map2;
  }, {});
  const counts = Object.keys(distribution).map((type2) => distribution[type2].length);
  const max = Math.max(...counts);
  const missing = Object.keys(distribution).filter((type2) => !KNOWN_TYPES.includes(type2));
  const types2 = KNOWN_TYPES.concat(missing);
  return /* @__PURE__ */ react.createElement("table", {
    className: "wave-distribution-chart"
  }, /* @__PURE__ */ react.createElement("tbody", null, types2.map((type2) => /* @__PURE__ */ react.createElement(TypeRow, {
    key: `entry-${type2}`,
    type: type2,
    max,
    distribution
  }))));
};
var TypeRow = (props) => {
  const {type: type2, max, distribution} = props;
  const count = (distribution[type2] || []).length;
  const percent = count / max;
  return /* @__PURE__ */ react.createElement("tr", null, /* @__PURE__ */ react.createElement("th", null, type2), /* @__PURE__ */ react.createElement("td", null, /* @__PURE__ */ react.createElement("div", {
    className: "bar",
    style: {flex: `${Math.floor(percent * 100)}% 0 0`}
  }), /* @__PURE__ */ react.createElement("div", {
    className: "count"
  }, count)));
};
var WaveDistributionChart_default = WaveDistributionChart;

// build/dist/components/WaveDistributionChart/index.js
var WaveDistributionChart_default2 = WaveDistributionChart_default;

// build/dist/components/WaveProgressionChart/WaveProgressionChart.js
var WaveProgressionChart = (props) => {
  const [count, setCount] = useState(props.count || 20);
  const single = props.single.slice().sort((a, b2) => b2.wave - a.wave);
  const recurrent = props.recurrent.slice().sort((a, b2) => b2.priority - a.priority);
  const waves = [];
  for (let i = 0; i < count; i++) {
    const n2 = i + 1;
    const entry = {
      winner: null,
      candidates: []
    };
    for (let w2 of single) {
      if (w2.wave === n2) {
        entry.winner = w2;
        entry.candidates.push(w2);
        break;
      }
    }
    for (let w2 of recurrent) {
      const first = w2.wave || w2.frequency;
      if (n2 >= first && (first - n2) % w2.frequency === 0) {
        if (entry.winner == null) {
          entry.winner = w2;
        }
        entry.candidates.push(w2);
      }
    }
    waves.push(entry);
  }
  return /* @__PURE__ */ react.createElement(Fragment, null, /* @__PURE__ */ react.createElement("div", {
    className: "wave-progression-chart-header"
  }, /* @__PURE__ */ react.createElement("div", {
    className: "legend"
  }, /* @__PURE__ */ react.createElement("table", {
    className: "wave-progression-chart"
  }, /* @__PURE__ */ react.createElement("tbody", null, /* @__PURE__ */ react.createElement("tr", null, /* @__PURE__ */ react.createElement("td", {
    className: "cell tiny winner"
  }), /* @__PURE__ */ react.createElement("th", {
    className: "left-align"
  }, "winner")), /* @__PURE__ */ react.createElement("tr", null, /* @__PURE__ */ react.createElement("td", {
    className: "cell tiny candidate"
  }), /* @__PURE__ */ react.createElement("th", {
    className: "left-align"
  }, "candidate")), /* @__PURE__ */ react.createElement("tr", null, /* @__PURE__ */ react.createElement("td", {
    className: "cell tiny miss"
  }), /* @__PURE__ */ react.createElement("th", {
    className: "left-align"
  }, "miss"))))), /* @__PURE__ */ react.createElement("div", {
    className: "settings"
  }, /* @__PURE__ */ react.createElement("label", {
    htmlFor: "wave-count"
  }, "Wave count: "), /* @__PURE__ */ react.createElement("input", {
    id: "wave-count",
    type: "number",
    value: count,
    onChange: (e2) => setCount(parseInt(e2.target.value))
  }))), /* @__PURE__ */ react.createElement("div", {
    className: "wave-progression-chart-container"
  }, /* @__PURE__ */ react.createElement("table", {
    className: "wave-progression-chart"
  }, /* @__PURE__ */ react.createElement("tbody", null, single.map((w2) => /* @__PURE__ */ react.createElement(WaveRow, {
    key: `single-${w2.id}`,
    wave: w2,
    waves,
    count
  })), /* @__PURE__ */ react.createElement("tr", null, /* @__PURE__ */ react.createElement("td", {
    colSpan: count + 1
  }, /* @__PURE__ */ react.createElement("hr", null))), recurrent.map((w2) => /* @__PURE__ */ react.createElement(WaveRow, {
    key: `recurrent-${w2.id}`,
    wave: w2,
    waves,
    count
  })), /* @__PURE__ */ react.createElement("tr", null, /* @__PURE__ */ react.createElement("td", {
    colSpan: count + 1
  }, /* @__PURE__ */ react.createElement("hr", null))), /* @__PURE__ */ react.createElement(WaveNumberRow, {
    count
  })))));
};
var WaveRow = (props) => {
  const {wave, waves, count} = props;
  return /* @__PURE__ */ react.createElement("tr", null, /* @__PURE__ */ react.createElement("th", null, wave.id), [...Array(count).keys()].map((i) => /* @__PURE__ */ react.createElement("td", {
    key: `${wave.id}-${i}`,
    className: getCellClass(i, wave, waves)
  })));
};
var getCellClass = (i, w2, waves) => {
  if (waves[i].winner === w2) {
    return "cell winner";
  }
  if (waves[i].candidates.includes(w2)) {
    return "cell candidate";
  }
  return "cell miss";
};
var WaveNumberRow = (props) => {
  const {count} = props;
  return /* @__PURE__ */ react.createElement("tr", null, /* @__PURE__ */ react.createElement("th", null), [...Array(count).keys()].map((i) => /* @__PURE__ */ react.createElement("td", {
    key: `wave-number-${i}`
  }, `${i + 1 < 10 ? "0" : ""}${i + 1}`)));
};
var WaveProgressionChart_default = WaveProgressionChart;

// build/dist/components/WaveProgressionChart/index.js
var WaveProgressionChart_default2 = WaveProgressionChart_default;

// build/dist/components/CodeEditor/sample.js
var sample = `
waves:
  recurrent:
    def1:
      type: default
      priority: 1
      frequency: 1
      monsters:
        zombies: 10
        skeletons: 4
        exploding_sheep: 5
    def2:
      type: default
      priority: 2
      frequency: 1
      wave: 5
      monsters:
        zombies: 10
        skeletons: 6
        creepers: 4
    spec1:
      type: special
      priority: 5
      frequency: 4
      wave: 4
      monsters:
        powered_creepers: 10
        angry_wolves: 10
        zombie_pigmen: 10
    upgrade1:
      type: upgrade
      priority: 7
      frequency: 10
      wave: 10
      upgrades:
        all: potion:instant_heal:2
        Archer: arrow:64
        Oddjob: tnt:2, netherrack
  single:
    swarm1:
      type: swarm
      wave: 7
      monster: slimes
      amount: medium
    boss1:
      type: boss
      wave: 9
      monster: spider
      health: medium
      abilities: fire-aura, disorient-target, fireballs, throw-nearby
      effects: speed:3:20, wither, increase_damage:1
      ability-interval: 5
    boss2:
      type: boss
      wave: 13
      monster: zombie_pigman
      health: high
      abilities: root-target, arrows, fetch-distant, fire-aura
      drops: lever, stone_button
    upgrade2:
      type: upgrade
      wave: 14
      upgrades:
        all: potion:instant_heal:2
        Knight:
          armor: diamond_helmet
          items: diamond_sword sharpness:2;knockback:1
        Tank:
          items: iron_sword knockback:3
        Oddjob:
          armor: iron_chestplate, iron_leggings
        Wizard:
          permissions:
          - magicspells.cast.ChainLightning
    boss3:
      type: boss
      wave: 16
      monster: wolf
      health: psycho
      abilities: warp-to-player, fire-aura, throw-nearby, fireballs, fetch-target, arrows
      effects: slow:1
      ability-interval: 1
      reward: diamond_chestplate
    supply1:
      type: supply
      wave: 19
      monsters:
        cows: 10
        pigs: 5
      drops: grilled_pork, cooked_chicken, cooked_beef, cooked_fish:2
    boss4:
      type: boss
      wave: 20
      monster: blaze
      health: low
      abilities: fire-aura, throw-nearby
      effects: speed
      reward: diamond_helmet
`;
var sample_default = sample.trim();

// build/dist/pages/WaveAnalyzer/WaveAnalyzer.js
var WaveAnalyzer = () => {
  const [content, setContent] = useState(sample_default);
  const [doc, setDoc] = useState({});
  const [recurrent, setRecurrent] = useState([]);
  const [single, setSingle] = useState([]);
  useEffect(() => {
    try {
      const result = js_yaml_default.load(content);
      setDoc(result);
    } catch (e2) {
    }
  }, [content]);
  useEffect(() => {
    const waves = doc["waves"];
    if (waves == null) {
      return;
    }
    if (waves["recurrent"] != null) {
      const section = waves["recurrent"];
      const result = [];
      Object.keys(section).forEach((key) => result.push({
        id: key,
        ...section[key]
      }));
      setRecurrent(result);
    }
    if (waves["single"] != null) {
      const section = waves["single"];
      const result = [];
      Object.keys(section).forEach((key) => result.push({
        id: key,
        ...section[key]
      }));
      setSingle(result);
    }
  }, [doc]);
  return /* @__PURE__ */ react.createElement("div", {
    className: "wave-analyzer-container"
  }, /* @__PURE__ */ react.createElement("div", {
    className: "wave-analyzer-header"
  }, /* @__PURE__ */ react.createElement("h1", null, "Wave Analyzer"), /* @__PURE__ */ react.createElement("p", null, "Paste your waves section into the text area on the left and get a visualization of its progression and a rundown of the composition on the right.")), /* @__PURE__ */ react.createElement("div", {
    className: "wave-analyzer-content"
  }, /* @__PURE__ */ react.createElement(SplitPane_default2, null, /* @__PURE__ */ react.createElement(CodeEditor_default2, {
    value: content,
    onChange: setContent
  }), /* @__PURE__ */ react.createElement("div", {
    className: "wave-analyzer-details"
  }, /* @__PURE__ */ react.createElement("h3", null, "Wave distribution"), /* @__PURE__ */ react.createElement("p", null, "Bar graph showing the distribution of wave types across all waves in the configuration."), /* @__PURE__ */ react.createElement(WaveDistributionChart_default2, {
    recurrent,
    single
  }), /* @__PURE__ */ react.createElement("h3", null, "Wave progression"), /* @__PURE__ */ react.createElement("p", null, "This chart lists all the waves of the configuration with single waves on top (ordered by ", /* @__PURE__ */ react.createElement("code", null, "wave"), ") and recurrent waves at the bottom (ordered by ", /* @__PURE__ */ react.createElement("code", null, "priority"), "). For each wave number (x-axis), the chart marks the candidates and the winner."), /* @__PURE__ */ react.createElement(WaveProgressionChart_default2, {
    recurrent,
    single,
    count: 30
  })))));
};
var WaveAnalyzer_default = WaveAnalyzer;

// build/dist/pages/WaveAnalyzer/index.js
var WaveAnalyzer_default2 = WaveAnalyzer_default;

// build/dist/App.js
import maximizeIcon from "./icons/maximize.svg";
import restoreIcon from "./icons/restore.svg";
var App = () => {
  const [maximized, setMaximized] = useState(false);
  return /* @__PURE__ */ react.createElement(HashRouter, {
    basename: "/"
  }, /* @__PURE__ */ react.createElement("div", {
    className: "app"
  }, /* @__PURE__ */ react.createElement("nav", null, /* @__PURE__ */ react.createElement("span", {
    className: "title"
  }, "Mule's Tools"), /* @__PURE__ */ react.createElement("ul", null, /* @__PURE__ */ react.createElement("li", null, /* @__PURE__ */ react.createElement(Link, {
    to: "/"
  }, "Home")), /* @__PURE__ */ react.createElement("li", null, /* @__PURE__ */ react.createElement(Link, {
    to: "/wave-analyzer"
  }, "Wave Analyzer")))), /* @__PURE__ */ react.createElement("main", {
    className: maximized ? "" : "sheet"
  }, /* @__PURE__ */ react.createElement(Switch, null, /* @__PURE__ */ react.createElement(Route, {
    exact: true,
    path: "/"
  }, /* @__PURE__ */ react.createElement(Home_default, null)), /* @__PURE__ */ react.createElement(Route, {
    path: "/wave-analyzer"
  }, /* @__PURE__ */ react.createElement(WaveAnalyzer_default2, null)))), /* @__PURE__ */ react.createElement("img", {
    className: "maximize-button",
    src: maximized ? restoreIcon : maximizeIcon,
    alt: maximized ? "Restore" : "Maximize",
    onClick: () => setMaximized(!maximized)
  })));
};
var App_default = App;

// build/dist/index.js
react_dom_default.render(/* @__PURE__ */ react.createElement(react.StrictMode, null, /* @__PURE__ */ react.createElement(App_default, null)), document.getElementById("root"));
//# sourceMappingURL=index.js.map
